from __future__ import annotations

from fastapi import FastAPI, HTTPException, Request
from fastapi import WebSocket, WebSocketDisconnect
from fastapi.responses import HTMLResponse, Response, JSONResponse, StreamingResponse, FileResponse
from starlette.middleware.trustedhost import TrustedHostMiddleware
from starlette.responses import RedirectResponse
from shamell_shared import RequestIDMiddleware, configure_cors, add_standard_health, setup_json_logging
from pydantic import BaseModel
from sqlalchemy import (
    create_engine as _sa_create_engine,
    String as _sa_String,
    Integer as _sa_Integer,
    Boolean as _sa_Boolean,
    DateTime as _sa_DateTime,
    Text as _sa_Text,
    UniqueConstraint as _sa_UniqueConstraint,
    func as _sa_func,
    select as _sa_select,
    text as _sa_text,
    Float as _sa_Float,
)
from sqlalchemy.orm import (
    DeclarativeBase as _sa_DeclarativeBase,
    Mapped as _sa_Mapped,
    mapped_column as _sa_mapped_column,
    Session as _sa_Session,
)
import httpx
import logging
import os
import asyncio, json as _json, re
import ipaddress
import math
from pathlib import Path
import secrets as _secrets
import time, uuid as _uuid
from typing import Any
from io import BytesIO
try:
    from PIL import Image, ImageDraw, ImageFont
except Exception:
    Image = None
try:
    import qrcode as _qr
except Exception:
    _qr = None
try:
    from reportlab.pdfgen import canvas as _pdfcanvas
    from reportlab.lib.pagesizes import A4
    from reportlab.lib.utils import ImageReader as _RLImageReader
except Exception:
    _pdfcanvas = None


def _env_or(key: str, default: str) -> str:
    v = os.getenv(key)
    return v if v is not None else default

from .events import emit_event


_ENV_LOWER = _env_or("ENV", "dev").lower()
# Never expose interactive API docs by default in prod.
_ENABLE_DOCS = _ENV_LOWER in ("dev", "test") or os.getenv("ENABLE_API_DOCS_IN_PROD", "").lower() in (
    "1",
    "true",
    "yes",
    "on",
)
app = FastAPI(
    title="Shamell BFF",
    version="0.1.0",
    docs_url="/docs" if _ENABLE_DOCS else None,
    redoc_url="/redoc" if _ENABLE_DOCS else None,
    openapi_url="/openapi.json" if _ENABLE_DOCS else None,
)
setup_json_logging()
app.add_middleware(RequestIDMiddleware)
configure_cors(app, os.getenv("ALLOWED_ORIGINS", ""))
add_standard_health(app)

# Trusted hosts: mitigate Host header attacks and misrouting.
_allowed_hosts_raw = (os.getenv("ALLOWED_HOSTS") or "").strip()
if _allowed_hosts_raw:
    _allowed_hosts = [h.strip() for h in _allowed_hosts_raw.split(",") if h.strip()]
    # Keep local health checks working even if ALLOWED_HOSTS is minimal.
    for _extra in ("localhost", "127.0.0.1"):
        if _extra not in _allowed_hosts:
            _allowed_hosts.append(_extra)
    app.add_middleware(TrustedHostMiddleware, allowed_hosts=_allowed_hosts)

_HTTPX_CLIENT: httpx.Client | None = None
_HTTPX_ASYNC_CLIENT: httpx.AsyncClient | None = None
# Include PMS router directly for monolith/internal mode so Cloudbeds UI works via BFF.
try:
    from apps.pms.app.main import router as pms_router  # type: ignore
    app.include_router(pms_router, prefix="/pms")  # type: ignore[arg-type]
except Exception:
    pms_router = None  # type: ignore


def _httpx_client() -> httpx.Client:
    """Shared sync HTTPX client (keep-alive, pooled)."""
    global _HTTPX_CLIENT
    if _HTTPX_CLIENT is None:
        _HTTPX_CLIENT = httpx.Client(
            timeout=10.0,
            limits=httpx.Limits(max_keepalive_connections=20, max_connections=100),
        )
    return _HTTPX_CLIENT


def _httpx_async_client() -> httpx.AsyncClient:
    """Shared async HTTPX client (keep-alive, pooled)."""
    global _HTTPX_ASYNC_CLIENT
    if _HTTPX_ASYNC_CLIENT is None:
        _HTTPX_ASYNC_CLIENT = httpx.AsyncClient(
            timeout=10.0,
            limits=httpx.Limits(max_keepalive_connections=20, max_connections=100),
        )
    return _HTTPX_ASYNC_CLIENT

_audit_logger = logging.getLogger("shamell.audit")
_metrics_logger = logging.getLogger("shamell.metrics")
_AUDIT_EVENTS: list[dict[str, Any]] = []
_MAX_AUDIT_EVENTS = 2000


class _AuditInMemoryHandler(logging.Handler):
    """
    Kapselt alle Audit-Logs (logger \"shamell.audit\") in einem kleinen
    In-Memory-Puffer, damit /admin/stats und /admin/guardrails auch
    Domain-Events (z.B. freight/courier) sehen.
    """

    def emit(self, record: logging.LogRecord) -> None:  # type: ignore[override]
        try:
            msg = record.msg
            if isinstance(msg, dict):
                payload = dict(msg)
            else:
                payload = {
                    "event": "audit",
                    "action": record.getMessage(),
                }
            if "ts_ms" not in payload:
                payload["ts_ms"] = int(time.time() * 1000)
            _AUDIT_EVENTS.append(payload)  # type: ignore[arg-type]
            if len(_AUDIT_EVENTS) > _MAX_AUDIT_EVENTS:
                del _AUDIT_EVENTS[: len(_AUDIT_EVENTS) - _MAX_AUDIT_EVENTS]
        except Exception:
            # Audit buffer must never break normal flows
            pass


_audit_logger.addHandler(_AuditInMemoryHandler())
_audit_logger.setLevel(logging.INFO)

# Optional in-memory mapping between building orders and courier shipments.
# This keeps coupling lightweight and avoids schema changes in Commerce while
# still allowing the BFF to enforce 2-step confirmation (order + shipment).
_BUILDING_ORDER_SHIPMENTS: dict[int, str] = {}

# Simple background stats (monolith heartbeat etc.)
_BG_STATS: dict[str, Any] = {"last_tick_ms": None}

# Small in-memory caches for frequently used lists
_BUS_CITIES_CACHE: dict[str, Any] = {"ts": 0.0, "data": None}
_COMMERCE_PRODUCTS_CACHE: dict[str, Any] = {"ts": 0.0, "data": None}
_AGRICULTURE_LISTINGS_CACHE: dict[str, Any] = {"ts": 0.0, "data": None}
_LIVESTOCK_LISTINGS_CACHE: dict[str, Any] = {"ts": 0.0, "data": None}
_TAXI_ADMIN_SUMMARY_CACHE: dict[str, Any] = {"ts": 0.0, "data": None}
_OSM_GEOCODE_CACHE: dict[str, tuple[float, Any]] = {}
_OSM_REVERSE_CACHE: dict[tuple[float, float], tuple[float, Any]] = {}
_OSM_TAXI_CACHE: dict[tuple[float, float, float, float], tuple[float, Any]] = {}

# Simple Moments cache / DB will be handled via dedicated SQLAlchemy models below.

# In-memory VoIP signaling connections (device_id -> WebSocket)
_CALL_WS_CONNECTIONS: dict[str, WebSocket] = {}


def _haversine_km(lat1: float, lon1: float, lat2: float, lon2: float) -> float:
    """
    Great-circle distance between two points on Earth (in km).
    Used for simple fleet heuristics (nearest driver, stop ordering).
    """
    try:
        r = 6371.0
        phi1 = math.radians(lat1)
        phi2 = math.radians(lat2)
        dphi = math.radians(lat2 - lat1)
        dlambda = math.radians(lon2 - lon1)
        a = math.sin(dphi / 2.0) ** 2 + math.cos(phi1) * math.cos(phi2) * math.sin(dlambda / 2.0) ** 2
        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1.0 - a))
        return float(r * c)
    except Exception:
        return 0.0

# In-memory payment guardrails (best-effort)
_PAY_VELOCITY_WALLET: dict[str, list[float]] = {}
_PAY_VELOCITY_DEVICE: dict[str, list[float]] = {}
PAY_VELOCITY_WINDOW_SECS = int(os.getenv("PAY_VELOCITY_WINDOW_SECS", "60"))
PAY_VELOCITY_MAX_PER_WALLET = int(os.getenv("PAY_VELOCITY_MAX_PER_WALLET", "20"))
PAY_VELOCITY_MAX_PER_DEVICE = int(os.getenv("PAY_VELOCITY_MAX_PER_DEVICE", "40"))
PAY_MAX_PER_TXN_CENTS = int(os.getenv("PAY_MAX_PER_TXN_CENTS", "0"))  # 0 = disabled


def _legacy_console_removed_page(title: str = "Shamell") -> HTMLResponse:
    """
    Unified minimal page for all legacy HTML consoles.
    Keeps routes functional but clearly points to the Shamell UI.
    """
    html = f"""
<!doctype html>
<html><head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>{title}</title>
  <style>
    body{{font-family:sans-serif;margin:20px;max-width:640px;color:#0f172a;background:#ffffff;}}
    h1{{margin-bottom:8px;}}
    p{{margin:6px 0;}}
    code{{background:#f3f4f6;padding:2px 4px;border-radius:3px;font-size:13px;}}
  </style>
</head><body>
  <h1>{title}</h1>
  <p>This legacy HTML console has been removed.</p>
  <p>Please use the Shamell web app as the admin UI.</p>
  <p><code>http://localhost:8081</code></p>
</body></html>
"""
    return HTMLResponse(content=html)


@app.middleware("http")
async def _security_headers_mw(request: Request, call_next):
    """
    Adds basic security headers and can optionally enforce a
    global maintenance mode.
    """
    # Global maintenance mode: all non-admin / non-health routes are
    # answered with 503. Admins can still operate the system.
    if MAINTENANCE_MODE_ENABLED:
        path = request.url.path
        if not (path.startswith("/admin") or path.startswith("/health")):
            return JSONResponse(
                status_code=503,
                content={
                    "status": "maintenance",
                    "detail": "service temporarily unavailable",
                },
                headers={"Retry-After": "60"},
            )

    response = await call_next(request)
    if SECURITY_HEADERS_ENABLED:
        try:
            headers = response.headers
            headers.setdefault("X-Content-Type-Options", "nosniff")
            headers.setdefault("X-Frame-Options", "DENY")
            headers.setdefault("Referrer-Policy", "strict-origin-when-cross-origin")
            headers.setdefault(
                "Content-Security-Policy",
                "default-src 'self'; img-src 'self' data:; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; connect-src 'self' https:; frame-ancestors 'none'",
            )
        except Exception:
            # Security headers must never break normal flows
            pass
    return response

async def _start_bg_tasks():
    # Lightweight heartbeat only in dev/staging
    if _env_or("ENABLE_BFF_BG", "false").lower() != "true":
        return

    async def _loop():
        while True:
            try:
                _BG_STATS["last_tick_ms"] = int(time.time() * 1000)
            except Exception:
                pass
            await asyncio.sleep(60)

    asyncio.create_task(_loop())

# Register startup hook without deprecated decorator
app.router.on_startup.append(_start_bg_tasks)


async def _shutdown_http_clients():
    """Close shared HTTPX clients on shutdown."""
    global _HTTPX_CLIENT, _HTTPX_ASYNC_CLIENT
    try:
        if _HTTPX_CLIENT is not None:
            _HTTPX_CLIENT.close()
    except Exception:
        pass
    try:
        if _HTTPX_ASYNC_CLIENT is not None:
            await _HTTPX_ASYNC_CLIENT.aclose()
    except Exception:
        pass
    _HTTPX_CLIENT = None
    _HTTPX_ASYNC_CLIENT = None


app.router.on_shutdown.append(_shutdown_http_clients)

# --- Lightweight metrics intake (optional) ---
_METRICS = []  # in-memory ring buffer

@app.post("/metrics")
async def metrics_ingest(req: Request):
    if _ENV_LOWER not in ("dev", "test") and not METRICS_INGEST_SECRET:
        # Avoid unauthenticated log/memory spam in prod/staging when the secret
        # is not configured.
        raise HTTPException(status_code=403, detail="metrics ingest disabled")
    if METRICS_INGEST_SECRET:
        provided = (req.headers.get("X-Metrics-Secret") or "").strip()
        if provided != METRICS_INGEST_SECRET:
            raise HTTPException(status_code=401, detail="metrics auth required")
    try:
        body = await req.json()
    except Exception:
        body = {}
    try:
        dev = req.headers.get("X-Device-ID") or ""
    except Exception:
        dev = ""
    item = {"ts": int(time.time()*1000), "device": dev, **body}
    _METRICS.append(item)
    if len(_METRICS) > 2000:
        del _METRICS[:len(_METRICS)-2000]
    try:
        _metrics_logger.info(item)
    except Exception:
        # Metrics logging must never break main flows
        pass
    return {"ok": True}

@app.get("/metrics", response_class=JSONResponse)
def metrics_dump(request: Request, limit: int = 200):
    _require_admin_v2(request)
    return {"items": _METRICS[-limit:]}


@app.get("/admin/metrics", response_class=HTMLResponse)
def metrics_html(request: Request, limit: int = 200):
    """
    Simple HTML view for metrics from Perf/_metrics.
    Black text on white background, without visual effects.
    """
    _require_admin_v2(request)
    # Legacy HTML dashboard removed – use Shamell instead.
    return _legacy_console_removed_page("Shamell · Metrics")

    # Build rows for aggregates
    sample_rows: list[str] = []
    for metric, st in sorted(sample_stats.items()):
        cnt = int(st.get("count", 0.0) or 0)
        if cnt <= 0:
            continue
        total = st.get("sum", 0.0) or 0.0
        avg = total / cnt if cnt else 0.0
        vmin = st.get("min", 0.0) or 0.0
        vmax = st.get("max", 0.0) or 0.0
        sample_rows.append(
            f"<tr><td>{metric}</td><td>{cnt}</td><td>{avg:.1f}</td><td>{vmin:.0f}</td><td>{vmax:.0f}</td></tr>"
        )
    if not sample_rows:
        sample_rows.append(
            "<tr><td colspan='5'>No sample metrics yet.</td></tr>"
        )
    sample_html = "\n".join(sample_rows)

    action_rows: list[str] = []
    for label, cnt in sorted(action_counts.items(), key=lambda x: (-x[1], x[0])):
        action_rows.append(f"<tr><td>{label}</td><td>{cnt}</td></tr>")
    if not action_rows:
        action_rows.append("<tr><td colspan='2'>No action metrics yet.</td></tr>")
    action_html = "\n".join(action_rows)

    # Raw event rows
    rows: list[str] = []
    for it in items:
        try:
            ts = it.get("ts", "")
            mtype = it.get("type", "")
            dev_id = it.get("device", "")
            data = it.get("data", {}) or {}
            label = ""
            ms = ""
            if isinstance(data, dict):
                label = str(data.get("label", ""))
                ms_val = data.get("ms")
                if ms_val is not None:
                    ms = str(ms_val)
        except Exception:
            ts = it.get("ts", "")
            mtype = it.get("type", "")
            dev_id = it.get("device", "")
            label = ""
            ms = ""
        rows.append(
            f"<tr><td>{ts}</td><td>{mtype}</td><td>{label}</td><td>{ms}</td><td>{dev_id}</td></tr>"
        )
    rows_html = "\n".join(rows)
    html = f"""
<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Metrics</title>
    <style>
      body {{ font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif; background:#ffffff; color:#000000; }}
      table {{ border-collapse: collapse; width: 100%; }}
      th, td {{ border: 1px solid #dddddd; padding: 4px 6px; font-size: 12px; }}
      th {{ background: #f5f5f5; text-align: left; }}
      caption {{ text-align:left; font-weight:bold; margin-bottom:8px; }}
    </style>
  </head>
  <body>
    <h1>Metrics</h1>
    <p>Last {len(items)} entries from /metrics.</p>
    <h2>Aggregates (samples, last {len(items)} events)</h2>
    <table>
      <caption>Samples (value_ms)</caption>
      <thead>
        <tr><th>metric</th><th>count</th><th>avg_ms</th><th>min_ms</th><th>max_ms</th></tr>
      </thead>
      <tbody>
        {sample_html}
      </tbody>
    </table>
    <h2>Action counts</h2>
    <table>
      <caption>Actions</caption>
      <thead>
        <tr><th>label</th><th>count</th></tr>
      </thead>
      <tbody>
        {action_html}
      </tbody>
    </table>
    <h2>Raw events</h2>
    <table>
      <caption>Events</caption>
      <thead>
        <tr><th>ts</th><th>type</th><th>label</th><th>ms</th><th>device</th></tr>
      </thead>
      <tbody>
        {rows_html}
      </tbody>
    </table>
  </body>
</html>
"""
    return HTMLResponse(content=html)


@app.get("/admin/stats", response_class=JSONResponse)
def admin_stats(request: Request, limit: int = 200):
    """
    JSON variant of the most important metric aggregates for the Superadmin UI.
    Returns sample metrics (avg/min/max) and action counts.
    """
    _require_admin_v2(request)
    items = _METRICS[-limit:]

    action_counts: dict[str, int] = {}
    sample_stats: dict[str, dict[str, float]] = {}

    for it in items:
        try:
            mtype = it.get("type", "")
            data = it.get("data", {}) or {}
            if not isinstance(data, dict):
                continue
            if mtype == "action":
                label = str(data.get("label", "") or "")
                if label:
                    action_counts[label] = action_counts.get(label, 0) + 1
            elif mtype == "sample":
                metric = str(data.get("metric", "") or "")
                val = data.get("value_ms")
                if metric and isinstance(val, (int, float)):
                    v = float(val)
                    st = sample_stats.get(metric)
                    if st is None:
                        st = {"count": 0.0, "sum": 0.0, "min": v, "max": v}
                        sample_stats[metric] = st
                    st["count"] += 1.0
                    st["sum"] += v
                    if v < st["min"]:
                        st["min"] = v
                    if v > st["max"]:
                        st["max"] = v
        except Exception:
            continue

    samples_out: dict[str, dict[str, float]] = {}
    for metric, st in sample_stats.items():
        cnt = int(st.get("count", 0.0) or 0)
        if cnt <= 0:
            continue
        total = st.get("sum", 0.0) or 0.0
        avg = total / cnt if cnt else 0.0
        samples_out[metric] = {
            "count": float(cnt),
            "avg_ms": avg,
            "min_ms": st.get("min", 0.0) or 0.0,
            "max_ms": st.get("max", 0.0) or 0.0,
        }

    # Guardrail counts from audit log (best-effort)
    guardrail_counts: dict[str, int] = {}
    building_counts: dict[str, int] = {}
    freight_guardrail_counts: dict[str, int] = {}
    try:
        # consider only recent audit events
        tail = _AUDIT_EVENTS[-limit:]
        for e in tail:
            action = str(e.get("action", "") or "")
            if not action:
                continue
            if "guardrail" in action:
                guardrail_counts[action] = guardrail_counts.get(action, 0) + 1
                if action.startswith("freight_"):
                    freight_guardrail_counts[action] = freight_guardrail_counts.get(action, 0) + 1
            if action.startswith("building_order_"):
                key = action
                building_counts[key] = building_counts.get(key, 0) + 1
    except Exception:
        guardrail_counts = {}
        building_counts = {}
        freight_guardrail_counts = {}

    return {
        "samples": samples_out,
        "actions": action_counts,
        "total_events": len(items),
        "guardrails": guardrail_counts,
        "freight_guardrails": freight_guardrail_counts,
        "building_orders": building_counts,
    }


@app.get("/admin/finance_stats", response_class=JSONResponse)
def admin_finance_stats(request: Request, from_iso: str | None = None, to_iso: str | None = None):
    """
    Finance statistics over the Payments domain service:
    - total_txns: number of transactions in the period
    - total_fee_cents: total fees charged in the period
    """
    _require_admin_v2(request)

    # For monolithic deployments we rely on internal calls.
    if not _use_pay_internal():
        raise HTTPException(status_code=500, detail="payments internal not available")

    from_iso_eff = from_iso
    to_iso_eff = to_iso

    # Optional default period (last 24h) when nothing is provided
    if from_iso_eff is None and to_iso_eff is None:
        try:
            now = time.time()
            end = int(now)
            start = end - 86400
            from_iso_eff = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime(start))
            to_iso_eff = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime(end))
        except Exception:
            from_iso_eff = None
            to_iso_eff = None

    total_txns = 0
    total_fee_cents = 0
    fee_from_ts: str | None = None
    fee_to_ts: str | None = None

    try:
        with _pay_internal_session() as s:
            # Transaction count
            try:
                cnt = _pay_admin_txns_count(
                    wallet_id=None,
                    from_iso=from_iso_eff,
                    to_iso=to_iso_eff,
                    s=s,
                )
                if isinstance(cnt, dict):
                    total_txns = int(cnt.get("count") or 0)
            except Exception:
                total_txns = 0
            # Fee sum
            try:
                fees = _pay_fees_summary(from_iso=from_iso_eff, to_iso=to_iso_eff, s=s)
                if hasattr(fees, "dict"):
                    data = fees.dict()  # type: ignore[call-arg]
                elif isinstance(fees, dict):
                    data = fees
                else:
                    data = {}
                total_fee_cents = int(data.get("total_fee_cents") or 0)
                fee_from_ts = data.get("from_ts") or from_iso_eff
                fee_to_ts = data.get("to_ts") or to_iso_eff
            except Exception:
                total_fee_cents = 0
    except Exception as e:
        raise HTTPException(status_code=502, detail=f"finance stats error: {e}")

    return {
        "from_iso": fee_from_ts or from_iso_eff,
        "to_iso": fee_to_ts or to_iso_eff,
        "total_txns": total_txns,
        "total_fee_cents": total_fee_cents,
    }


@app.get("/admin/guardrails", response_class=HTMLResponse)
def guardrails_html(request: Request, limit: int = 200) -> HTMLResponse:
    """
    Minimal admin dashboard for guardrail audit events (legacy HTML).
    Shows recent audit entries whose action contains "guardrail".
    """
    _require_admin_v2(request)
    try:
        tail = list(_AUDIT_EVENTS[-limit:])
    except Exception:
        tail = []
    guardrails = [
        e for e in tail
        if isinstance(e, dict) and "guardrail" in str(e.get("action", "")).lower()
    ]
    rows = []
    for e in guardrails:
        try:
            rows.append(
                f"<tr><td>{e.get('ts_ms','')}</td>"
                f"<td>{e.get('action','')}</td>"
                f"<td>{e.get('phone','') or ''}</td>"
                f"<td><code>{_json.dumps({k:v for k,v in e.items() if k not in ('ts_ms','action','phone')})}</code></td></tr>"
            )
        except Exception:
            continue
    if not rows:
        rows.append("<tr><td colspan='4'>No guardrail events yet.</td></tr>")
    html = f"""
<!doctype html>
<html><head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Shamell · Guardrails</title>
  <style>
    body{{font-family:sans-serif;margin:16px;max-width:900px;color:#0f172a;}}
    table{{border-collapse:collapse;width:100%;}}
    th,td{{border:1px solid #e5e7eb;padding:6px 8px;font-size:13px;text-align:left;}}
    th{{background:#f9fafb;font-weight:600;}}
    code{{font-size:12px;background:#f3f4f6;padding:2px 4px;border-radius:4px;}}
  </style>
</head><body>
  <h1>Guardrail Audit</h1>
  <p>Last {len(guardrails)} guardrail events (max {limit}). Non-guardrail audit items are hidden.</p>
  <table>
    <thead><tr><th>ts_ms</th><th>action</th><th>phone</th><th>details</th></tr></thead>
    <tbody>
      {"".join(rows)}
    </tbody>
  </table>
</body></html>
"""
    return HTMLResponse(content=html)


@app.get("/admin/quality", response_class=HTMLResponse)
def admin_quality(request: Request, limit: int = 200) -> HTMLResponse:
    """
    Compact quality dashboard for admins (legacy HTML).
    Replaced by Shamell; this route now only returns a minimal notice.
    """
    _require_admin_v2(request)
    # Legacy HTML dashboard removed – please use Shamell instead.
    return _legacy_console_removed_page("Shamell · Quality")


@app.get("/admin/info", response_class=JSONResponse)
def admin_info(request: Request):
    """
    Compact admin info about environment and domain modes.
    Only accessible for admins/superadmins.
    """
    _require_admin_v2(request)
    env = _env_or("ENV", "dev")
    monolith = bool(_env_or("MONOLITH_MODE", "0") not in ("0", "false", "False"))
    domains: dict[str, dict[str, Any]] = {}
    try:
        domains["payments"] = {
            "internal": _use_pay_internal(),
            "base_url": PAYMENTS_BASE,
        }
    except Exception:
        domains["payments"] = {"internal": False, "base_url": PAYMENTS_BASE}
    try:
        domains["taxi"] = {
            "internal": _use_taxi_internal(),  # type: ignore[name-defined]
            "base_url": TAXI_BASE,
        }
    except Exception:
        domains["taxi"] = {"internal": False, "base_url": TAXI_BASE}
    try:
        domains["bus"] = {
            "internal": _use_bus_internal(),
            "base_url": BUS_BASE,
        }
    except Exception:
        domains["bus"] = {"internal": False, "base_url": BUS_BASE}
    try:
        domains["food"] = {
            "internal": _use_food_internal(),  # type: ignore[name-defined]
            "base_url": None,
        }
    except Exception:
        domains["food"] = {"internal": False, "base_url": None}
    try:
        domains["stays"] = {
            "internal": _use_stays_internal(),  # type: ignore[name-defined]
            "base_url": STAYS_BASE,
        }
    except Exception:
        domains["stays"] = {"internal": False, "base_url": STAYS_BASE}
    try:
        domains["commerce"] = {
            "internal": _use_commerce_internal(),
            "base_url": COMMERCE_BASE,
        }
    except Exception:
        domains["commerce"] = {"internal": False, "base_url": COMMERCE_BASE}
    try:
        domains["doctors"] = {
            "internal": _use_doctors_internal(),
            "base_url": DOCTORS_BASE,
        }
    except Exception:
        domains["doctors"] = {"internal": False, "base_url": DOCTORS_BASE}
    try:
        domains["flights"] = {
            "internal": _use_flights_internal(),
            "base_url": FLIGHTS_BASE,
        }
    except Exception:
        domains["flights"] = {"internal": False, "base_url": FLIGHTS_BASE}
    try:
        domains["agriculture"] = {
            "internal": _use_agriculture_internal(),
            "base_url": AGRICULTURE_BASE,
        }
    except Exception:
        domains["agriculture"] = {"internal": False, "base_url": AGRICULTURE_BASE}
    try:
        domains["livestock"] = {
            "internal": _use_livestock_internal(),
            "base_url": LIVESTOCK_BASE,
        }
    except Exception:
        domains["livestock"] = {"internal": False, "base_url": LIVESTOCK_BASE}
    try:
        domains["equipment"] = {
            "internal": _use_equipment_internal(),
            "base_url": EQUIPMENT_BASE,
        }
    except Exception:
        domains["equipment"] = {"internal": False, "base_url": EQUIPMENT_BASE}

    return {"env": env, "monolith": monolith, "security_headers": SECURITY_HEADERS_ENABLED, "domains": domains}

# --- Wallet WebSocket (dev) ---
@app.websocket("/ws/payments/wallets/{wallet_id}")
async def ws_wallet_events(websocket: WebSocket, wallet_id: str):
    # Simple polling-based wallet credit stream over WS
    if _ENV_LOWER not in ("dev", "test") and os.getenv("ENABLE_WALLET_WS_IN_PROD", "").lower() not in (
        "1",
        "true",
        "yes",
        "on",
    ):
        # This endpoint is intentionally dev/test-only by default.
        await websocket.close(code=1008)
        return
    await websocket.accept()
    last_key = None
    try:
        while True:
            try:
                # fetch latest txn
                client = _httpx_async_client()
                r = await client.get(
                    _payments_url(f"/txns"),
                    params={"wallet_id": wallet_id, "limit": 1},
                    headers=_payments_headers(),
                )
                arr = r.json() if r.headers.get('content-type','').startswith('application/json') else []
                if arr:
                    t = arr[0]
                    key = f"{t.get('id','')}|{t.get('amount_cents',0)}|{t.get('created_at','')}"
                    if key and key != last_key:
                        last_key = key
                        await websocket.send_json({
                            "kind": "wallet_txn",
                            "wallet_id": wallet_id,
                            "amount_cents": t.get('amount_cents', 0),
                            "reference": t.get('reference', ''),
                            "created_at": t.get('created_at', ''),
                        })
            except Exception:
                pass
            await asyncio.sleep(3)
    except WebSocketDisconnect:
        return


# Upstream base URLs (prefer custom domains but allow service URLs)
PAYMENTS_BASE = _env_or("PAYMENTS_BASE_URL", "")
ESCROW_WALLET_ID = _env_or("ESCROW_WALLET_ID", "")
STICKERS_MERCHANT_WALLET_ID = _env_or("STICKERS_MERCHANT_WALLET_ID", "")
DEFAULT_CURRENCY = _env_or("DEFAULT_CURRENCY", "SYP")
TAXI_BASE = _env_or("TAXI_BASE_URL", "")
BUS_BASE = _env_or("BUS_BASE_URL", "")
CARMARKET_BASE = _env_or("CARMARKET_BASE_URL", "")
CARRENTAL_BASE = _env_or("CARRENTAL_BASE_URL", "")
REALESTATE_BASE = _env_or("REALESTATE_BASE_URL", "")
STAYS_BASE = _env_or("STAYS_BASE_URL", "")
FREIGHT_BASE = _env_or("FREIGHT_BASE_URL", "")
EQUIPMENT_BASE = _env_or("EQUIPMENT_BASE_URL", "")
COURIER_BASE = _env_or("COURIER_BASE_URL", "")
COURIER_ADMIN_TOKEN = _env_or("COURIER_ADMIN_TOKEN", "")
CHAT_BASE = _env_or("CHAT_BASE_URL", "")
AGRICULTURE_BASE = _env_or("AGRICULTURE_BASE_URL", "")
COMMERCE_BASE = _env_or("COMMERCE_BASE_URL", "")
BUILDING_BASE = _env_or("BUILDING_BASE_URL", "")
DOCTORS_BASE = _env_or("DOCTORS_BASE_URL", "")
FLIGHTS_BASE = _env_or("FLIGHTS_BASE_URL", "")
JOBS_BASE = _env_or("JOBS_BASE_URL", "")
LIVESTOCK_BASE = _env_or("LIVESTOCK_BASE_URL", "")
PAYMENTS_INTERNAL_SECRET = os.getenv("PAYMENTS_INTERNAL_SECRET") or os.getenv("INTERNAL_API_SECRET")
GMAPS_API_KEY = os.getenv("GMAPS_API_KEY", "")
ORS_BASE = _env_or("ORS_BASE_URL", "")
ORS_API_KEY = os.getenv("ORS_API_KEY", "")
TOMTOM_API_KEY = os.getenv("TOMTOM_API_KEY", "")
TOMTOM_BASE = _env_or("TOMTOM_BASE_URL", "https://api.tomtom.com")
NOMINATIM_BASE = _env_or("NOMINATIM_BASE_URL", "")
GOTIFY_BASE = _env_or("GOTIFY_BASE_URL", "")
GOTIFY_APP_TOKEN = os.getenv("GOTIFY_APP_TOKEN", "")
NOMINATIM_USER_AGENT = _env_or("NOMINATIM_USER_AGENT", "shamell-taxi/1.0 (contact@example.com)")
OSRM_BASE = _env_or("OSRM_BASE_URL", "")
OVERPASS_BASE = _env_or("OVERPASS_BASE_URL", "https://overpass-api.de/api/interpreter")


def _payments_headers(extra: dict[str, str] | None = None) -> dict[str, str]:
    """
    Attach the internal auth header for all BFF->Payments HTTP calls.

    In prod/staging the Payments API should be treated as an internal-only
    service; the BFF is the public surface.
    """
    h: dict[str, str] = {}
    if extra:
        h.update(extra)
    if PAYMENTS_INTERNAL_SECRET:
        # Always override any caller-provided value (do not forward from clients).
        h["X-Internal-Secret"] = PAYMENTS_INTERNAL_SECRET
    return h

# Force all domains to use internal integrations; ignore external BASE_URLs.
FORCE_INTERNAL_DOMAINS = True


def _force_internal(avail: bool) -> bool:
    return bool(FORCE_INTERNAL_DOMAINS and avail)
OVERPASS_USER_AGENT = _env_or("OVERPASS_USER_AGENT", NOMINATIM_USER_AGENT)
BFF_TOPUP_SELLERS = set(a.strip() for a in os.getenv("BFF_TOPUP_SELLERS", "").split(",") if a.strip())
BFF_TOPUP_ALLOW_ALL = (_env_or("BFF_TOPUP_ALLOW_ALL", "false").lower() == "true")
BFF_ADMINS = set(a.strip() for a in os.getenv("BFF_ADMINS", "").split(",") if a.strip())
SUPERADMIN_PHONE = os.getenv("SUPERADMIN_PHONE", "").strip()
TAXI_CANCEL_FEE_SYP = int(_env_or("TAXI_CANCEL_FEE_SYP", "4000"))

# Guardrails for money + mobility flows (best-effort, per-process).
TAXI_PAYOUT_MAX_PER_DRIVER_DAY = int(_env_or("TAXI_PAYOUT_MAX_PER_DRIVER_DAY", "50"))
TAXI_CANCEL_MAX_PER_DRIVER_DAY = int(_env_or("TAXI_CANCEL_MAX_PER_DRIVER_DAY", "50"))
_TAXI_PAYOUT_EVENTS: dict[str, list[int]] = {}
_TAXI_CANCEL_EVENTS: dict[str, list[int]] = {}

# Simple in-memory rate limiting for auth flows (per process).
AUTH_RATE_WINDOW_SECS = int(_env_or("AUTH_RATE_WINDOW_SECS", "60"))
AUTH_MAX_PER_PHONE = int(_env_or("AUTH_MAX_PER_PHONE", "5"))
AUTH_MAX_PER_IP = int(_env_or("AUTH_MAX_PER_IP", "40"))
_AUTH_RATE_PHONE: dict[str, list[int]] = {}
_AUTH_RATE_IP: dict[str, list[int]] = {}

# Payments edge rate-limits (BFF layer, best-effort in-memory).
PAY_API_RATE_WINDOW_SECS = int(_env_or("PAY_API_RATE_WINDOW_SECS", "60"))
PAY_API_REQ_WRITE_MAX_PER_WALLET = int(_env_or("PAY_API_REQ_WRITE_MAX_PER_WALLET", "40"))
PAY_API_REQ_WRITE_MAX_PER_IP = int(_env_or("PAY_API_REQ_WRITE_MAX_PER_IP", "200"))
PAY_API_REQ_READ_MAX_PER_WALLET = int(_env_or("PAY_API_REQ_READ_MAX_PER_WALLET", "120"))
PAY_API_REQ_READ_MAX_PER_IP = int(_env_or("PAY_API_REQ_READ_MAX_PER_IP", "500"))
PAY_API_FAV_WRITE_MAX_PER_WALLET = int(_env_or("PAY_API_FAV_WRITE_MAX_PER_WALLET", "30"))
PAY_API_FAV_WRITE_MAX_PER_IP = int(_env_or("PAY_API_FAV_WRITE_MAX_PER_IP", "120"))
PAY_API_FAV_READ_MAX_PER_WALLET = int(_env_or("PAY_API_FAV_READ_MAX_PER_WALLET", "120"))
PAY_API_FAV_READ_MAX_PER_IP = int(_env_or("PAY_API_FAV_READ_MAX_PER_IP", "500"))
PAY_API_RESOLVE_MAX_PER_WALLET = int(_env_or("PAY_API_RESOLVE_MAX_PER_WALLET", "20"))
PAY_API_RESOLVE_MAX_PER_IP = int(_env_or("PAY_API_RESOLVE_MAX_PER_IP", "120"))
_PAY_API_RATE_WALLET: dict[str, list[int]] = {}
_PAY_API_RATE_IP: dict[str, list[int]] = {}

# Global security headers toggle
SECURITY_HEADERS_ENABLED = _env_or("SECURITY_HEADERS_ENABLED", "true").lower() == "true"

_AUTH_EXPOSE_DEFAULT = "true" if _ENV_LOWER in ("dev", "test") else "false"
# Whether auth codes should be returned in responses (for dev/test only).
AUTH_EXPOSE_CODES = _env_or("AUTH_EXPOSE_CODES", _AUTH_EXPOSE_DEFAULT).lower() == "true"

# Global maintenance mode toggle (read-only / outage banner).
MAINTENANCE_MODE_ENABLED = _env_or("MAINTENANCE_MODE", "false").lower() == "true"
METRICS_INGEST_SECRET = _env_or("METRICS_INGEST_SECRET", "").strip()
SECURITY_ALERT_WEBHOOK_URL = _env_or("SECURITY_ALERT_WEBHOOK_URL", "").strip()
SECURITY_ALERT_WINDOW_SECS = int(_env_or("SECURITY_ALERT_WINDOW_SECS", "300"))
SECURITY_ALERT_COOLDOWN_SECS = int(_env_or("SECURITY_ALERT_COOLDOWN_SECS", "600"))
SECURITY_ALERT_THRESHOLDS_RAW = _env_or(
    "SECURITY_ALERT_THRESHOLDS",
    (
        "payments_transfer_wallet_mismatch:5,"
        "alias_request_wallet_mismatch:5,"
        "alias_request_user_override_blocked:5,"
        "favorites_owner_wallet_mismatch:5,"
        "payments_request_from_wallet_mismatch:5,"
        "payments_edge_rate_limit_wallet:30,"
        "payments_edge_rate_limit_ip:50"
    ),
).strip()

# ---- Simple session auth (OTP via code; in-memory storage for demo) ----
AUTH_SESSION_TTL_SECS = int(_env_or("AUTH_SESSION_TTL_SECS", "86400"))
LOGIN_CODE_TTL_SECS = int(_env_or("LOGIN_CODE_TTL_SECS", "300"))
DEVICE_LOGIN_TTL_SECS = int(_env_or("DEVICE_LOGIN_TTL_SECS", "300"))
_LOGIN_CODES: dict[str, tuple[str, int]] = {}  # phone -> (code, expires_at)
_SESSIONS: dict[str, tuple[str, int]] = {}     # sid -> (phone, expires_at)
_DEVICE_LOGIN_CHALLENGES: dict[str, dict[str, Any]] = {}  # token -> metadata
_BLOCKED_PHONES: set[str] = set()
_PUSH_ENDPOINTS: dict[str, list[dict]] = {}
_AUTH_CLEANUP_INTERVAL_SECS = 60
_AUTH_LAST_CLEANUP_TS = 0


def _parse_security_alert_thresholds(raw: str) -> dict[str, int]:
    out: dict[str, int] = {}
    for chunk in (raw or "").split(","):
        item = chunk.strip()
        if not item or ":" not in item:
            continue
        name, value = item.split(":", 1)
        action = name.strip()
        if not action:
            continue
        try:
            threshold = int(value.strip())
        except Exception:
            continue
        if threshold <= 0:
            continue
        out[action] = threshold
    return out


SECURITY_ALERT_THRESHOLDS = _parse_security_alert_thresholds(SECURITY_ALERT_THRESHOLDS_RAW)
_SECURITY_ALERT_EVENTS: dict[str, list[int]] = {}
_SECURITY_ALERT_LAST_SENT: dict[str, int] = {}

def _now() -> int:
    return int(time.time())


def _cleanup_auth_state(now: int | None = None) -> None:
    """
    Best-effort periodic cleanup of expired OTP codes and sessions
    to keep memory usage bounded across long-running processes.
    """
    global _AUTH_LAST_CLEANUP_TS
    ts = now or _now()
    if ts - _AUTH_LAST_CLEANUP_TS < _AUTH_CLEANUP_INTERVAL_SECS:
        return
    _AUTH_LAST_CLEANUP_TS = ts
    try:
        expired = [p for p, (_, exp) in list(_LOGIN_CODES.items()) if exp < ts]
        for phone in expired:
            _LOGIN_CODES.pop(phone, None)
    except Exception:
        pass
    try:
        expired_sids = [sid for sid, (_, exp) in list(_SESSIONS.items()) if exp < ts]
        for sid in expired_sids:
            _SESSIONS.pop(sid, None)
    except Exception:
        pass
    try:
        expired_tokens = [
            token
            for token, rec in list(_DEVICE_LOGIN_CHALLENGES.items())
            if int(rec.get("created_at") or 0) + DEVICE_LOGIN_TTL_SECS < ts
        ]
        for token in expired_tokens:
            _DEVICE_LOGIN_CHALLENGES.pop(token, None)
    except Exception:
        pass


def _issue_code(phone: str) -> str:
    _cleanup_auth_state()
    code = f"{_secrets.randbelow(1_000_000):06d}"
    _LOGIN_CODES[phone] = (code, _now()+LOGIN_CODE_TTL_SECS)
    return code


def _check_code(phone: str, code: str) -> bool:
    _cleanup_auth_state()
    rec = _LOGIN_CODES.get(phone)
    ok = bool(rec and rec[0] == code and rec[1] >= _now())
    if ok:
        # Drop code after successful use (no reuse)
        try:
            del _LOGIN_CODES[phone]
        except Exception:
            pass
    return ok


def _create_session(phone: str) -> str:
    _cleanup_auth_state()
    sid = _uuid.uuid4().hex
    _SESSIONS[sid] = (phone, _now()+AUTH_SESSION_TTL_SECS)
    return sid


def _normalize_session_token(raw: str | None) -> str | None:
    token = (raw or "").strip()
    if not token:
        return None
    if "=" in token:
        for part in token.split(";"):
            part = part.strip()
            if part.startswith("sa_session="):
                token = part.split("=", 1)[1]
                break
    token = token.strip()
    if not re.fullmatch(r"[a-f0-9]{32}", token):
        return None
    return token


def _normalize_ip(raw: str | None) -> str | None:
    candidate = (raw or "").strip()
    if not candidate:
        return None
    try:
        return str(ipaddress.ip_address(candidate))
    except Exception:
        return None


def _auth_client_ip(request: Request) -> str:
    """
    Best-effort resolution of the client IP for rate limiting.
    Prefer trusted proxy headers and avoid trusting attacker-controlled
    left-most X-Forwarded-For entries.
    """
    try:
        real_ip = _normalize_ip(request.headers.get("x-real-ip") or request.headers.get("X-Real-IP"))
        if real_ip:
            return real_ip
    except Exception:
        pass
    try:
        fwd = request.headers.get("x-forwarded-for") or request.headers.get("X-Forwarded-For")
        if fwd:
            # Nginx appends the direct client as the right-most element.
            for hop in reversed([p.strip() for p in fwd.split(",") if p.strip()]):
                ip = _normalize_ip(hop)
                if ip:
                    return ip
    except Exception:
        pass
    try:
        if request.client and request.client.host:
            ip = _normalize_ip(request.client.host)
            if ip:
                return ip
            return request.client.host
    except Exception:
        pass
    return "unknown"


def _check_payment_guardrails(from_wallet_id: str | None, amount_cents: int | None, device_id: str | None) -> None:
    """
    Best-effort anti-fraud guardrails for payments:
    - optional max amount per transaction
    - simple velocity limits per wallet and per device over a short window
    """
    try:
        now = time.time()
        amt = int(amount_cents or 0)
        fw = (from_wallet_id or "").strip()

        # Guardrail 1: maximum amount per transaction (when configured)
        if PAY_MAX_PER_TXN_CENTS > 0 and amt > PAY_MAX_PER_TXN_CENTS:
            _audit("pay_amount_guardrail", from_wallet_id=fw or None, amount_cents=amt, device_id=device_id)
            raise HTTPException(status_code=403, detail="payment amount exceeds guardrail")

        window = max(1, PAY_VELOCITY_WINDOW_SECS)

        # Guardrail 2: velocity per wallet
        if fw:
            events = _PAY_VELOCITY_WALLET.get(fw) or []
            events = [ts for ts in events if ts >= now - window]
            if len(events) >= max(1, PAY_VELOCITY_MAX_PER_WALLET):
                _PAY_VELOCITY_WALLET[fw] = events
                _audit("pay_velocity_guardrail_wallet", from_wallet_id=fw, amount_cents=amt, device_id=device_id)
                raise HTTPException(status_code=429, detail="payment velocity guardrail (wallet)")
            events.append(now)
            _PAY_VELOCITY_WALLET[fw] = events

        # Guardrail 3: Velocity pro Device
        dev = (device_id or "").strip()
        if dev:
            events_d = _PAY_VELOCITY_DEVICE.get(dev) or []
            events_d = [ts for ts in events_d if ts >= now - window]
            if len(events_d) >= max(1, PAY_VELOCITY_MAX_PER_DEVICE):
                _PAY_VELOCITY_DEVICE[dev] = events_d
                _audit("pay_velocity_guardrail_device", from_wallet_id=fw or None, amount_cents=amt, device_id=dev)
                raise HTTPException(status_code=429, detail="payment velocity guardrail (device)")
            events_d.append(now)
            _PAY_VELOCITY_DEVICE[dev] = events_d
    except HTTPException:
        # Guardrail intentionally blocking request
        raise
    except Exception:
        # Guardrails must never break normal flows
        return


def _rate_limit_auth(request: Request, phone: str) -> None:
    """
    Very simple in-memory rate limiter for auth endpoints.
    Limits per phone number and per IP within a short window.
    """
    now = _now()
    # Limit pro Telefonnummer
    if phone:
        lst = _AUTH_RATE_PHONE.get(phone) or []
        lst = [ts for ts in lst if ts >= now - AUTH_RATE_WINDOW_SECS]
        lst.append(now)
        _AUTH_RATE_PHONE[phone] = lst
        if len(lst) > AUTH_MAX_PER_PHONE:
            raise HTTPException(status_code=429, detail="rate limited: too many codes for this phone")
    # Limit pro IP
    ip = _auth_client_ip(request)
    if ip:
        lst_ip = _AUTH_RATE_IP.get(ip) or []
        lst_ip = [ts for ts in lst_ip if ts >= now - AUTH_RATE_WINDOW_SECS]
        lst_ip.append(now)
        _AUTH_RATE_IP[ip] = lst_ip
        if len(lst_ip) > AUTH_MAX_PER_IP:
            raise HTTPException(status_code=429, detail="rate limited: too many requests from this ip")


def _rate_limit_bucket(
    store: dict[str, list[int]],
    key: str,
    *,
    window_secs: int,
    max_hits: int,
) -> int:
    if max_hits <= 0:
        return 0
    now = _now()
    window = max(1, window_secs)
    entries = store.get(key) or []
    entries = [ts for ts in entries if ts >= now - window]
    entries.append(now)
    store[key] = entries
    return len(entries)


def _rate_limit_payments_edge(
    request: Request,
    *,
    wallet_id: str,
    scope: str,
    wallet_max: int,
    ip_max: int,
) -> None:
    scope_key = (scope or "").strip().lower() or "default"
    wallet_key = (wallet_id or "").strip()
    if wallet_key:
        hits_wallet = _rate_limit_bucket(
            _PAY_API_RATE_WALLET,
            f"{scope_key}:{wallet_key}",
            window_secs=PAY_API_RATE_WINDOW_SECS,
            max_hits=wallet_max,
        )
        if wallet_max > 0 and hits_wallet > wallet_max:
            _audit_from_request(
                request,
                "payments_edge_rate_limit_wallet",
                scope=scope_key,
                wallet_id=wallet_key,
                max=wallet_max,
                hits=hits_wallet,
            )
            raise HTTPException(status_code=429, detail="rate limited: too many requests")
    ip = _auth_client_ip(request)
    if ip and ip != "unknown":
        hits_ip = _rate_limit_bucket(
            _PAY_API_RATE_IP,
            f"{scope_key}:{ip}",
            window_secs=PAY_API_RATE_WINDOW_SECS,
            max_hits=ip_max,
        )
        if ip_max > 0 and hits_ip > ip_max:
            _audit_from_request(
                request,
                "payments_edge_rate_limit_ip",
                scope=scope_key,
                ip=ip,
                max=ip_max,
                hits=hits_ip,
            )
            raise HTTPException(status_code=429, detail="rate limited: too many requests")


def _auth_phone(request: Request) -> str | None:
    # Test-only shortcut: allow injecting a phone number via header
    # when ENV=test so API tests do not need to orchestrate cookie login.
    _cleanup_auth_state()
    try:
        if os.getenv("ENV") == "test":
            h_phone = request.headers.get("X-Test-Phone") or request.headers.get("x-test-phone")
            if h_phone:
                return h_phone
    except Exception:
        # Fall back to cookie-based auth
        pass
    # 1) Optional: session from custom header `sa_cookie` (for web clients
    #    that cannot use Set-Cookie / browser cookies).
    sid = None
    try:
        raw = request.headers.get("sa_cookie") or request.headers.get("Sa-Cookie")
        if raw:
            sid = _normalize_session_token(raw)
    except Exception:
        sid = None

    # 2) Fallback to regular cookie when no explicit header is used.
    if not sid:
        sid = _normalize_session_token(request.cookies.get("sa_session"))
    if not sid: return None
    rec = _SESSIONS.get(sid)
    if not rec: return None
    phone, exp = rec
    if exp < _now():
        try: del _SESSIONS[sid]
        except Exception: pass
        return None
    return phone


def _audit(action: str, phone: str | None = None, **extra: Any) -> None:
    """
    Lightweight audit logger for critical admin/superadmin actions.
    Writes structured entries into the JSON log stream.
    """
    try:
        payload: dict[str, Any] = {
            "event": "audit",
            "action": action,
            "phone": phone or "",
            "ts_ms": int(time.time() * 1000),
        }
        for k, v in extra.items():
            if v is not None:
                payload[k] = v
        _audit_logger.info(payload)
        _maybe_send_security_alert(payload)
    except Exception:
        # Audit must never break normal flows
        pass


def _maybe_send_security_alert(payload: dict[str, Any]) -> None:
    if not SECURITY_ALERT_WEBHOOK_URL:
        return
    if not SECURITY_ALERT_THRESHOLDS:
        return
    action = str(payload.get("action") or "").strip()
    if not action:
        return
    threshold = int(SECURITY_ALERT_THRESHOLDS.get(action) or 0)
    if threshold <= 0:
        return
    now = _now()
    window = max(30, SECURITY_ALERT_WINDOW_SECS)
    events = _SECURITY_ALERT_EVENTS.get(action) or []
    events = [ts for ts in events if ts >= now - window]
    events.append(now)
    _SECURITY_ALERT_EVENTS[action] = events
    if len(events) < threshold:
        return
    last_sent = int(_SECURITY_ALERT_LAST_SENT.get(action) or 0)
    if last_sent and now - last_sent < max(30, SECURITY_ALERT_COOLDOWN_SECS):
        return
    _SECURITY_ALERT_LAST_SENT[action] = now
    sample_keys = (
        "phone",
        "caller_wallet_id",
        "requested_wallet_id",
        "scope",
        "ip",
        "hits",
        "max",
        "target_phone",
    )
    sample: dict[str, Any] = {}
    for key in sample_keys:
        value = payload.get(key)
        if value is not None and value != "":
            sample[key] = value
    alert_payload = {
        "source": "shamell-bff",
        "event": "security_alert",
        "action": action,
        "count": len(events),
        "threshold": threshold,
        "window_secs": window,
        "sample": sample,
        "ts_ms": int(time.time() * 1000),
    }
    try:
        _metrics_logger.info(alert_payload)
    except Exception:
        pass
    try:
        httpx.post(
            SECURITY_ALERT_WEBHOOK_URL,
            json={
                "text": (
                    f"Shamell security alert: {action} "
                    f"count={len(events)} threshold={threshold} window={window}s"
                ),
                "alert": alert_payload,
            },
            timeout=4,
        )
    except Exception:
        # Alert delivery must never break request path.
        return


def _audit_from_request(request: Request, action: str, **extra: Any) -> None:
    phone = ""
    try:
        phone = _auth_phone(request) or ""
    except Exception:
        phone = ""
    _audit(action, phone=phone, **extra)

def _require_seller(request: Request) -> str:
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    # First try dynamic roles via Payments
    if PAYMENTS_BASE and PAYMENTS_INTERNAL_SECRET:
        try:
            url = _payments_url("/admin/roles/check")
            r = httpx.get(url, params={"phone": phone, "role": "seller"}, headers={"X-Internal-Secret": PAYMENTS_INTERNAL_SECRET}, timeout=6)
            if r.json().get("has", False):
                return phone
        except Exception:
            pass
    # Fallback to local env allowlist
    if BFF_TOPUP_ALLOW_ALL or not BFF_TOPUP_SELLERS or phone in BFF_TOPUP_SELLERS:
        return phone
    raise HTTPException(status_code=403, detail="seller not allowed")

def _require_admin(request: Request) -> str:
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    if phone in BFF_ADMINS and phone:
        return phone
    # Optionally allow sellers to manage sellers
    if phone in BFF_TOPUP_SELLERS:
        return phone
    raise HTTPException(status_code=403, detail="admin not allowed")


def _get_effective_roles(phone: str) -> list[str]:
    """
    Returns the effective roles for a phone number.
    Prefers Payments roles and falls back to local env lists.
    """
    roles: list[str] = []
    # Payments roles via internal API when configured
    try:
        if _use_pay_internal():
            if _PAY_INTERNAL_AVAILABLE:
                with _pay_internal_session() as s:
                    arr = _pay_roles_list(phone=phone, role=None, limit=500, s=s, admin_ok=True)
                    try:
                        roles = [str(getattr(x, "role", "") or "") for x in arr if getattr(x, "role", "")]  # type: ignore[attr-defined]
                    except Exception:
                        roles = []
        elif PAYMENTS_BASE and PAYMENTS_INTERNAL_SECRET:
            # External fallback; used only when configured
            r = httpx.get(
                _payments_url("/admin/roles"),
                params={"phone": phone, "limit": 500},
                headers={"X-Internal-Secret": PAYMENTS_INTERNAL_SECRET},
                timeout=8,
            )
            if r.headers.get("content-type", "").startswith("application/json"):
                arr = r.json()
                try:
                    roles = [str(x.get("role") or "") for x in arr if isinstance(x, dict) and (x.get("role") or "")]
                except Exception:
                    roles = []
    except Exception:
        # Fallback to local roles
        roles = []
    # Always consider local env-based lists as well
    if phone in BFF_ADMINS and "admin" not in roles:
        roles.append("admin")
    if phone in BFF_TOPUP_SELLERS and "seller" not in roles:
        roles.append("seller")
    return sorted(set(r for r in roles if r))


def _is_superadmin(phone: str) -> bool:
    """
    Superadmin resolution:

    - In production/staging environments only SUPERADMIN_PHONE
      is allowed as Superadmin.
    - We also honor the Payments role "superadmin" (and legacy ops/seller in
      test/dev) so granting the role in the DB is enough without relying on
      env overrides.
    """
    # Hard binding to a single phone number (production path)
    if phone.strip() == SUPERADMIN_PHONE:
        return True
    # Role-based superadmin (dev/test use payments roles)
    try:
        roles = _get_effective_roles(phone)
        if "superadmin" in roles:
            return True
        if _env_or("ENV", "dev").lower() == "test":
            return any(r in ("ops", "seller", "superadmin") for r in roles)
    except Exception:
        pass
    return False


def _is_admin(phone: str) -> bool:
    roles = _get_effective_roles(phone)
    # Admin: admin oder Superadmin
    return _is_superadmin(phone) or "admin" in roles


def _is_operator(phone: str, domain: str | None = None) -> bool:
    roles = _get_effective_roles(phone)
    if domain:
        if f"operator_{domain}" in roles:
            return True
    # Admin/Superadmin gelten immer auch als Operatoren
    return _is_admin(phone)


def _require_operator(request: Request, domain: str) -> str:
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    if _is_operator(phone, domain):
        return phone
    raise HTTPException(status_code=403, detail=f"operator for {domain} required")


def _require_superadmin(request: Request) -> str:
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    if _is_superadmin(phone):
        return phone
    raise HTTPException(status_code=403, detail="superadmin not allowed")


def _require_admin_or_superadmin(request: Request) -> str:
    """
    Allow both Admin and Superadmin (Payments role model).
    Used for operator provisioning flows where business owners or
    superadmins are allowed to manage domain operators.
    """
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    if _is_admin(phone) or _is_superadmin(phone):
        return phone
    raise HTTPException(status_code=403, detail="admin or superadmin required")


def _require_admin_v2(request: Request) -> str:
    """
    New admin check that uses the Payments role model.
    Currently only used selectively; existing _require_admin remains for backwards compatibility.
    """
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    if _is_admin(phone):
        return phone
    raise HTTPException(status_code=403, detail="admin not allowed")


@app.post("/push/register")
async def push_register(req: Request):
    """
    Register a self-hosted push endpoint (Gotify / UnifiedPush) for the
    currently authenticated user (driver or passenger).
    """
    phone = _auth_phone(req)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    try:
        body = await req.json()
    except Exception:
        body = {}
    if not isinstance(body, dict):
        body = {}
    device_id = (body.get("device_id") or "").strip()
    endpoint = (body.get("endpoint") or "").strip()
    etype = (body.get("type") or "gotify").strip().lower()
    if not device_id or not endpoint:
        raise HTTPException(status_code=400, detail="device_id and endpoint required")
    entries = [e for e in _PUSH_ENDPOINTS.get(phone, []) if e.get("device_id") != device_id]
    entries.append({"device_id": device_id, "endpoint": endpoint, "type": etype})
    _PUSH_ENDPOINTS[phone] = entries
    return {"ok": True, "phone": phone, "device_id": device_id, "type": etype}


@app.get("/osm/route")
def osm_route(start_lat: float, start_lon: float, end_lat: float, end_lon: float, profile: str = "driving-car"):
    """
    Lightweight proxy for OpenRouteService/GraphHopper style routing.

    Returns a simplified polyline and distance/duration so the client can draw
    the route on MapLibre/Google maps without talking to ORS directly.
    """
    if not ORS_BASE and not OSRM_BASE and not TOMTOM_API_KEY:
        raise HTTPException(status_code=400, detail="no routing backend configured")
    try:
        points: list[list[float]] = []
        distance_m = 0.0
        duration_s = 0.0
        # Prefer TomTom Routing API when a key is configured.
        if TOMTOM_API_KEY:
            base = TOMTOM_BASE.rstrip("/")
            # TomTom Routing API expects "lat,lon:lat,lon" order in the path.
            path = f"/routing/1/calculateRoute/{float(start_lat)},{float(start_lon)}:{float(end_lat)},{float(end_lon)}/json"
            # Map generic profile to TomTom travelMode
            p = (profile or "").lower()
            if p in ("truck", "hgv", "lorry"):
                travel_mode = "truck"
            elif p in ("bicycle", "bike", "cycling"):
                travel_mode = "bicycle"
            elif p in ("foot", "pedestrian", "walk", "walking"):
                travel_mode = "pedestrian"
            else:
                travel_mode = "car"
            params = {
                "key": TOMTOM_API_KEY,
                # Enable traffic-aware routing for accurate ETAs.
                "traffic": "true",
                "travelMode": travel_mode,
                # Ask TomTom for alternative routes where available.
                "maxAlternatives": "2",
            }
            try:
                r = _httpx_client().get(base + path, params=params)
            except Exception as e:
                raise HTTPException(status_code=502, detail=f"routing upstream error: {e}")
            if r.status_code >= 400:
                raise HTTPException(status_code=502, detail=f"routing upstream error: {r.text[:200]}")
            j = r.json()
            routes = j.get("routes") or []
            if routes:
                # Build normalized list of route variants.
                norm_routes: list[dict[str, object]] = []
                for rt in routes:
                    legs = rt.get("legs") or []
                    points_raw = []
                    if legs:
                        leg0 = legs[0]
                        points_raw = leg0.get("points") or []
                    pts: list[list[float]] = []
                    for pp in points_raw:
                        try:
                            lat = float(pp.get("latitude") or pp.get("lat") or 0.0)
                            lon = float(pp.get("longitude") or pp.get("lon") or 0.0)
                            pts.append([lat, lon])
                        except Exception:
                            continue
                    summary = rt.get("summary") or {}
                    try:
                        d_m = float(summary.get("lengthInMeters") or 0.0)
                    except Exception:
                        d_m = 0.0
                    try:
                        t_s = float(summary.get("travelTimeInSeconds") or 0.0)
                    except Exception:
                        t_s = 0.0
                    norm_routes.append(
                        {
                            "points": pts,
                            "distance_m": d_m,
                            "duration_s": t_s,
                        }
                    )
                if norm_routes:
                    first = norm_routes[0]
                    points = first.get("points") or []
                    try:
                        distance_m = float(first.get("distance_m") or 0.0)  # type: ignore[arg-type]
                    except Exception:
                        distance_m = 0.0
                    try:
                        duration_s = float(first.get("duration_s") or 0.0)  # type: ignore[arg-type]
                    except Exception:
                        duration_s = 0.0
                    return {
                        "points": points,
                        "distance_m": distance_m,
                        "duration_s": duration_s,
                        "routes": norm_routes,
                    }
        elif ORS_BASE:
            coords = [
                [float(start_lon), float(start_lat)],
                [float(end_lon), float(end_lat)],
            ]
            url = ORS_BASE.rstrip("/") + f"/v2/directions/{profile}"
            headers = {"accept": "application/json", "content-type": "application/json"}
            if ORS_API_KEY:
                headers["Authorization"] = ORS_API_KEY
            body = {
                "coordinates": coords,
                "geometry": True,
            }
            r = _httpx_client().post(url, json=body, headers=headers)
            if r.status_code >= 400:
                raise HTTPException(status_code=502, detail=f"routing upstream error: {r.text[:200]}")
            j = r.json()
            routes = j.get("routes") or j.get("features") or []
            if routes:
                route = routes[0]
                coords_out = []
                try:
                    geom = route.get("geometry")
                    if isinstance(geom, dict):
                        coords_out = geom.get("coordinates") or []
                    elif isinstance(geom, list):
                        coords_out = geom
                    elif isinstance(geom, str):
                        # geometry is encoded polyline; for now keep empty -> client falls back
                        coords_out = []
                except Exception:
                    coords_out = []
                for c in coords_out:
                    try:
                        if isinstance(c, (list, tuple)) and len(c) >= 2:
                            lon, lat = float(c[0]), float(c[1])
                            points.append([lat, lon])
                    except Exception:
                        continue
                summary = route.get("summary") or {}
                try:
                    distance_m = float(summary.get("distance") or 0.0)
                except Exception:
                    distance_m = 0.0
                try:
                    duration_s = float(summary.get("duration") or 0.0)
                except Exception:
                    duration_s = 0.0
        elif OSRM_BASE:
            base = OSRM_BASE.rstrip("/")
            coords = f"{float(start_lon)},{float(start_lat)};{float(end_lon)},{float(end_lat)}"
            url = f"{base}/route/v1/driving/{coords}"
            params = {
                "overview": "full",
                "alternatives": "false",
                "steps": "false",
                "geometries": "geojson",
            }
            r = _httpx_client().get(url, params=params)
            if r.status_code >= 400:
                raise HTTPException(status_code=502, detail=f"routing upstream error: {r.text[:200]}")
            j = r.json()
            routes = j.get("routes") or []
            if routes:
                route = routes[0]
                try:
                    geom = route.get("geometry") or {}
                    coords_out = geom.get("coordinates") or []
                except Exception:
                    coords_out = []
                for c in coords_out:
                    try:
                        if isinstance(c, (list, tuple)) and len(c) >= 2:
                            lon, lat = float(c[0]), float(c[1])
                            points.append([lat, lon])
                    except Exception:
                        continue
                try:
                    distance_m = float(route.get("distance") or 0.0)
                except Exception:
                    distance_m = 0.0
                try:
                    duration_s = float(route.get("duration") or 0.0)
                except Exception:
                    duration_s = 0.0
        return {"points": points, "distance_m": distance_m, "duration_s": duration_s}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/osm/geocode")
def osm_geocode(q: str):
    """
    Simple geocoding proxy backed by Nominatim or TomTom Search API.
    """
    now = time.time()
    cached = _OSM_GEOCODE_CACHE.get(q)
    if cached and (now - cached[0] < 60):
        return cached[1]
    # Prefer TomTom Search API when a key is configured.
    if TOMTOM_API_KEY:
        base = TOMTOM_BASE.rstrip("/")
        # Geocode query: /search/2/geocode/{query}.json?key=...
        from urllib.parse import quote
        path = f"/search/2/geocode/{quote(q)}.json"
        params = {"key": TOMTOM_API_KEY, "limit": "5"}
        try:
            r = _httpx_client().get(base + path, params=params)
            if r.status_code >= 400:
                raise HTTPException(status_code=502, detail=f"geocode upstream error: {r.text[:200]}")
            j = r.json()
            results = j.get("results") or []
            out: list[dict[str, object]] = []
            for item in results:
                try:
                    pos = item.get("position") or {}
                    lat = float(pos.get("lat") or pos.get("latitude") or 0.0)
                    lon = float(pos.get("lon") or pos.get("longitude") or 0.0)
                    addr = ""
                    address = item.get("address") or {}
                    if isinstance(address, dict):
                        addr = (address.get("freeformAddress") or "") or ""
                    out.append({"lat": lat, "lon": lon, "display_name": addr})
                except Exception:
                    continue
            _OSM_GEOCODE_CACHE[q] = (now, out)
            return out
        except HTTPException:
            raise
        except Exception as e:
            raise HTTPException(status_code=502, detail=str(e))
    # Fallback: Nominatim / OSM when configured.
    if not NOMINATIM_BASE:
        raise HTTPException(status_code=400, detail="NOMINATIM_BASE_URL not configured and no TomTom key")
    url = NOMINATIM_BASE.rstrip("/") + "/search"
    params = {"q": q, "format": "json", "addressdetails": "0", "limit": "5"}
    headers = {"User-Agent": NOMINATIM_USER_AGENT}
    try:
        r = _httpx_client().get(url, params=params, headers=headers)
        if r.status_code >= 400:
            raise HTTPException(status_code=502, detail=f"geocode upstream error: {r.text[:200]}")
        arr = r.json()
        if not isinstance(arr, list):
            return []
        out = []
        for item in arr:
            try:
                lat = float(item.get("lat") or 0.0)
                lon = float(item.get("lon") or 0.0)
                out.append({
                    "lat": lat,
                    "lon": lon,
                    "display_name": (item.get("display_name") or ""),
                })
            except Exception:
                continue
        _OSM_GEOCODE_CACHE[q] = (now, out)
        return out
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/osm/poi_search")
def osm_poi_search(
    q: str,
    lat: float | None = None,
    lon: float | None = None,
    limit: int = 20,
):
    """
    POI-Suche (Tankstellen, Apotheken, Restaurants, ...) rund um eine Position.

    Bevorzugt TomTom Search API, fällt sonst auf Nominatim/OSM zurück.
    Antwortformat:
      - lat, lon, name, category, address
    """
    limit = max(1, min(limit, 50))
    # TomTom Search API
    if TOMTOM_API_KEY:
        base = TOMTOM_BASE.rstrip("/")
        from urllib.parse import quote

        path = f"/search/2/search/{quote(q)}.json"
        params: dict[str, object] = {"key": TOMTOM_API_KEY, "limit": limit}
        if lat is not None and lon is not None:
            params["lat"] = float(lat)
            params["lon"] = float(lon)
            params["radius"] = 5000
        try:
            r = _httpx_client().get(base + path, params=params)
            if r.status_code >= 400:
                raise HTTPException(status_code=502, detail=f"poi upstream error: {r.text[:200]}")
            j = r.json()
            results = j.get("results") or []
            out: list[dict[str, object]] = []
            for item in results:
                try:
                    pos = item.get("position") or {}
                    plat = float(pos.get("lat") or pos.get("latitude") or 0.0)
                    plon = float(pos.get("lon") or pos.get("longitude") or 0.0)
                    poi = item.get("poi") or {}
                    name = ""
                    category = ""
                    if isinstance(poi, dict):
                        name = (poi.get("name") or "") or ""
                        cats = poi.get("categories") or []
                        if isinstance(cats, list) and cats:
                            category = str(cats[0] or "")
                    address = ""
                    addr = item.get("address") or {}
                    if isinstance(addr, dict):
                        address = (addr.get("freeformAddress") or "") or ""
                    out.append(
                        {
                            "lat": plat,
                            "lon": plon,
                            "name": name,
                            "category": category,
                            "address": address,
                        }
                    )
                except Exception:
                    continue
            return out
        except HTTPException:
            raise
        except Exception as e:
            raise HTTPException(status_code=502, detail=str(e))

    # Fallback: Nominatim POI search via OSM when configured
    if not NOMINATIM_BASE:
        raise HTTPException(
            status_code=400, detail="NOMINATIM_BASE_URL not configured and no TomTom key"
        )
    url = NOMINATIM_BASE.rstrip("/") + "/search"
    params = {
        "q": q,
        "format": "json",
        "addressdetails": "1",
        "limit": str(limit),
    }
    if lat is not None and lon is not None:
        params["viewbox"] = (
            f"{lon-0.05},{lat+0.05},{lon+0.05},{lat-0.05}"
        )
        params["bounded"] = "1"
    headers = {"User-Agent": NOMINATIM_USER_AGENT}
    try:
        r = _httpx_client().get(url, params=params, headers=headers)
        if r.status_code >= 400:
            raise HTTPException(status_code=502, detail=f"poi upstream error: {r.text[:200]}")
        arr = r.json()
        if not isinstance(arr, list):
            return []
        out = []
        for item in arr:
            try:
                plat = float(item.get("lat") or 0.0)
                plon = float(item.get("lon") or 0.0)
                name = (item.get("display_name") or "") or ""
                addr = item.get("address") or {}
                cat = ""
                if isinstance(addr, dict):
                    cat = (
                        addr.get("amenity")
                        or addr.get("shop")
                        or addr.get("tourism")
                        or ""
                    )
                out.append(
                    {
                        "lat": plat,
                        "lon": plon,
                        "name": name,
                        "category": cat,
                        "address": name,
                    }
                )
            except Exception:
                continue
        return out
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/osm/geocode_batch")
async def osm_geocode_batch(request: Request):
    """
    Batch-Geocoding für Backend-Importe.

    Body:
      - queries: List[str]
      - max_per_query: int (optional, default 1)

    Antwort:
      {
        "results": [
          {
            "query": "...",
            "hits": [
              {"lat": ..., "lon": ..., "display_name": "..."},
              ...
            ]
          },
          ...
        ]
      }
    """
    try:
        body = await request.json()
    except Exception:
        body = {}
    if not isinstance(body, dict):
        body = {}
    queries = body.get("queries") or []
    if not isinstance(queries, list):
        raise HTTPException(status_code=400, detail="queries must be a list")
    max_per_query = int(body.get("max_per_query") or 1)
    max_per_query = max(1, min(max_per_query, 10))

    out: list[dict[str, object]] = []
    for raw_q in queries:
        q = str(raw_q or "").strip()
        if not q:
            out.append({"query": q, "hits": []})
            continue
        try:
            # Reuse osm_geocode logic via internal call
            hits = osm_geocode(q)
            if isinstance(hits, list):
                hits = hits[:max_per_query]
            else:
                hits = []
        except HTTPException as e:
            hits = [{"error": e.detail}]
        except Exception as e:
            hits = [{"error": str(e)}]
        out.append({"query": q, "hits": hits})
    return {"results": out}


@app.post("/fleet/optimize_stops")
async def fleet_optimize_stops(request: Request):
    """
    Simple stop-order optimisation for a single vehicle (e.g. deliveries or rides).

    Body:
      - origin: {lat, lon}
      - stops: [{id, lat, lon}, ...]
      - profile: optional (car/truck/bicycle/pedestrian), currently only used for future routing hooks

    Uses a greedy nearest-neighbour heuristic based on Haversine distance.
    Returns an ordered stop list and approximate total distance.
    """
    try:
        body = await request.json()
    except Exception:
        body = {}
    if not isinstance(body, dict):
        body = {}
    origin = body.get("origin") or {}
    stops = body.get("stops") or []
    if not isinstance(origin, dict) or not isinstance(stops, list):
        raise HTTPException(status_code=400, detail="origin and stops required")
    try:
        o_lat = float(origin.get("lat"))
        o_lon = float(origin.get("lon"))
    except Exception:
        raise HTTPException(status_code=400, detail="invalid origin")
    # Normalise stops
    rem: list[dict[str, Any]] = []
    for s in stops:
        try:
            if not isinstance(s, dict):
                continue
            sid = str(s.get("id") or "")
            lat = float(s.get("lat"))
            lon = float(s.get("lon"))
            if not sid:
                continue
            rem.append({"id": sid, "lat": lat, "lon": lon})
        except Exception:
            continue
    if not rem:
        return {"ok": True, "origin": origin, "order": [], "total_km": 0.0}
    cur_lat = o_lat
    cur_lon = o_lon
    ordered: list[dict[str, Any]] = []
    total_km = 0.0
    while rem:
        best_idx = None
        best_km = float("inf")
        for i, s in enumerate(rem):
            d_km = _haversine_km(cur_lat, cur_lon, s["lat"], s["lon"])
            if d_km < best_km:
                best_km = d_km
                best_idx = i
        if best_idx is None:
            break
        nxt = rem.pop(best_idx)
        total_km += best_km if math.isfinite(best_km) else 0.0
        ordered.append(
            {
                "id": nxt["id"],
                "lat": nxt["lat"],
                "lon": nxt["lon"],
                "leg_km": best_km,
            }
        )
        cur_lat = nxt["lat"]
        cur_lon = nxt["lon"]
    return {
        "ok": True,
        "origin": {"lat": o_lat, "lon": o_lon},
        "order": ordered,
        "total_km": total_km,
    }


@app.post("/fleet/assign_deliveries")
async def fleet_assign_deliveries(request: Request):
    """
    Simple multi-depot assignment helper for planning scenarios.

    Body:
      - depots: [{id, lat, lon}, ...]
      - stops: [{id, lat, lon}, ...]

    Each stop is assigned to the nearest depot by Haversine distance.
    The result can be used per-depot with /fleet/optimize_stops to plan daily tours.
    """
    try:
        body = await request.json()
    except Exception:
        body = {}
    if not isinstance(body, dict):
        body = {}
    depots = body.get("depots") or []
    stops = body.get("stops") or []
    if not isinstance(depots, list) or not isinstance(stops, list):
        raise HTTPException(status_code=400, detail="depots and stops must be lists")
    norm_depots: list[dict[str, Any]] = []
    for d in depots:
        try:
            if not isinstance(d, dict):
                continue
            did = str(d.get("id") or "")
            lat = float(d.get("lat"))
            lon = float(d.get("lon"))
            if not did:
                continue
            norm_depots.append({"id": did, "lat": lat, "lon": lon})
        except Exception:
            continue
    if not norm_depots:
        raise HTTPException(status_code=400, detail="no valid depots provided")
    norm_stops: list[dict[str, Any]] = []
    for s in stops:
        try:
            if not isinstance(s, dict):
                continue
            sid = str(s.get("id") or "")
            lat = float(s.get("lat"))
            lon = float(s.get("lon"))
            if not sid:
                continue
            norm_stops.append({"id": sid, "lat": lat, "lon": lon})
        except Exception:
            continue
    assignments: list[dict[str, Any]] = []
    per_depot: dict[str, dict[str, Any]] = {}
    for d in norm_depots:
        per_depot[d["id"]] = {"depot": d, "stops": [], "total_km": 0.0}
    for s in norm_stops:
        best_depot = None
        best_km = float("inf")
        for d in norm_depots:
            d_km = _haversine_km(d["lat"], d["lon"], s["lat"], s["lon"])
            if d_km < best_km:
                best_km = d_km
                best_depot = d
        if best_depot is None:
            continue
        did = best_depot["id"]
        assignments.append(
            {
                "stop_id": s["id"],
                "depot_id": did,
                "distance_km": best_km,
            }
        )
        pd = per_depot[did]
        pd["stops"].append(s)
        pd["total_km"] = float(pd.get("total_km") or 0.0) + (best_km if math.isfinite(best_km) else 0.0)
    return {
        "ok": True,
        "assignments": assignments,
        "per_depot": per_depot,
    }

@app.get("/osm/reverse")
def osm_reverse(lat: float, lon: float):
    """
    Reverse geocoding proxy backed by Nominatim or TomTom.
    """
    now = time.time()
    key = (round(lat, 5), round(lon, 5))
    cached = _OSM_REVERSE_CACHE.get(key)
    if cached and (now - cached[0] < 60):
        return cached[1]
    # Prefer TomTom Reverse Geocoding when configured.
    if TOMTOM_API_KEY:
        base = TOMTOM_BASE.rstrip("/")
        path = f"/search/2/reverseGeocode/{float(lat)},{float(lon)}.json"
        params = {"key": TOMTOM_API_KEY}
        try:
            r = _httpx_client().get(base + path, params=params)
            if r.status_code >= 400:
                raise HTTPException(status_code=502, detail=f"reverse upstream error: {r.text[:200]}")
            j = r.json()
            addresses = j.get("addresses") or []
            if not addresses:
                res = {"lat": lat, "lon": lon, "display_name": ""}
                _OSM_REVERSE_CACHE[key] = (now, res)
                return res
            addr0 = addresses[0]
            try:
                pos = addr0.get("position") or {}
                out_lat = float(pos.get("lat") or pos.get("latitude") or lat)
            except Exception:
                out_lat = lat
            try:
                pos = addr0.get("position") or {}
                out_lon = float(pos.get("lon") or pos.get("longitude") or lon)
            except Exception:
                out_lon = lon
            display_name = ""
            address = addr0.get("address") or {}
            if isinstance(address, dict):
                display_name = (address.get("freeformAddress") or "") or ""
            res = {"lat": out_lat, "lon": out_lon, "display_name": display_name}
            _OSM_REVERSE_CACHE[key] = (now, res)
            return res
        except HTTPException:
            raise
        except Exception as e:
            raise HTTPException(status_code=502, detail=str(e))
    # Fallback: Nominatim / OSM when configured.
    if not NOMINATIM_BASE:
        raise HTTPException(status_code=400, detail="NOMINATIM_BASE_URL not configured and no TomTom key")
    url = NOMINATIM_BASE.rstrip("/") + "/reverse"
    params = {"lat": lat, "lon": lon, "format": "json"}
    headers = {"User-Agent": NOMINATIM_USER_AGENT}
    try:
        r = _httpx_client().get(url, params=params, headers=headers)
        if r.status_code >= 400:
            raise HTTPException(status_code=502, detail=f"reverse upstream error: {r.text[:200]}")
        j = r.json()
        if not isinstance(j, dict):
            return {"lat": lat, "lon": lon, "display_name": ""}
        try:
            out_lat = float(j.get("lat") or lat)
        except Exception:
            out_lat = lat
        try:
            out_lon = float(j.get("lon") or lon)
        except Exception:
            out_lon = lon
        display_name = (j.get("display_name") or "")
        res = {"lat": out_lat, "lon": out_lon, "display_name": display_name}
        _OSM_REVERSE_CACHE[key] = (now, res)
        return res
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/osm/taxi_stands")
def osm_taxi_stands(south: float, west: float, north: float, east: float, response: Response):
    """
    Find taxi stands (amenity=taxi) within a bounding box via Overpass.

    bbox = (south, west, north, east)
    """
    if north <= south or east <= west:
        raise HTTPException(status_code=400, detail="invalid bbox")
    # simple guard: don't allow excessively large boxes
    if (north - south) > 5.0 or (east - west) > 5.0:
        raise HTTPException(status_code=400, detail="bbox too large")
    if not OVERPASS_BASE:
        raise HTTPException(status_code=400, detail="OVERPASS_BASE_URL not configured")
    q = f"""
    [out:json][timeout:25];
    node["amenity"="taxi"]({south},{west},{north},{east});
    out body;
    """
    now = time.time()
    key = (round(south, 3), round(west, 3), round(north, 3), round(east, 3))
    cached = _OSM_TAXI_CACHE.get(key)
    if cached and (now - cached[0] < 60):
        try:
            if response is not None:
                response.headers.setdefault("Cache-Control", "public, max-age=60")
        except Exception:
            pass
        return cached[1]
    try:
        r = _httpx_client().post(
            OVERPASS_BASE,
            data={"data": q},
            headers={"User-Agent": OVERPASS_USER_AGENT},
        )
        if r.status_code >= 400:
            raise HTTPException(status_code=502, detail=f"overpass error: {r.text[:200]}")
        j = r.json()
        elements = j.get("elements") or []
        out = []
        for el in elements:
            try:
                if el.get("type") != "node":
                    continue
                lat = float(el.get("lat"))
                lon = float(el.get("lon"))
                tags = el.get("tags") or {}
                out.append({
                    "id": el.get("id"),
                    "lat": lat,
                    "lon": lon,
                    "name": tags.get("name") or "",
                    "tags": tags,
                })
            except Exception:
                continue
        _OSM_TAXI_CACHE[key] = (now, out)
        try:
            if response is not None:
                response.headers.setdefault("Cache-Control", "public, max-age=60")
        except Exception:
            pass
        return out
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))

@app.post("/auth/request_code")
async def auth_request_code(req: Request):
    try:
        body = await req.json()
        phone = (body.get("phone") or "").strip()
    except Exception:
        phone = ""
    if not phone:
        raise HTTPException(status_code=400, detail="phone required")
    # Blocked phones: do not issue codes
    if phone in _BLOCKED_PHONES:
        raise HTTPException(status_code=403, detail="phone blocked")
    # Basic rate limiting per phone and IP
    _rate_limit_auth(req, phone)
    code = _issue_code(phone)
    resp = {"ok": True, "phone": phone, "ttl": LOGIN_CODE_TTL_SECS}
    # Only expose OTP code when explicitly allowed (typically dev/test).
    if AUTH_EXPOSE_CODES:
        resp["code"] = code
    return resp

@app.post("/auth/verify")
async def auth_verify(req: Request):
    try:
        body = await req.json()
        phone = (body.get("phone") or "").strip()
        code = (body.get("code") or "").strip()
        name = (body.get("name") or "").strip()
    except Exception:
        raise HTTPException(status_code=400, detail="invalid body")
    # Optional: also rate-limit verify requests (same limits as request_code)
    if phone:
        _rate_limit_auth(req, phone)
    if not _check_code(phone, code):
        raise HTTPException(status_code=400, detail="invalid code")
    # Ensure a payments wallet exists for this phone (idempotent).
    # Prefer internal Payments wiring in monolith mode; fallback to HTTP
    # only when explicitly configured.
    wallet_id: str | None = None
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise RuntimeError("payments internal not available")
            data = {"phone": phone}
            try:
                req_model = _PayCreateUserReq(**data)  # type: ignore[name-defined]
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _pay_internal_session() as s:  # type: ignore[name-defined]
                user = _pay_create_user(req_model, s=s)  # type: ignore[name-defined]
                try:
                    wallet_id = getattr(user, "wallet_id", None) or getattr(user, "id", None)  # type: ignore[attr-defined]
                except Exception:
                    wallet_id = None
        elif PAYMENTS_BASE:
            url = PAYMENTS_BASE.rstrip('/') + '/users'
            async with httpx.AsyncClient(timeout=10) as client:
                r = await client.post(url, json={"phone": phone}, headers=_payments_headers())
            if r.headers.get("content-type","" ).startswith("application/json"):
                j = r.json()
                wallet_id = (j.get("wallet_id") or j.get("id")) if isinstance(j, dict) else None  # type: ignore[assignment]
    except HTTPException:
        # Input errors etc.; login should still work.
        wallet_id = None
    except Exception:
        # Payments must not hard-break login.
        wallet_id = None
    # Ensure rider exists in Taxi API
    rider_id = None
    try:
        if TAXI_BASE:
            url = TAXI_BASE.rstrip('/') + '/riders'
            payload = {"phone": phone}
            if name:
                payload["name"] = name
            if wallet_id:
                payload["wallet_id"] = wallet_id
            async with httpx.AsyncClient(timeout=10) as client:
                r = await client.post(url, json=payload)
                if r.headers.get("content-type","" ).startswith("application/json"):
                    j = r.json(); rider_id = j.get("id")
    except Exception:
        rider_id = None
    sid = _create_session(phone)
    # Also return the session ID in JSON so web clients
    # can send it explicitly as header (sa_cookie).
    resp = JSONResponse({"ok": True, "phone": phone, "wallet_id": wallet_id, "rider_id": rider_id, "session": sid})
    resp.set_cookie("sa_session", sid, max_age=AUTH_SESSION_TTL_SECS, httponly=True, secure=True, samesite="lax", path="/")
    return resp


@app.get("/me/wallet")
async def me_wallet(request: Request):
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    # Prefer internal Payments wiring in monolith mode; fallback to HTTP only
    # when explicitly configured.
    try:
        wallet_id: str | None = None
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            data = {"phone": phone}
            try:
                req_model = _PayCreateUserReq(**data)  # type: ignore[name-defined]
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _pay_internal_session() as s:
                user = _pay_create_user(req_model, s=s)
                try:
                    wallet_id = getattr(user, "wallet_id", None) or getattr(user, "id", None)  # type: ignore[attr-defined]
                except Exception:
                    wallet_id = None
        else:
            if not PAYMENTS_BASE:
                raise HTTPException(status_code=500, detail="PAYMENTS_BASE_URL not configured")
            url = PAYMENTS_BASE.rstrip('/') + '/users'
            async with httpx.AsyncClient(timeout=10) as client:
                r = await client.post(url, json={"phone": phone}, headers=_payments_headers())
            if r.headers.get("content-type","" ).startswith("application/json"):
                j = r.json()
            else:
                j = {"raw": r.text, "status_code": r.status_code}
            try:
                if isinstance(j, dict):
                    wallet_id = (j.get("wallet_id") or j.get("id"))  # type: ignore[assignment]
            except Exception:
                wallet_id = None
        return {"ok": True, "phone": phone, "wallet_id": wallet_id}
    except HTTPException:
        raise
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/me/overview")
async def me_overview(request: Request):
    """
    Lightweight aggregate endpoint for clients:
      - authenticated phone number
      - roles (via /me/roles internally)
      - wallet information (via internal Payments or HTTP fallback)
    """
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")

    overview: dict[str, Any] = {"phone": phone}

    # Rollen wiederverwenden, ohne HTTP-Roundtrip
    try:
        roles_obj = me_roles(request)
        overview["roles"] = roles_obj.get("roles", []) if isinstance(roles_obj, dict) else []
    except HTTPException:
        raise
    except Exception:
        overview["roles"] = []

    # Wallet / User aus Payments holen (intern bevorzugt)
    wallet_info: Any = None
    wallet_id: str | None = None
    wallet_error: str | None = None
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise RuntimeError("payments internal not available")
            data = {"phone": phone}
            req_model = _PayCreateUserReq(**data)  # type: ignore[name-defined]
            with _pay_internal_session() as s:
                user = _pay_create_user(req_model, s=s)
                wallet_info = user
                # Versuche Wallet-ID abzuleiten
                try:
                    wallet_id = getattr(user, "wallet_id", None) or getattr(user, "id", None)  # type: ignore[attr-defined]
                except Exception:
                    wallet_id = None
                if wallet_id:
                    try:
                        wallet_obj = _pay_get_wallet(wallet_id=wallet_id, s=s)
                        wallet_info = wallet_obj
                    except Exception:
                        # Fallback: nur User-Objekt
                        pass
        elif PAYMENTS_BASE:
            async with httpx.AsyncClient(timeout=10) as client:
                r = await client.post(
                    _payments_url("/users"),
                    json={"phone": phone},
                    headers=_payments_headers(),
                )
            if r.headers.get("content-type", "").startswith("application/json"):
                j = r.json()
            else:
                j = {"raw": r.text, "status_code": r.status_code}
            wallet_info = j
            try:
                if isinstance(j, dict):
                    wallet_id = (j.get("wallet_id") or j.get("id"))  # type: ignore[assignment]
            except Exception:
                wallet_id = None
    except HTTPException:
        raise
    except Exception as e:
        wallet_error = str(e)

    if wallet_info is not None:
        overview["wallet"] = wallet_info
    if wallet_id:
        overview["wallet_id"] = wallet_id
    if wallet_error:
        overview["wallet_error"] = wallet_error

    return overview


@app.get("/me/dashboard")
async def me_dashboard(request: Request, tx_limit: int = 10):
    """
    A slightly richer aggregate endpoint for clients:
      - base data from /me/overview
      - recent payments of the primary wallet (if available)
    """
    if tx_limit <= 0:
        tx_limit = 10
    tx_limit = min(tx_limit, 50)

    overview = await me_overview(request)
    wallet_id = None
    try:
        wallet_id = overview.get("wallet_id")  # type: ignore[assignment]
        if not wallet_id and isinstance(overview.get("wallet"), dict):
            w = overview.get("wallet") or {}
            if isinstance(w, dict):
                wallet_id = (w.get("wallet_id") or w.get("id"))  # type: ignore[assignment]
    except Exception:
        wallet_id = None

    txns: Any = []
    tx_error: str | None = None
    if wallet_id:
        try:
            txns = payments_txns(wallet_id=str(wallet_id), limit=tx_limit, request=request)
        except HTTPException:
            raise
        except Exception as e:
            tx_error = str(e)

    overview["txns"] = txns
    if tx_error:
        overview["txns_error"] = tx_error
    return overview


@app.get("/me/home_snapshot")
async def me_home_snapshot(request: Request, response: Response = None):  # type: ignore[assignment]
    """
    Aggregated snapshot for the home screen:
      - base: /me/dashboard (phone, roles, wallet, recent payments)
      - flags: is_admin, is_superadmin, operator_domains
      - operator KPIs: Taxi and Bus summaries (if operator/admin)
    """
    snapshot: dict[str, Any] = {}
    base = await me_dashboard(request)
    snapshot.update(base)

    phone = _auth_phone(request)
    roles = base.get("roles") or []
    if not isinstance(roles, list):
        roles = []
    snapshot["roles"] = roles

    snapshot["is_admin"] = False
    snapshot["is_superadmin"] = False
    snapshot["operator_domains"] = []

    if phone:
        try:
            snapshot["is_admin"] = _is_admin(phone)
        except Exception:
            snapshot["is_admin"] = False
        try:
            snapshot["is_superadmin"] = _is_superadmin(phone)
        except Exception:
            snapshot["is_superadmin"] = False
        # Determine operator domains
        op_domains: list[str] = []
        for dom in ("taxi", "bus", "stays", "realestate", "food", "commerce", "freight", "agriculture", "livestock", "carrental", "equipment"):
            try:
                if _is_operator(phone, dom):
                    op_domains.append(dom)
            except Exception:
                continue
        snapshot["operator_domains"] = op_domains
        # Optionally add operator KPIs (best-effort)
        if "taxi" in op_domains:
            try:
                snapshot["taxi_admin_summary"] = taxi_admin_summary(request)
            except HTTPException:
                # Re-raise HTTPException (e.g. 403) so clients see that session/role does not match
                raise
            except Exception as e:
                snapshot["taxi_admin_summary_error"] = str(e)
        if "bus" in op_domains:
            try:
                snapshot["bus_admin_summary"] = bus_admin_summary(request)
            except HTTPException:
                raise
            except Exception as e:
                snapshot["bus_admin_summary_error"] = str(e)

    # Home screen snapshot is user-specific; mark it explicitly as non-cacheable.
    try:
        if response is not None:
            response.headers.setdefault("Cache-Control", "no-store")
    except Exception:
        pass
    return snapshot


@app.get("/me/journey_snapshot")
async def me_journey_snapshot(request: Request, response: Response = None):  # type: ignore[assignment]
    """
    Aggregated "journey" snapshot for the home screen:
      - base: /me/home_snapshot (phone, roles, wallet, KPIs)
      - mobility history: most recent Taxi and Bus rides via /me/mobility_history
      - missing parts are best-effort and returned as empty lists/fields.
    """
    try:
        base = await me_home_snapshot(request, response=response)
        journey: dict[str, Any] = {"home": base}

        # Mobility history (existing handler)
        try:
            mobility = me_mobility_history(request)  # type: ignore[assignment]
        except HTTPException:
            raise
        except Exception as e:
            mobility = {"error": str(e)}
        journey["mobility_history"] = mobility

        return journey
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))

@app.post("/auth/logout")
def auth_logout():
    resp = JSONResponse({"ok": True})
    resp.delete_cookie("sa_session", path="/")
    return resp


@app.get("/auth/device_login_demo", response_class=HTMLResponse)
def device_login_demo() -> HTMLResponse:
    """
    Simple HTML demo page for the QR-based device login flow.
    Renders a QR code with a one-time device_login token and polls
    the backend until the phone approves the login.
    """
    html = """
<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Mirsaal · Device login demo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      body { font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; margin: 0; padding: 0; background: #020617; color: #e5e7eb; }
      .page { min-height: 100vh; display: flex; align-items: center; justify-content: center; padding: 24px; }
      .card { max-width: 480px; width: 100%; background: rgba(15,23,42,0.95); border-radius: 12px; padding: 20px 20px 16px; box-shadow: 0 18px 45px rgba(0,0,0,0.45); border: 1px solid rgba(148,163,184,0.45); }
      h1 { font-size: 20px; margin: 0 0 4px; }
      p { margin: 4px 0; font-size: 14px; color: #9ca3af; }
      label { display: block; font-size: 13px; margin-top: 10px; margin-bottom: 4px; color: #e5e7eb; }
      input[type="text"] { width: 100%; padding: 6px 8px; border-radius: 6px; border: 1px solid #4b5563; background: #020617; color: #e5e7eb; font-size: 14px; }
      button { margin-top: 12px; padding: 8px 14px; border-radius: 999px; border: none; background: #22c55e; color: #022c22; font-weight: 600; font-size: 14px; cursor: pointer; }
      button:disabled { opacity: .6; cursor: default; }
      .qr-wrap { margin-top: 14px; display: flex; align-items: center; justify-content: center; }
      .qr-wrap img { border-radius: 8px; border: 1px solid rgba(75,85,99,0.8); background: white; }
      .status { margin-top: 10px; font-size: 13px; color: #9ca3af; }
      .payload { margin-top: 6px; font-size: 11px; color: #6b7280; word-break: break-all; }
      a { color: #38bdf8; text-decoration: none; }
    </style>
  </head>
  <body>
    <div class="page">
      <div class="card">
        <h1>Mirsaal · Device login</h1>
        <p>Scan this code with Mirsaal on your phone (Scan &gt; Scan QR). Confirm the login on the phone to sign in this browser.</p>
        <label for="dl_label">Device label (optional)</label>
        <input id="dl_label" type="text" value="Web" autocomplete="off" />
        <button id="dl_btn" type="button">Start new login QR</button>
        <div class="qr-wrap">
          <img id="dl_qr_img" src="" alt="Device login QR" width="220" height="220" />
        </div>
        <div id="dl_status" class="status">No active login yet.</div>
        <div id="dl_payload" class="payload"></div>
      </div>
    </div>
    <script>
      let dlToken = null;
      let dlPollTimer = null;

      async function dlStart() {
        const btn = document.getElementById('dl_btn');
        const labEl = document.getElementById('dl_label');
        const statusEl = document.getElementById('dl_status');
        const payloadEl = document.getElementById('dl_payload');
        const img = document.getElementById('dl_qr_img');
        const label = (labEl.value || '').trim();
        btn.disabled = true;
        statusEl.textContent = 'Requesting login token…';
        payloadEl.textContent = '';
        if (dlPollTimer) {
          clearInterval(dlPollTimer);
          dlPollTimer = null;
        }
        try {
          const resp = await fetch('/auth/device_login/start', {
            method: 'POST',
            headers: {'content-type': 'application/json'},
            body: JSON.stringify({label: label || null})
          });
          const data = await resp.json();
          if (!resp.ok || !data.token) {
            statusEl.textContent = 'Failed to start device login.';
            btn.disabled = false;
            return;
          }
          dlToken = data.token;
          const url = new URL(window.location.href);
          const base = url.origin || '';
          const payload = 'shamell://device_login?token=' + encodeURIComponent(dlToken) + (label ? '&label=' + encodeURIComponent(label) : '');
          img.src = 'https://api.qrserver.com/v1/create-qr-code/?size=220x220&data=' + encodeURIComponent(payload);
          img.alt = 'Device login QR';
          statusEl.textContent = 'Waiting for scan and approval on phone…';
          payloadEl.textContent = payload;
          dlPollTimer = setInterval(dlPoll, 2000);
        } catch (e) {
          console.error(e);
          statusEl.textContent = 'Failed to start device login.';
        } finally {
          btn.disabled = false;
        }
      }

      async function dlPoll() {
        if (!dlToken) return;
        const statusEl = document.getElementById('dl_status');
        try {
          const resp = await fetch('/auth/device_login/redeem', {
            method: 'POST',
            headers: {'content-type': 'application/json'},
            body: JSON.stringify({token: dlToken})
          });
          if (!resp.ok) {
            let detail = '';
            try {
              const err = await resp.json();
              detail = (err && err.detail) || '';
            } catch (_) {}
            if (detail && (detail.indexOf('expired') !== -1 || detail.indexOf('not found') !== -1)) {
              statusEl.textContent = 'Login token expired. Start a new QR.';
              clearInterval(dlPollTimer);
              dlPollTimer = null;
              dlToken = null;
            }
            return;
          }
          const data = await resp.json();
          const phone = (data && data.phone) || '';
          statusEl.textContent = phone ? ('Login successful for ' + phone + '. This browser is now signed in.') : 'Login successful.';
          clearInterval(dlPollTimer);
          dlPollTimer = null;
        } catch (e) {
          console.error(e);
        }
      }

      document.getElementById('dl_btn').addEventListener('click', dlStart);
    </script>
  </body>
</html>
"""
    return HTMLResponse(html)

# --- Simple admin: block/unblock drivers by phone (in-memory) ---
@app.post("/admin/block_driver")
async def admin_block_driver(req: Request):
    _require_admin_v2(req)
    try:
        body = await req.json(); phone = (body.get("phone") or "").strip()
    except Exception:
        raise HTTPException(status_code=400, detail="invalid body")
    if not phone:
        raise HTTPException(status_code=400, detail="phone required")
    _BLOCKED_PHONES.add(phone)
    _audit_from_request(req, "admin_block_driver", target_phone=phone)
    return {"ok": True, "phone": phone, "blocked": True}

@app.post("/admin/unblock_driver")
async def admin_unblock_driver(req: Request):
    _require_admin_v2(req)
    try:
        body = await req.json(); phone = (body.get("phone") or "").strip()
    except Exception:
        raise HTTPException(status_code=400, detail="invalid body")
    if not phone:
        raise HTTPException(status_code=400, detail="phone required")
    try:
        _BLOCKED_PHONES.discard(phone)
    except Exception:
        pass
    _audit_from_request(req, "admin_unblock_driver", target_phone=phone)
    return {"ok": True, "phone": phone, "blocked": False}

@app.get("/login", response_class=HTMLResponse)
def login_page() -> HTMLResponse:
    # Browser login page is no longer actively used.
    # Shamell provides the full login/dashboard UI.
    return _legacy_console_removed_page("Shamell Login")

@app.get("/home", response_class=HTMLResponse)
def home_page(request: Request):
    # Legacy HTML start page removed: always redirect to modern shell or login.
    if not _auth_phone(request):
        return RedirectResponse(url="/login", status_code=303)
    return RedirectResponse(url="/app", status_code=303)


@app.get("/", response_class=HTMLResponse)
def root_redirect(request: Request):
    # If authenticated, send to modern app shell; else to login
    if _auth_phone(request):
        return RedirectResponse(url="/app", status_code=303)
    return RedirectResponse(url="/login", status_code=303)


@app.get("/app", response_class=HTMLResponse)
def app_shell(request: Request) -> HTMLResponse:
    # Previously: large mixed SuperApp HTML console.
    # Now: BFF only exposes APIs; UI is Shamell.
    if not _auth_phone(request):
        return RedirectResponse(url="/login", status_code=303)
    return _legacy_console_removed_page("Shamell BFF")
    html = """
<!doctype html>
<html lang="en"><head>
  <meta name=viewport content="width=device-width, initial-scale=1" />
  <title>SuperApp</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="icon" href="/favicon.ico" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tweetnacl/nacl-fast.min.js"></script>
  <script src="https://unpkg.com/html5-qrcode@2.3.10/html5-qrcode.min.js"></script>
  <script src="/ds.js"></script>
  %%GMAPS_TAG%%
  <script>
  // --- tiny design system helpers ---
  // Using utility classes inline, plus a few small helper classes
  const DS = {
    btn: 'px-3 py-2 rounded border border-gray-300 bg-gray-100 hover:bg-gray-200 text-gray-900',
    btnPri: 'px-3 py-2 rounded border border-gray-900 bg-gray-900 text-white',
    btnGood: 'px-3 py-2 rounded border border-gray-300 bg-gray-100 text-gray-900',
    btnWarn: 'px-3 py-2 rounded border border-gray-300 bg-gray-100 text-gray-900',
    chip: 'px-2 py-1 rounded-full bg-white border border-gray-300 text-gray-800 text-xs',
    card: 'rounded border border-gray-300 bg-white',
    input: 'px-3 py-2 rounded border border-gray-300 placeholder-gray-400',
  };
    tailwind.config = { darkMode: 'class' }
  </script>
  <style>
    body{background:#ffffff;color:#000000;}
    .active{background-color:#e5e7eb}
    .glass{background:#ffffff;border:1px solid #d1d5db;border-radius:4px}
  </style>
</head>
<body class="min-h-screen">
  <div class="flex h-screen">
    <aside class="w-64 hidden md:block glass border border-white/20">
      <div class="p-4 text-xl font-semibold">SuperApp</div>
      <nav class="px-2 space-y-1" id="nav">
        <button data-mod="payments" class="w-full text-left px-3 py-2 rounded hover:bg-gray-100">Payments</button>
        <button data-mod="merchant" class="w-full text-left px-3 py-2 rounded hover:bg-gray-100">Merchant POS</button>
        <button data-mod="taxi_driver" class="w-full text-left px-3 py-2 rounded hover:bg-gray-100">Taxi Driver</button>
        <button data-mod="taxi_rider" class="w-full text-left px-3 py-2 rounded hover:bg-gray-100">Taxi Rider</button>
        <button data-mod="taxi_admin" class="w-full text-left px-3 py-2 rounded hover:bg-gray-100">Taxi Admin</button>
        <button data-mod="carmarket" class="w-full text-left px-3 py-2 rounded hover:bg-gray-100">Carmarket</button>
        <button data-mod="carrental" class="w-full text-left px-3 py-2 rounded hover:bg-gray-100">Carrental</button>
        <button data-mod="food" class="w-full text-left px-3 py-2 rounded hover:bg-gray-100">Food</button>
        <button data-mod="realestate" class="w-full text-left px-3 py-2 rounded hover:bg-gray-100">RealEstate</button>
        <button data-mod="stays" class="w-full text-left px-3 py-2 rounded hover:bg-gray-100">Stays</button>
        <button data-mod="freight" class="w-full text-left px-3 py-2 rounded hover:bg-gray-100">Courier</button>
        <button data-mod="chat" class="w-full text-left px-3 py-2 rounded hover:bg-gray-100">Chat</button>
        <div class="px-3 pt-3 text-xs uppercase text-gray-500">Admin</div>
        <button data-mod="risk" class="w-full text-left px-3 py-2 rounded hover:bg-gray-100">Risk Admin</button>
        <button data-mod="exports" class="w-full text-left px-3 py-2 rounded hover:bg-gray-100">Exports</button>
      </nav>
    </aside>
    <main class="flex-1 flex flex-col">
      <header class="flex items-center justify-between px-4 h-14 glass border border-white/20">
        <div class="md:hidden">
          <button id="menuBtn" class="p-2 rounded hover:bg-gray-100 dark:hover:bg-gray-800">☰</button>
        </div>
        <div class="font-semibold">Dashboard</div>
        <div class="flex items-center gap-2">
          <button onclick="me_ensureWallet()" class="px-2 py-1 rounded border border-gray-300 bg-gray-100 text-gray-900">Ensure Wallet</button>
          <button id="themeBtn" class="px-2 py-1 rounded border border-gray-300 bg-gray-100 text-gray-900">Theme</button>
          <button onclick="logout()" class="px-2 py-1 rounded border border-gray-300 bg-gray-100 text-gray-900">Logout</button>
        </div>
      </header>
      <div id="mobileNav" class="md:hidden hidden glass p-2 m-2">
        <div class="grid grid-cols-2 gap-2" id="navMobile"></div>
      </div>
      <!-- Quick Actions -->
      <div class="p-4">
        <div class="max-w-5xl mx-auto">
          <div class="glass border border-white/20 p-3 mb-3 rounded-xl flex items-center gap-2 text-white/90">
            <div class="px-2 py-1 rounded bg-gray-100 text-gray-900">Wallet</div>
            <div class="flex-1 truncate"><span class="opacity-80 text-sm">Wallet</span>
              <div id="me_wallet_chip" class="truncate">—</div></div>
            <button onclick="me_copyWallet()" class="px-2 py-1 rounded bg-white/20 hover:bg-white/30">Copy</button>
          </div>
          <div class="flex flex-wrap gap-2">
            <button onclick="quick_scan_pay()" class="px-4 py-2 rounded border border-gray-300 bg-gray-100 text-gray-900">Scan & Pay</button>
            <button onclick="quick_topup()" class="px-4 py-2 rounded border border-gray-300 bg-gray-100 text-gray-900">Topup</button>
            <button onclick="quick_p2p()" class="px-4 py-2 rounded border border-gray-300 bg-gray-100 text-gray-900">P2P</button>
          </div>
        </div>
      </div>
      <section class="flex-1">
        <!-- Native migrated panels -->
        <div id="panel-payments" class="hidden h-full overflow-auto p-4">
          <div class="max-w-5xl mx-auto space-y-6">
            <!-- Scan flash overlay -->
            <div id="pay_flash" class="fixed inset-0 pointer-events-none opacity-0 transition-opacity duration-200 bg-green-300/30"></div>

            <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-4">
              <div class="text-lg font-semibold mb-3">My Wallet</div>
              <div class="flex gap-2 items-center">
                <input id="me_wallet" class="flex-1 px-3 py-2 rounded border border-gray-300 dark:border-gray-700 bg-transparent" placeholder="my wallet id" />
                <button onclick="pay_saveMe()" class="px-3 py-2 rounded bg-blue-600 text-white">Save</button>
                <span id="me_status" class="text-sm text-gray-500"></span>
              </div>
            </div>

            <!-- Wallet hero -->
            <div id="wallet_hero" class="rounded-2xl p-4 text-white shadow hidden">
              <div class="flex items-center gap-3">
                <div class="p-3 rounded-xl bg-white/15">💳</div>
                <div class="flex-1">
                  <div class="text-sm opacity-90">Wallet</div>
                  <div id="wh_wallet" class="font-semibold truncate"></div>
                </div>
                <div class="text-right">
                  <div class="text-sm opacity-90">Saldo</div>
                  <div id="wh_balance" class="font-bold text-lg">—</div>
                  <div id="wh_kyc" class="text-xs opacity-90"></div>
                </div>
                <button onclick="pay_loadWallet()" class="ml-3 px-2 py-1 rounded bg-white/20 hover:bg-white/30">Refresh</button>
              </div>
            </div>

            <div class="grid md:grid-cols-2 gap-4">
              <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-4">
                <div class="text-lg font-semibold mb-3">Favorites</div>
                <div class="flex gap-2 mb-2">
                  <input id="fav_to2" class="flex-1 px-3 py-2 rounded border border-gray-300 dark:border-gray-700 bg-transparent" placeholder="favorite wallet id" />
                  <input id="fav_alias2" class="flex-1 px-3 py-2 rounded border border-gray-300 dark:border-gray-700 bg-transparent" placeholder="alias (optional)" />
                  <button onclick="pay_addFav()" class="px-3 py-2 rounded bg-blue-600 text-white">Add</button>
                </div>
                <div id="fav_list" class="text-sm"></div>
              </div>
              <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-4">
                <div class="text-lg font-semibold mb-3">Quick Pay</div>
                <div class="flex gap-2 mb-2">
                  <input id="qp_to3" class="flex-1 px-3 py-2 rounded border border-gray-300 dark:border-gray-700 bg-transparent" placeholder="To wallet id or @alias" />
                  <input id="qp_amt3" class="w-40 px-3 py-2 rounded border border-gray-300 dark:border-gray-700 bg-transparent" type="number" placeholder="Amount (cents)" />
                  <button onclick="pay_quickPay()" class="px-3 py-2 rounded bg-green-600 text-white">Pay</button>
                  <button onclick="pay_scan()" class="px-3 py-2 rounded border border-gray-300 dark:border-gray-700">Scan</button>
                </div>
                <div id="qp_recent3" class="flex flex-wrap gap-2"></div>
                <div id="scanner3" class="mt-2" style="width:260px;height:220px"></div>
              </div>
            </div>

            <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-4">
              <div class="text-lg font-semibold mb-3">Requests</div>
              <div class="flex flex-wrap gap-2 mb-3">
                <input id="rq_to3" class="flex-1 min-w-64 px-3 py-2 rounded border border-gray-300 dark:border-gray-700 bg-transparent" placeholder="Payer wallet id or @alias" />
                <input id="rq_amt3" class="w-40 px-3 py-2 rounded border border-gray-300 dark:border-gray-700 bg-transparent" type="number" placeholder="Amount (cents)" />
                <input id="rq_msg3" class="flex-1 min-w-40 px-3 py-2 rounded border border-gray-300 dark:border-gray-700 bg-transparent" placeholder="Message (optional)" />
                <button onclick="pay_createReq()" class="px-3 py-2 rounded bg-blue-600 text-white">Request</button>
                <button onclick="pay_loadReqs()" class="px-3 py-2 rounded border border-gray-300 dark:border-gray-700">Refresh</button>
              </div>
              <div class="grid md:grid-cols-2 gap-4">
                <div>
                  <div class="font-medium mb-2">Incoming</div>
                  <div id="rq_in3" class="space-y-2 text-sm"></div>
                </div>
                <div>
                  <div class="font-medium mb-2">Outgoing</div>
                  <div id="rq_out3" class="space-y-2 text-sm"></div>
                </div>
              </div>
            </div>

          </div>
        </div>

        <!-- Merchant panel (migrated) -->
        <div id="panel-merchant" class="hidden h-full overflow-auto p-4">
          <div class="max-w-5xl mx-auto space-y-6">
            <div class="${DS.card}">
              <div class="text-lg font-semibold mb-3">Merchant Wallet</div>
              <div class="flex gap-2 items-center">
                <input id="merch_wallet" class="flex-1 ${DS.input}" placeholder="wallet id" />
                <button onclick="merch_saveWid()" class="${DS.btnPri}">Save</button>
                <span id="merch_status" class="text-sm text-gray-500"></span>
              </div>
            </div>
            <div class="grid md:grid-cols-2 gap-4">
              <div class="${DS.card}">
                <div class="text-lg font-semibold mb-3">PAY QR</div>
                <div class="flex gap-2 mb-2">
                  <input id="merch_amount" class="w-40 ${DS.input}" type="number" placeholder="Amount (cents)" />
                  <button onclick="merch_genPayQR()" class="${DS.btnPri}">Generate</button>
                </div>
                <div id="merch_qr" class="mt-1"></div>
                <pre id="merch_payload" class="text-sm mt-2"></pre>
              </div>
              <div class="${DS.card}">
                <div class="text-lg font-semibold mb-3">Alias QR</div>
                <div class="flex gap-2 mb-2">
                  <input id="merch_alias" class="flex-1 ${DS.input}" placeholder="@alias" />
                  <input id="merch_a_amount" class="w-40 ${DS.input}" type="number" placeholder="Amount (cents)" />
                  <button onclick="merch_genAliasQR()" class="${DS.btnPri}">Generate</button>
                </div>
                <div id="merch_aqr" class="mt-1"></div>
                <pre id="merch_apayload" class="text-sm mt-2"></pre>
              </div>
            </div>
            <div class="grid md:grid-cols-2 gap-4">
              <div class="${DS.card}">
                <div class="text-lg font-semibold mb-3">Balance</div>
                <button onclick="merch_refreshBal()" class="${DS.btn}">Refresh</button>
                <pre id="merch_bal" class="text-sm mt-2"></pre>
              </div>
              <div class="${DS.card}">
                <div class="text-lg font-semibold mb-3">Recent Transactions</div>
                <button onclick="merch_loadTxns()" class="${DS.btn}">Load</button>
                <pre id="merch_txns" class="text-sm mt-2"></pre>
              </div>
            </div>
          </div>
        </div>

        <!-- Taxi Driver panel (migrated) -->
        <div id="panel-taxi-driver" class="hidden h-full overflow-auto p-4">
          <div class="max-w-5xl mx-auto space-y-6">
            <div class="${DS.card}">
              <div class="text-lg font-semibold mb-3">Register Driver</div>
              <div class="grid md:grid-cols-2 gap-2">
                <input id="td_name" class="${DS.input}" placeholder="Name" />
                <input id="td_phone" class="${DS.input}" placeholder="Phone" />
                <input id="td_make" class="${DS.input}" placeholder="Vehicle make" />
                <input id="td_plate" class="${DS.input}" placeholder="Plate" />
              </div>
              <div class="mt-2 flex gap-2">
                <button onclick="td_register()" class="${DS.btnPri}">Register</button>
                <input id="td_driver" class="flex-1 ${DS.input}" placeholder="driver_id" />
                <button onclick="td_save()" class="${DS.btn}">Save</button>
              </div>
              <pre id="td_out" class="text-sm mt-2"></pre>
            </div>
            <div class="grid md:grid-cols-2 gap-4">
              <div class="${DS.card}">
                <div class="text-lg font-semibold mb-3">Driver Controls</div>
                <div class="flex gap-2 mb-2">
                  <input id="td_wallet" class="flex-1 ${DS.input}" placeholder="driver wallet id" />
                  <button onclick="td_setWallet()" class="${DS.btn}">Set wallet</button>
                </div>
                <div class="flex gap-2">
                  <button onclick="td_online(true)" class="${DS.btnGood}">Go online</button>
                  <button onclick="td_online(false)" class="${DS.btn}">Go offline</button>
                </div>
              </div>
              <div class="${DS.card}">
                <div class="text-lg font-semibold mb-3">Location</div>
                <div class="grid grid-cols-2 gap-2 mb-2">
                  <input id="td_lat" class="${DS.input}" placeholder="lat" />
                  <input id="td_lon" class="${DS.input}" placeholder="lon" />
                </div>
                <div class="flex gap-2">
                  <button onclick="td_updateLoc()" class="${DS.btn}">Update</button>
                  <button onclick="td_track()" class="${DS.btn}">Start track</button>
                  <button onclick="td_stopTrack()" class="${DS.btn}">Stop track</button>
                  <button onclick="td_center()" class="${DS.btn}">Center on me</button>
                </div>
                <div id="td_map" class="rounded border border-gray-200 dark:border-gray-700 mt-3" style="height:300px"></div>
              </div>
            </div>
            <div class="${DS.card}">
              <div class="text-lg font-semibold mb-3">Events</div>
              <pre id="td_events" class="text-sm"></pre>
            </div>
          </div>
        </div>

        <!-- Taxi Rider panel (migrated) -->
        <div id="panel-taxi-rider" class="hidden h-full overflow-auto p-4">
          <div class="max-w-5xl mx-auto space-y-6">
            <div class="${DS.card}">
              <div class="text-lg font-semibold mb-3">Request Ride</div>
              <div class="grid md:grid-cols-2 gap-2 mb-2">
                <input id="tr_phone" class="${DS.input}" placeholder="Rider phone (optional)" />
                <input id="tr_wallet" class="${DS.input}" placeholder="Rider wallet (optional)" />
              </div>
              <div class="grid md:grid-cols-2 gap-2 mb-2">
                <input id="tr_plat" class="${DS.input}" placeholder="pickup lat" />
                <input id="tr_plon" class="${DS.input}" placeholder="pickup lon" />
              </div>
              <div class="grid md:grid-cols-2 gap-2 mb-2">
                <input id="tr_dlat" class="${DS.input}" placeholder="drop lat" />
                <input id="tr_dlon" class="${DS.input}" placeholder="drop lon" />
              </div>
              <div class="flex gap-2 mb-2">
                <button onclick="tr_req()" class="${DS.btnPri}">Request</button>
                <button onclick="tr_bookpay()" class="${DS.btnPri}">Book & Pay</button>
                <button onclick="tr_status()" class="${DS.btn}">Status</button>
                <button onclick="tr_cancel()" class="${DS.btn}">Cancel</button>
              </div>
              <input id="tr_ride" class="w-full ${DS.input}" placeholder="ride_id" />
              <div id="tr_map" class="rounded border border-gray-200 dark:border-gray-700 mt-3" style="height:300px"></div>
              <pre id="tr_out" class="text-sm mt-2"></pre>
            </div>
          </div>
        </div>

        <!-- Taxi Admin panel (migrated) -->
        <div id="panel-taxi-admin" class="hidden h-full overflow-auto p-4">
          <div class="max-w-6xl mx-auto space-y-6">
            <div class="${DS.card}">
              <div class="flex items-center justify-between mb-2">
                <div class="text-lg font-semibold">Map</div>
                <div class="flex gap-2">
                  <button onclick="ta_updateBounds()" class="${DS.btn}">Fit All</button>
                  <button onclick="ta_fitDrivers()" class="${DS.btn}">Fit Drivers</button>
                  <button onclick="ta_fitRides()" class="${DS.btn}">Fit Rides</button>
                </div>
              </div>
              <div id="ta_map" class="rounded border border-gray-200 dark:border-gray-700" style="height:360px"></div>
            </div>
            <div class="${DS.card}">
              <div class="flex items-center justify-between mb-2">
                <div class="text-lg font-semibold">Drivers (online)</div>
                <button onclick="ta_loadDrivers()" class="${DS.btn}">Refresh</button>
              </div>
              <div id="ta_drivers" class="text-sm"></div>
            </div>
            <div class="${DS.card}">
              <div class="flex items-center justify-between mb-2">
                <div class="text-lg font-semibold">Rides</div>
                <div class="flex gap-2 items-center">
                  <select id="ta_rstatus" class="${DS.input}">
                    <option value="">any</option>
                    <option value="requested">requested</option>
                    <option value="assigned">assigned</option>
                    <option value="in_progress">in_progress</option>
                    <option value="completed">completed</option>
                    <option value="canceled">canceled</option>
                  </select>
                  <button onclick="ta_loadRides()" class="${DS.btn}">Refresh</button>
                </div>
              </div>
              <div id="ta_rides" class="text-sm"></div>
              <div class="mt-3 flex gap-2 items-center">
                <input id="ta_ride" class="flex-1 ${DS.input}" placeholder="ride_id" />
                <input id="ta_driver_id" class="flex-1 ${DS.input}" placeholder="driver_id" />
                <button onclick="ta_assign()" class="${DS.btnPri}">Assign</button>
              </div>
              <pre id="ta_out" class="text-sm mt-2"></pre>
            </div>
          </div>
        </div>

        <!-- Carmarket panel (migrated) -->
        <div id="panel-carmarket" class="hidden h-full overflow-auto p-4">
          <div class="max-w-6xl mx-auto space-y-6">
            <div class="${DS.card}">
              <div class="flex items-center justify-between mb-2">
                <div class="text-lg font-semibold">Listings</div>
                <div class="flex gap-2 items-center">
                  <input id="cm_q" class="${DS.input}" placeholder="search" />
                  <input id="cm_city" class="${DS.input}" placeholder="city" />
                  <button onclick="cm_load()" class="${DS.btn}">Load</button>
                </div>
              </div>
              <table class="w-full text-sm">
                <thead><tr><th class="text-left">ID</th><th class="text-left">Title</th><th class="text-left">City</th><th class="text-left">Owner</th><th></th></tr></thead>
                <tbody id="cm_list"></tbody>
              </table>
            </div>
            <div class="${DS.card}">
              <div class="text-lg font-semibold mb-2">Create Listing</div>
              <div class="grid md:grid-cols-3 gap-2 mb-2">
                <input id="cm_title" class="${DS.input}" placeholder="Title" />
                <input id="cm_city2" class="${DS.input}" placeholder="City" />
                <input id="cm_owner" class="${DS.input}" placeholder="Owner wallet" />
              </div>
              <div class="grid md:grid-cols-3 gap-2 mb-2">
                <input id="cm_make" class="${DS.input}" placeholder="Make" />
                <input id="cm_model" class="${DS.input}" placeholder="Model" />
                <input id="cm_year" class="${DS.input}" placeholder="Year" />
              </div>
              <div class="grid md:grid-cols-3 gap-2 mb-2">
                <input id="cm_price" class="${DS.input}" placeholder="Price cents" />
                <input id="cm_desc" class="${DS.input}" placeholder="Description (optional)" />
                <button onclick="cm_create()" class="${DS.btnPri}">Create</button>
              </div>
              <pre id="cm_out" class="text-sm mt-2"></pre>
            </div>
            <div class="${DS.card}">
              <div class="text-lg font-semibold mb-2">Inquiry</div>
              <div class="grid md:grid-cols-3 gap-2 mb-2">
                <input id="cm_sel" class="${DS.input}" placeholder="listing id" />
                <input id="cm_iname" class="${DS.input}" placeholder="Your name" />
                <input id="cm_iphone" class="${DS.input}" placeholder="Phone" />
              </div>
              <div class="flex gap-2">
                <input id="cm_imsg" class="flex-1 ${DS.input}" placeholder="Message" />
                <button onclick="cm_inquiry()" class="${DS.btn}">Send</button>
              </div>
              <pre id="cm_iout" class="text-sm mt-2"></pre>
            </div>
          </div>
        </div>

        <!-- Carrental panel (migrated) -->
        <div id="panel-carrental" class="hidden h-full overflow-auto p-4">
          <div class="max-w-6xl mx-auto space-y-6">
            <div class="${DS.card}">
              <div class="flex items-center justify-between mb-2">
                <div class="text-lg font-semibold">Cars</div>
                <div class="flex gap-2 items-center">
                  <input id="cr_q" class="${DS.input}" placeholder="search" />
                  <input id="cr_city" class="${DS.input}" placeholder="city" />
                  <button onclick="cr_loadCars()" class="${DS.btn}">Load</button>
                </div>
              </div>
              <table class="w-full text-sm">
                <thead><tr><th class="text-left">ID</th><th class="text-left">Title</th><th class="text-left">Make/Model</th><th class="text-left">Year</th><th class="text-left">Price d/h</th><th class="text-left">Owner</th></tr></thead>
                <tbody id="cr_cars"></tbody>
              </table>
            </div>
            <div class="${DS.card}">
              <div class="text-lg font-semibold mb-2">Quote & Book</div>
              <div class="grid md:grid-cols-3 gap-2 mb-2">
                <input id="cr_carid" class="${DS.input}" placeholder="car id" />
                <input id="cr_from" class="${DS.input}" placeholder="from ISO" />
                <input id="cr_to" class="${DS.input}" placeholder="to ISO" />
              </div>
              <div class="flex gap-2 mb-2">
                <button onclick="cr_quote()" class="${DS.btn}">Quote</button>
                <pre id="cr_qout" class="text-sm flex-1"></pre>
              </div>
              <div class="grid md:grid-cols-3 gap-2 mb-2">
                <input id="cr_name" class="${DS.input}" placeholder="Renter name" />
                <input id="cr_phone" class="${DS.input}" placeholder="Renter phone" />
                <input id="cr_rw" class="${DS.input}" placeholder="Renter wallet (optional)" />
              </div>
              <label class="inline-flex items-center gap-2"><input id="cr_confirm" type="checkbox" /> Confirm & pay now</label>
              <div class="mt-2 flex gap-2 items-center">
                <button onclick="cr_book()" class="${DS.btnPri}">Book</button>
                <input id="cr_bid" class="flex-1 ${DS.input}" placeholder="booking id" />
                <button onclick="cr_status()" class="${DS.btn}">Status</button>
                <button onclick="cr_cancel()" class="${DS.btn}">Cancel</button>
                <button onclick="cr_confirm()" class="${DS.btn}">Confirm</button>
              </div>
              <pre id="cr_bout" class="text-sm mt-2"></pre>
              <pre id="cr_bstat" class="text-sm mt-2"></pre>
            </div>
          </div>
        </div>

        <!-- RealEstate panel (migrated) -->
        <div id="panel-realestate" class="hidden h-full overflow-auto p-4">
          <div class="max-w-6xl mx-auto space-y-6">
            <div class="${DS.card}">
              <div class="flex items-center justify-between mb-2">
                <div class="text-lg font-semibold">Properties</div>
                <div class="flex gap-2 items-center">
                  <input id="re_q" class="${DS.input}" placeholder="search" />
                  <input id="re_city" class="${DS.input}" placeholder="city" />
                  <input id="re_minp" class="${DS.input}" placeholder="min price" />
                  <input id="re_maxp" class="${DS.input}" placeholder="max price" />
                  <input id="re_minb" class="${DS.input}" placeholder="min beds" />
                  <button onclick="re_loadProps()" class="${DS.btn}">Load</button>
                </div>
              </div>
              <table class="w-full text-sm">
                <thead><tr><th class="text-left">ID</th><th class="text-left">Title</th><th class="text-left">City</th><th class="text-left">Price</th><th class="text-left">Beds</th><th class="text-left">Owner</th><th></th></tr></thead>
                <tbody id="re_props"></tbody>
              </table>
            </div>
            <div class="${DS.card}">
              <div class="text-lg font-semibold mb-2">Create / Update</div>
              <div class="grid md:grid-cols-3 gap-2 mb-2">
                <input id="re_pid" class="${DS.input}" placeholder="id (for update)" />
                <input id="re_title" class="${DS.input}" placeholder="title" />
                <input id="re_price" class="${DS.input}" placeholder="price_cents" />
              </div>
              <div class="grid md:grid-cols-3 gap-2 mb-2">
                <input id="re_city2" class="${DS.input}" placeholder="city" />
                <input id="re_addr" class="${DS.input}" placeholder="address" />
                <input id="re_beds" class="${DS.input}" placeholder="bedrooms" />
              </div>
              <div class="grid md:grid-cols-3 gap-2 mb-2">
                <input id="re_baths" class="${DS.input}" placeholder="bathrooms" />
                <input id="re_area" class="${DS.input}" placeholder="area sqm" />
                <input id="re_owner" class="${DS.input}" placeholder="owner wallet" />
              </div>
              <div class="flex gap-2">
                <button onclick="re_create()" class="${DS.btnPri}">Create</button>
                <button onclick="re_update()" class="${DS.btn}">Update</button>
              </div>
              <pre id="re_out" class="text-sm mt-2"></pre>
            </div>
            <div class="${DS.card}">
              <div class="text-lg font-semibold mb-2">Inquiry / Reserve</div>
              <div class="grid md:grid-cols-3 gap-2 mb-2">
                <input id="re_sel" class="${DS.input}" placeholder="property id" />
                <input id="re_iname" class="${DS.input}" placeholder="name" />
                <input id="re_iphone" class="${DS.input}" placeholder="phone" />
              </div>
              <div class="flex gap-2 mb-2">
                <input id="re_imsg" class="flex-1 ${DS.input}" placeholder="message" />
                <button onclick="re_inquiry()" class="${DS.btn}">Send Inquiry</button>
              </div>
              <div class="grid md:grid-cols-3 gap-2 mb-2">
                <input id="re_buyer" class="${DS.input}" placeholder="buyer wallet" />
                <input id="re_dep" class="${DS.input}" placeholder="deposit cents" />
                <button onclick="re_reserve()" class="${DS.btn}">Reserve</button>
              </div>
              <pre id="re_iout" class="text-sm mt-2"></pre>
            </div>
          </div>
        </div>

        <!-- Food panel (migrated) -->
        <div id="panel-food" class="hidden h-full overflow-auto p-4">
          <div class="max-w-6xl mx-auto space-y-6">
            <div class="${DS.card}">
              <div class="flex items-center justify-between mb-2">
                <div class="text-lg font-semibold">Restaurants</div>
                <div class="flex gap-2 items-center">
                  <input id="f_q" class="${DS.input}" placeholder="search" />
                  <input id="f_city" class="${DS.input}" placeholder="city" />
                  <button onclick="food_loadRests()" class="${DS.btn}">Load</button>
                </div>
              </div>
              <table id="f_rests" class="w-full text-sm">
                <thead><tr><th class="text-left">ID</th><th class="text-left">Name</th><th class="text-left">City</th><th class="text-left">Owner</th><th class="text-left"></th></tr></thead>
                <tbody></tbody>
              </table>
            </div>
            <div class="${DS.card}">
              <div class="text-lg font-semibold mb-2">Menu</div>
              <div class="flex gap-2 mb-2 items-center">
                <input id="f_rid" class="${DS.input}" placeholder="restaurant id" />
                <button onclick="food_loadMenu()" class="${DS.btn}">Load menu</button>
              </div>
              <table id="f_menu" class="w-full text-sm">
                <thead><tr><th class="text-left">ID</th><th class="text-left">Name</th><th class="text-left">Price</th><th class="text-left">Qty</th></tr></thead>
                <tbody></tbody>
              </table>
            </div>
            <div class="${DS.card}">
              <div class="text-lg font-semibold mb-2">Place Order</div>
              <div class="grid md:grid-cols-3 gap-2 mb-2">
                <input id="f_cname" class="${DS.input}" placeholder="Customer name" />
                <input id="f_cphone" class="${DS.input}" placeholder="Customer phone" />
                <input id="f_wallet" class="${DS.input}" placeholder="Wallet (optional)" />
              </div>
              <label class="inline-flex items-center gap-2"><input id="f_confirm" type="checkbox" /> Confirm & pay now</label>
              <div class="mt-2 flex gap-2">
                <button onclick="food_placeOrder()" class="${DS.btnPri}">Place order</button>
                <input id="f_oid" class="flex-1 ${DS.input}" placeholder="order id" />
                <button onclick="food_status()" class="${DS.btn}">Status</button>
                <select id="f_st" class="${DS.input}"><option>new</option><option>confirmed</option><option>preparing</option><option>ready</option><option>delivered</option><option>canceled</option></select>
                <button onclick="food_set()" class="${DS.btn}">Set</button>
              </div>
              <pre id="f_oout" class="text-sm mt-2"></pre>
              <pre id="f_os" class="text-sm mt-2"></pre>
              <div class="mt-4 border-t border-gray-200 pt-3">
                <div class="text-sm font-semibold mb-1">Delivery QR (escrow)</div>
                <p class="text-xs text-gray-600 mb-2">
                  Generate a QR code for the courier. The customer scans it in the app to release the escrow payment to the restaurant.
                </p>
                <div class="flex items-center gap-2 mb-2">
                  <button onclick="food_showQr()" class="${DS.btn}">Show delivery QR</button>
                </div>
                <div id="f_qrwrap" class="mt-1">
                  <img id="f_qr" alt="Delivery QR" class="border rounded" style="max-width:220px;max-height:220px;display:none" />
                </div>
              </div>
            </div>
            <div class="${DS.card}">
              <div class="flex items-center justify-between mb-2">
                <div class="text-lg font-semibold">Today's orders</div>
                <button onclick="food_loadOrdersToday()" class="${DS.btn}">Reload</button>
              </div>
              <table id="f_orders" class="w-full text-sm">
                <thead>
                  <tr>
                    <th class="text-left">ID</th>
                    <th class="text-left">Restaurant</th>
                    <th class="text-left">Total</th>
                    <th class="text-left">Status</th>
                    <th class="text-left">Escrow</th>
                    <th class="text-left"></th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>
          </div>
        </div>

        <!-- Stays panel (migrated) -->
        <div id="panel-stays" class="hidden h-full overflow-auto p-4">
          <div class="max-w-6xl mx-auto space-y-6">
            <div class="${DS.card}">
              <div class="flex items-center justify-between mb-2">
                <div class="text-lg font-semibold">Listings</div>
                <div class="flex gap-2 items-center">
                  <input id="st_q" class="${DS.input}" placeholder="search" />
                  <input id="st_city" class="${DS.input}" placeholder="city" />
                  <button onclick="st_load()" class="${DS.btn}">Load</button>
                </div>
              </div>
              <table class="w-full text-sm">
                <thead><tr><th class="text-left">ID</th><th class="text-left">Title</th><th class="text-left">City</th><th class="text-left">Price/night</th><th class="text-left">Owner</th><th></th></tr></thead>
                <tbody id="st_list"></tbody>
              </table>
            </div>
            <div class="${DS.card}">
              <div class="text-lg font-semibold mb-2">Quote & Book</div>
              <div class="grid md:grid-cols-3 gap-2 mb-2">
                <input id="st_lid" class="${DS.input}" placeholder="listing id" />
                <input id="st_from" class="${DS.input}" placeholder="from ISO" />
                <input id="st_to" class="${DS.input}" placeholder="to ISO" />
              </div>
              <div class="grid md:grid-cols-3 gap-2 mb-2">
                <input id="st_gname" class="${DS.input}" placeholder="Guest name" />
                <input id="st_gphone" class="${DS.input}" placeholder="Guest phone" />
                <input id="st_gw" class="${DS.input}" placeholder="Guest wallet (optional)" />
              </div>
              <label class="inline-flex items-center gap-2"><input id="st_confirm" type="checkbox" /> Confirm & pay now</label>
              <div class="mt-2 flex gap-2 items-center">
                <button onclick="st_quote()" class="${DS.btn}">Quote</button>
                <pre id="st_qout" class="text-sm flex-1"></pre>
              </div>
              <div class="mt-2 flex gap-2 items-center">
                <button onclick="st_book()" class="${DS.btnPri}">Book</button>
                <input id="st_bid" class="flex-1 ${DS.input}" placeholder="booking id" />
                <button onclick="st_status()" class="${DS.btn}">Status</button>
              </div>
              <pre id="st_bout" class="text-sm mt-2"></pre>
              <pre id="st_bst" class="text-sm mt-2"></pre>
            </div>
          </div>
        </div>

        <!-- Courier panel (alias for Freight) -->
        <div id="panel-freight" class="hidden h-full overflow-auto p-4">
          <div class="max-w-6xl mx-auto space-y-6">
            <div class="${DS.card}">
              <div class="text-lg font-semibold mb-3">Quote</div>
              <div class="grid md:grid-cols-2 gap-2 mb-2">
                <input id="fr_title" class="${DS.input}" placeholder="Title" />
                <input id="fr_kg" class="${DS.input}" placeholder="Weight kg" />
              </div>
              <div class="grid md:grid-cols-4 gap-2 mb-2">
                <input id="fr_flat" class="${DS.input}" placeholder="from lat" />
                <input id="fr_flon" class="${DS.input}" placeholder="from lon" />
                <input id="fr_tlat" class="${DS.input}" placeholder="to lat" />
                <input id="fr_tlon" class="${DS.input}" placeholder="to lon" />
              </div>
              <div class="flex gap-2 items-center">
                <button onclick="fr_quote()" class="${DS.btn}">Quote</button>
                <pre id="fr_qout" class="text-sm flex-1"></pre>
              </div>
            </div>
            <div class="${DS.card}">
              <div class="text-lg font-semibold mb-3">Book</div>
              <div class="grid md:grid-cols-3 gap-2 mb-2">
                <input id="fr_payer" class="${DS.input}" placeholder="Payer wallet" />
                <input id="fr_carrier" class="${DS.input}" placeholder="Carrier wallet" />
                <label class="inline-flex items-center gap-2"><input id="fr_confirm" type="checkbox" /> Confirm & pay</label>
              </div>
              <div class="flex gap-2 items-center">
                <button onclick="fr_book()" class="${DS.btnPri}">Book</button>
                <input id="fr_sid" class="flex-1 ${DS.input}" placeholder="shipment id" />
                <button onclick="fr_status()" class="${DS.btn}">Status</button>
                <select id="fr_st" class="${DS.input}"><option>booked</option><option>in_transit</option><option>delivered</option><option>canceled</option></select>
                <button onclick="fr_set()" class="${DS.btn}">Set</button>
              </div>
              <pre id="fr_bout" class="text-sm mt-2"></pre>
              <pre id="fr_sout" class="text-sm mt-2"></pre>
            </div>
          </div>
        </div>

        <!-- Chat panel (migrated) -->
        <div id="panel-chat" class="hidden h-full overflow-auto p-4">
          <div class="max-w-5xl mx-auto space-y-6">
            <div class="${DS.card}">
              <div class="text-lg font-semibold mb-2">Your Identity</div>
              <div class="flex gap-2 mb-2">
                <button onclick="ch_gen()" class="${DS.btn}">Generate keys</button>
                <input id="ch_myid" class="${DS.input}" placeholder="Device ID" />
                <input id="ch_myname" class="${DS.input}" placeholder="Display name" />
                <button onclick="ch_register()" class="${DS.btnPri}">Register</button>
              </div>
              <pre id="ch_me" class="text-sm"></pre>
              <div class="mt-2">
                <div class="font-medium">Share</div>
                <pre id="ch_share" class="text-sm"></pre>
                <div id="ch_qr" class="mt-2"></div>
                <small>My fingerprint: <code id="ch_myfp"></code></small>
              </div>
              <div class="mt-2">
                <button onclick="ch_scanStart()" class="${DS.btn}">Scan Peer QR</button>
                <div id="ch_scanner" style="width:260px;height:220px" class="mt-2"></div>
              </div>
            </div>
            <div class="${DS.card}">
              <div class="text-lg font-semibold mb-2">Contact</div>
              <div class="flex gap-2 mb-2">
                <input id="ch_peerid" class="${DS.input}" placeholder="Peer ID" />
                <button onclick="ch_resolve()" class="${DS.btn}">Fetch peer key</button>
              </div>
              <pre id="ch_peer" class="text-sm"></pre>
              <small>Peer fingerprint: <code id="ch_peerfp"></code> · Verified: <span id="ch_verif">no</span></small>
              <div class="mt-2">
                <button onclick="ch_markVerified()" class="${DS.btn}">Mark verified</button>
              </div>
            </div>
            <div class="${DS.card}">
              <div class="text-lg font-semibold mb-2">Send message</div>
              <textarea id="ch_plain" class="w-full px-3 py-2 rounded border border-gray-300 dark:border-gray-700 bg-transparent" placeholder="Message..."></textarea>
              <button onclick="ch_send()" class="${DS.btnPri} mt-2">Send</button>
              <pre id="ch_sendout" class="text-sm mt-2"></pre>
            </div>
            <div class="${DS.card}">
              <div class="text-lg font-semibold mb-2">Inbox <small>WS: <span id="ch_live">disconnected</span></small></div>
              <div class="flex gap-2 mb-2">
                <button onclick="ch_poll()" class="${DS.btn}">Poll</button>
              </div>
              <pre id="ch_inbox" class="text-sm"></pre>
            </div>
          </div>
        </div>

        <!-- Legacy iframe fallback for non-migrated modules -->
        <iframe id="frame" src="/payments-social" class="w-full h-full"></iframe>
      </section>
    </main>
  </div>
  <script>
  const map = {
    payments:'/payments-social', merchant:'/merchant', taxi_driver:'/taxi/driver', taxi_rider:'/taxi/rider', taxi_admin:'/taxi/admin', carmarket:'/carmarket', carrental:'/carrental', food:'/food', realestate:'/realestate', stays:'/stays', freight:'/freight', chat:'/chat', risk:'/admin/risk', exports:'/admin/exports'
  };
  function setMod(k){ for(const b of document.querySelectorAll('#nav button')){ b.classList.toggle('active', b.dataset.mod===k); }
    if(k==='payments'){
      document.getElementById('panel-payments').classList.remove('hidden');
      document.getElementById('frame').classList.add('hidden');
      pay_init();
    } else if(k==='merchant'){
      document.getElementById('panel-payments').classList.add('hidden');
      document.getElementById('panel-merchant').classList.remove('hidden');
      document.getElementById('panel-taxi-driver').classList.add('hidden');
      document.getElementById('panel-taxi-rider').classList.add('hidden');
      document.getElementById('panel-taxi-admin').classList.add('hidden');
      document.getElementById('panel-carmarket').classList.add('hidden');
      document.getElementById('panel-carrental').classList.add('hidden');
      document.getElementById('panel-realestate').classList.add('hidden');
      document.getElementById('panel-stays').classList.add('hidden');
      document.getElementById('panel-freight').classList.add('hidden');
      document.getElementById('panel-chat').classList.add('hidden');
      document.getElementById('panel-food').classList.add('hidden');
      document.getElementById('frame').classList.add('hidden');
      merch_init();
    } else if(k==='taxi_driver'){
      document.getElementById('panel-payments').classList.add('hidden');
      document.getElementById('panel-merchant').classList.add('hidden');
      document.getElementById('panel-taxi-driver').classList.remove('hidden');
      document.getElementById('panel-taxi-rider').classList.add('hidden');
      document.getElementById('panel-taxi-admin').classList.add('hidden');
      document.getElementById('panel-carmarket').classList.add('hidden');
      document.getElementById('panel-carrental').classList.add('hidden');
      document.getElementById('panel-realestate').classList.add('hidden');
      document.getElementById('panel-stays').classList.add('hidden');
      document.getElementById('panel-freight').classList.add('hidden');
      document.getElementById('panel-chat').classList.add('hidden');
      document.getElementById('panel-food').classList.add('hidden');
      document.getElementById('frame').classList.add('hidden');
      td_mapSetup(); td_init();
    } else if(k==='taxi_rider'){
      document.getElementById('panel-payments').classList.add('hidden');
      document.getElementById('panel-merchant').classList.add('hidden');
      document.getElementById('panel-taxi-driver').classList.add('hidden');
      document.getElementById('panel-taxi-rider').classList.remove('hidden');
      document.getElementById('panel-taxi-admin').classList.add('hidden');
      document.getElementById('panel-carmarket').classList.add('hidden');
      document.getElementById('panel-carrental').classList.add('hidden');
      document.getElementById('panel-realestate').classList.add('hidden');
      document.getElementById('panel-stays').classList.add('hidden');
      document.getElementById('panel-freight').classList.add('hidden');
      document.getElementById('panel-chat').classList.add('hidden');
      document.getElementById('panel-food').classList.add('hidden');
      document.getElementById('frame').classList.add('hidden');
      tr_mapSetup();
    } else if(k==='taxi_admin'){
      document.getElementById('panel-payments').classList.add('hidden');
      document.getElementById('panel-merchant').classList.add('hidden');
      document.getElementById('panel-taxi-driver').classList.add('hidden');
      document.getElementById('panel-taxi-rider').classList.add('hidden');
      document.getElementById('panel-taxi-admin').classList.remove('hidden');
      document.getElementById('panel-carmarket').classList.add('hidden');
      document.getElementById('panel-carrental').classList.add('hidden');
      document.getElementById('panel-realestate').classList.add('hidden');
      document.getElementById('panel-stays').classList.add('hidden');
      document.getElementById('panel-freight').classList.add('hidden');
      document.getElementById('panel-chat').classList.add('hidden');
      document.getElementById('panel-food').classList.add('hidden');
      document.getElementById('frame').classList.add('hidden');
      ta_mapSetup(); ta_loadDrivers(); ta_loadRides();
    } else if(k==='realestate'){
      document.getElementById('panel-payments').classList.add('hidden');
      document.getElementById('panel-merchant').classList.add('hidden');
      document.getElementById('panel-taxi-driver').classList.add('hidden');
      document.getElementById('panel-taxi-rider').classList.add('hidden');
      document.getElementById('panel-taxi-admin').classList.add('hidden');
      document.getElementById('panel-carmarket').classList.add('hidden');
      document.getElementById('panel-carrental').classList.add('hidden');
      document.getElementById('panel-realestate').classList.remove('hidden');
      document.getElementById('panel-stays').classList.add('hidden');
      document.getElementById('panel-freight').classList.add('hidden');
      document.getElementById('panel-chat').classList.add('hidden');
      document.getElementById('panel-food').classList.add('hidden');
      document.getElementById('frame').classList.add('hidden');
      re_init();
    } else if(k==='carmarket'){
      document.getElementById('panel-payments').classList.add('hidden');
      document.getElementById('panel-merchant').classList.add('hidden');
      document.getElementById('panel-taxi-driver').classList.add('hidden');
      document.getElementById('panel-taxi-rider').classList.add('hidden');
      document.getElementById('panel-taxi-admin').classList.add('hidden');
      document.getElementById('panel-carmarket').classList.remove('hidden');
      document.getElementById('panel-carrental').classList.add('hidden');
      document.getElementById('panel-realestate').classList.add('hidden');
      document.getElementById('panel-stays').classList.add('hidden');
      document.getElementById('panel-freight').classList.add('hidden');
      document.getElementById('panel-chat').classList.add('hidden');
      document.getElementById('panel-food').classList.add('hidden');
      document.getElementById('frame').classList.add('hidden');
      cm_init();
    } else if(k==='carrental'){
      document.getElementById('panel-payments').classList.add('hidden');
      document.getElementById('panel-merchant').classList.add('hidden');
      document.getElementById('panel-taxi-driver').classList.add('hidden');
      document.getElementById('panel-taxi-rider').classList.add('hidden');
      document.getElementById('panel-taxi-admin').classList.add('hidden');
      document.getElementById('panel-carmarket').classList.add('hidden');
      document.getElementById('panel-carrental').classList.remove('hidden');
      document.getElementById('panel-realestate').classList.add('hidden');
      document.getElementById('panel-stays').classList.add('hidden');
      document.getElementById('panel-freight').classList.add('hidden');
      document.getElementById('panel-chat').classList.add('hidden');
      document.getElementById('panel-food').classList.add('hidden');
      document.getElementById('frame').classList.add('hidden');
      cr_init();
    } else if(k==='food'){
      document.getElementById('panel-payments').classList.add('hidden');
      document.getElementById('panel-merchant').classList.add('hidden');
      document.getElementById('panel-taxi-driver').classList.add('hidden');
      document.getElementById('panel-taxi-rider').classList.add('hidden');
      document.getElementById('panel-taxi-admin').classList.add('hidden');
      document.getElementById('panel-carmarket').classList.add('hidden');
      document.getElementById('panel-carrental').classList.add('hidden');
      document.getElementById('panel-realestate').classList.add('hidden');
      document.getElementById('panel-stays').classList.add('hidden');
      document.getElementById('panel-freight').classList.add('hidden');
      document.getElementById('panel-chat').classList.add('hidden');
      document.getElementById('panel-food').classList.remove('hidden');
      document.getElementById('frame').classList.add('hidden');
      food_init();
    } else if(k==='stays'){
      document.getElementById('panel-payments').classList.add('hidden');
      document.getElementById('panel-merchant').classList.add('hidden');
      document.getElementById('panel-taxi-driver').classList.add('hidden');
      document.getElementById('panel-taxi-rider').classList.add('hidden');
      document.getElementById('panel-taxi-admin').classList.add('hidden');
      document.getElementById('panel-carmarket').classList.add('hidden');
      document.getElementById('panel-carrental').classList.add('hidden');
      document.getElementById('panel-realestate').classList.add('hidden');
      document.getElementById('panel-stays').classList.remove('hidden');
      document.getElementById('panel-freight').classList.add('hidden');
      document.getElementById('panel-chat').classList.add('hidden');
      document.getElementById('panel-food').classList.add('hidden');
      document.getElementById('frame').classList.add('hidden');
      st_init();
    } else if(k==='freight'){
      document.getElementById('panel-payments').classList.add('hidden');
      document.getElementById('panel-merchant').classList.add('hidden');
      document.getElementById('panel-taxi-driver').classList.add('hidden');
      document.getElementById('panel-taxi-rider').classList.add('hidden');
      document.getElementById('panel-taxi-admin').classList.add('hidden');
      document.getElementById('panel-carmarket').classList.add('hidden');
      document.getElementById('panel-carrental').classList.add('hidden');
      document.getElementById('panel-realestate').classList.add('hidden');
      document.getElementById('panel-stays').classList.add('hidden');
      document.getElementById('panel-freight').classList.remove('hidden');
      document.getElementById('panel-chat').classList.add('hidden');
      document.getElementById('panel-food').classList.add('hidden');
      document.getElementById('frame').classList.add('hidden');
      fr_init();
    } else if(k==='chat'){
      document.getElementById('panel-payments').classList.add('hidden');
      document.getElementById('panel-merchant').classList.add('hidden');
      document.getElementById('panel-taxi-driver').classList.add('hidden');
      document.getElementById('panel-taxi-rider').classList.add('hidden');
      document.getElementById('panel-taxi-admin').classList.add('hidden');
      document.getElementById('panel-carmarket').classList.add('hidden');
      document.getElementById('panel-carrental').classList.add('hidden');
      document.getElementById('panel-realestate').classList.add('hidden');
      document.getElementById('panel-stays').classList.add('hidden');
      document.getElementById('panel-freight').classList.add('hidden');
      document.getElementById('panel-chat').classList.remove('hidden');
      document.getElementById('panel-food').classList.add('hidden');
      document.getElementById('frame').classList.add('hidden');
      ch_init();
    } else {
      document.getElementById('panel-payments').classList.add('hidden');
      document.getElementById('panel-merchant').classList.add('hidden');
      document.getElementById('panel-taxi-driver').classList.add('hidden');
      document.getElementById('panel-taxi-rider').classList.add('hidden');
      document.getElementById('panel-taxi-admin').classList.add('hidden');
      document.getElementById('panel-carmarket').classList.add('hidden');
      document.getElementById('panel-carrental').classList.add('hidden');
      document.getElementById('panel-realestate').classList.add('hidden');
      document.getElementById('panel-stays').classList.add('hidden');
      document.getElementById('panel-freight').classList.add('hidden');
      document.getElementById('panel-chat').classList.add('hidden');
      document.getElementById('panel-food').classList.add('hidden');
      document.getElementById('frame').classList.remove('hidden');
      const url = map[k]||'/payments-social'; document.getElementById('frame').src=url;
    }
  }
  const params = new URLSearchParams(location.search); if(params.get('mod')) setMod(params.get('mod'));
  for(const b of document.querySelectorAll('#nav button')){ b.addEventListener('click', ()=>setMod(b.dataset.mod)); }
  // mobile nav
  const navMobile = document.getElementById('navMobile');
  document.getElementById('menuBtn').addEventListener('click', ()=>{ const el=document.getElementById('mobileNav'); el.classList.toggle('hidden'); });
  for(const k in map){ const a=document.createElement('button'); a.textContent=k.replace('_',' '); a.className='px-2 py-2 rounded border border-gray-300 dark:border-gray-700'; a.onclick=()=>{ setMod(k); document.getElementById('mobileNav').classList.add('hidden'); }; navMobile.appendChild(a); }
  // theme
  const themeBtn=document.getElementById('themeBtn');
  function applyTheme(){ const d=localStorage.getItem('sa_theme')||'light'; document.documentElement.classList.toggle('dark', d==='dark'); themeBtn.textContent = d==='dark'?'☀️':'🌙'; }
  themeBtn.addEventListener('click', ()=>{ const cur=localStorage.getItem('sa_theme')||'light'; localStorage.setItem('sa_theme', cur==='dark'?'light':'dark'); applyTheme(); }); applyTheme();
  async function logout(){ await fetch('/auth/logout',{method:'POST'}); location.href='/login'; }

  // Quick actions
  function quick_scan_pay(){ setMod('payments'); setTimeout(()=>{ try{ pay_scan(); }catch(e){} }, 60); }
  async function quick_topup(){
    try{
      const me = (localStorage.getItem('me_wallet')||'').trim();
      const w = prompt('Wallet ID to top up', me);
      if(!w) return;
      const a = parseInt(prompt('Amount (cents)', '10000')||'0',10);
      if(!(a>0)){ alert('Invalid amount'); return; }
      const r = await fetch('/payments/wallets/'+encodeURIComponent(w)+'/topup', {method:'POST', headers:{'content-type':'application/json','Idempotency-Key':'qa-'+Date.now()}, body: JSON.stringify({amount_cents:a})});
      const t = await r.text();
      alert(r.status+': '+t);
    }catch(e){ alert('Topup error: '+e); }
  }
  function quick_p2p(){ setMod('payments'); setTimeout(()=>{ try{ document.getElementById('qp_to3')?.focus(); }catch(_){ } }, 60); }

  // Payments panel logic (migrated)
  function pay_me(){ const el=document.getElementById('me_wallet'); let v=el.value.trim(); if(!v){ v=localStorage.getItem('me_wallet')||''; el.value=v; } return v; }
  function pay_saveMe(){ const v=document.getElementById('me_wallet').value.trim(); localStorage.setItem('me_wallet', v); document.getElementById('me_status').textContent='Saved'; pay_loadWallet(); pay_loadFavs(); pay_loadReqs(); }
  function pay_recent(){ try{ return JSON.parse(localStorage.getItem('recent_payees')||'[]'); }catch(e){ return []; } }
  function pay_saveRecent(list){ localStorage.setItem('recent_payees', JSON.stringify(list)); pay_renderRecent(); }
  function pay_addRecent(target){ if(!target) return; const list=pay_recent().filter(x=>x!==target); list.unshift(target); while(list.length>5) list.pop(); pay_saveRecent(list); }
  function _hue(s){ let h=0; for(let i=0;i<s.length;i++){ h=(h*31 + s.charCodeAt(i))&0xffffffff; } return Math.abs(h)%360; }
  function avatarHTML(label){ const h=_hue(label.replace('@','')); const c1=`hsl(${h} 90% 55%)`; const c2=`hsl(${(h+24)%360} 85% 65%)`; const init=(label.replace('@','')[0]||'?').toUpperCase(); return `<span class=\"inline-flex items-center justify-center w-7 h-7 rounded-full shadow\" style=\"background:linear-gradient(135deg, ${c1}, ${c2}); color:white; font-weight:700;\">${init}</span>`; }
  function pay_renderRecent(){ const list=pay_recent(); const el=document.getElementById('qp_recent3'); if(!el) return; el.textContent=''; for(const t of list){ const b=document.createElement('button'); b.className='flex items-center gap-2 px-2 py-1 rounded border border-gray-300 dark:border-gray-700 text-sm'; b.innerHTML=avatarHTML(t)+`<span class=\\"truncate max-w-[12rem]\\">${t}</span>`; b.onclick=()=>{ document.getElementById('qp_to3').value=t; }; el.appendChild(b); } }
  async function pay_addFav(){ const o=pay_me(); const to=document.getElementById('fav_to2').value.trim(); const alias=(document.getElementById('fav_alias2').value||'').trim()||null; if(!o||!to){ alert('me/favorite required'); return; } const r=await fetch('/payments/favorites',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({owner_wallet_id:o,favorite_wallet_id:to,alias:alias})}); if(!r.ok){ alert('error'); } pay_loadFavs(); }
  async function pay_loadFavs(){ const o=pay_me(); if(!o){ return; } const r=await fetch('/payments/favorites?owner_wallet_id='+encodeURIComponent(o)); const arr=await r.json(); const box=document.getElementById('fav_list'); box.innerHTML=''; for(const f of arr){ const row=document.createElement('div'); row.className='flex items-center justify-between border-b border-gray-200 dark:border-gray-700 py-1'; const label=(f.alias||''); const id=f.favorite_wallet_id; row.innerHTML=`<div class=\"flex items-center gap-2\">${avatarHTML(label||id)}<span>${label||''} <small class=\"text-gray-500\">${id}</small></span></div>`; const act=document.createElement('div'); const payBtn=document.createElement('button'); payBtn.textContent='Pay'; payBtn.className='px-2 py-1 rounded bg-green-600 text-white text-sm'; payBtn.onclick=()=>pay_payTarget(label?label:id); const delBtn=document.createElement('button'); delBtn.textContent='Delete'; delBtn.className='ml-2 px-2 py-1 rounded border border-gray-300 dark:border-gray-700 text-sm'; delBtn.onclick=async()=>{ await fetch('/payments/favorites/'+f.id,{method:'DELETE'}); pay_loadFavs(); }; act.appendChild(payBtn); act.appendChild(delBtn); row.appendChild(act); box.appendChild(row);} }
  async function pay_payTarget(target){ const from=pay_me(); if(!from){ alert('save my wallet first'); return; } let amt=parseInt(prompt('Amount (cents):','1000')||'0',10); if(!(amt>0)){ return; } const ik='mx-'+Date.now().toString(36)+'-'+Math.random().toString(36).slice(2,6); const body=(target.startsWith('@')? {from_wallet_id:from,to_alias:target,amount_cents:amt}: {from_wallet_id:from,to_wallet_id:target,amount_cents:amt}); const r=await fetch('/payments/transfer',{method:'POST',headers:{'content-type':'application/json','Idempotency-Key':ik},body:JSON.stringify(body)}); if(!r.ok){ alert('pay failed'); } else { pay_addRecent(target); alert('paid'); } }

  // Stays panel logic
  function st_val(id){ return (document.getElementById(id).value||'').trim(); }
  async function st_init(){ try{ await st_load(); }catch(_){ } }
  async function st_load(){ const u=new URLSearchParams(); const q=st_val('st_q'); if(q)u.set('q',q); const c=st_val('st_city'); if(c)u.set('city',c); const r=await fetch('/stays/listings?'+u.toString()); const arr=await r.json(); const tb=document.getElementById('st_list'); tb.innerHTML=''; for(const x of arr){ const tr=document.createElement('tr'); tr.innerHTML = `<td>${x.id}</td><td>${x.title}</td><td>${x.city||''}</td><td>${x.price_per_night_cents}</td><td><small>${x.owner_wallet_id||''}</small></td><td><button class='${DS.btn}' onclick='document.getElementById("st_lid").value=${x.id}'>Select</button></td>`; tb.appendChild(tr);} }
  async function st_quote(){ const body={listing_id: parseInt(st_val('st_lid')||'0',10), from_iso:st_val('st_from'), to_iso:st_val('st_to')}; const r=await fetch('/stays/quote',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); document.getElementById('st_qout').textContent = await r.text(); }
  async function st_book(){ const body={listing_id: parseInt(st_val('st_lid')||'0',10), guest_name:st_val('st_gname'), guest_phone:st_val('st_gphone'), guest_wallet_id:st_val('st_gw')||null, from_iso:st_val('st_from'), to_iso:st_val('st_to'), confirm: document.getElementById('st_confirm').checked}; const r=await fetch('/stays/book',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); const t=await r.text(); document.getElementById('st_bout').textContent=t; try{ const j=JSON.parse(t); document.getElementById('st_bid').value=j.id; }catch(_){ } }
  async function st_status(){ const id=st_val('st_bid'); if(!id){ alert('set booking id'); return; } const r=await fetch('/stays/bookings/'+encodeURIComponent(id)); document.getElementById('st_bst').textContent = await r.text(); }

  // Freight panel logic
  function fr_val(id){ return (document.getElementById(id).value||'').trim(); }
  async function fr_init(){ }
  async function fr_quote(){ const body={title:fr_val('fr_title'), from_lat:parseFloat(fr_val('fr_flat')), from_lon:parseFloat(fr_val('fr_flon')), to_lat:parseFloat(fr_val('fr_tlat')), to_lon:parseFloat(fr_val('fr_tlon')), weight_kg:parseFloat(fr_val('fr_kg'))}; const r=await fetch('/freight/quote',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); document.getElementById('fr_qout').textContent=await r.text(); }
  async function fr_book(){ const body={title:fr_val('fr_title'), from_lat:parseFloat(fr_val('fr_flat')), from_lon:parseFloat(fr_val('fr_flon')), to_lat:parseFloat(fr_val('fr_tlat')), to_lon:parseFloat(fr_val('fr_tlon')), weight_kg:parseFloat(fr_val('fr_kg')), payer_wallet_id:fr_val('fr_payer')||null, carrier_wallet_id:fr_val('fr_carrier')||null, confirm:document.getElementById('fr_confirm').checked}; const r=await fetch('/freight/book',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); const t=await r.text(); document.getElementById('fr_bout').textContent=t; try{ const j=JSON.parse(t); document.getElementById('fr_sid').value=j.id; }catch(_){ } }
  async function fr_status(){ const id=fr_val('fr_sid'); if(!id){ alert('set shipment id'); return; } const r=await fetch('/freight/shipments/'+encodeURIComponent(id)); document.getElementById('fr_sout').textContent = await r.text(); }
  async function fr_set(){ const id=fr_val('fr_sid'); if(!id){ alert('set shipment id'); return; } const st=document.getElementById('fr_st').value; const r=await fetch('/freight/shipments/'+encodeURIComponent(id)+'/status',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({status:st})}); document.getElementById('fr_sout').textContent = await r.text(); }

  // Chat panel logic
  let chMy={pk:null, sk:null, id:null, name:null};
  let chPeers={};
  let chWs=null;
  function ch_b64(u8){ return btoa(String.fromCharCode.apply(null, Array.from(u8))); }
  function ch_unb64(s){ return new Uint8Array(atob(s).split('').map(c=>c.charCodeAt(0))); }
  async function ch_sha256(u8){ const buf = await crypto.subtle.digest('SHA-256', u8); return new Uint8Array(buf); }
  function ch_toHex(u8){ return Array.from(u8).map(b=>b.toString(16).padStart(2,'0')).join(''); }
  async function ch_computeFpB64(pkB64){ try{ const u=ch_unb64(pkB64); const d=await ch_sha256(u); if(d){ return ch_toHex(d).slice(0,16); } }catch(_){ } return (pkB64||'').slice(0,16); }
  function ch_isVerified(pid, fp){ try{ return localStorage.getItem('verified_peer_'+pid) === fp; }catch(_){ return false; } }
  function ch_gi(id){ return (document.getElementById(id).value||'').trim(); }
  function ch_init(){ try{ ch_connectWS(); }catch(_){ } }
  function ch_gen(){ const kp=nacl.box.keyPair(); chMy.pk=kp.publicKey; chMy.sk=kp.secretKey; const id=(Math.random().toString(36).slice(2,10)); chMy.id=id; document.getElementById('ch_myid').value=id; document.getElementById('ch_me').textContent='PublicKey(b64)='+ch_b64(chMy.pk); const payload='CHAT|id='+id+'|pk='+ch_b64(chMy.pk); document.getElementById('ch_share').textContent=payload; try{ makeQR(payload); const qr=document.getElementById('ch_qr'); const el=document.getElementById('qr'); if(el&&qr&&el.parentElement!==qr){ qr.appendChild(el.firstChild); } }catch(_){ } ch_updateMyFp(); ch_connectWS(); }
  async function ch_register(){ const id=ch_gi('ch_myid'); chMy.id=id; const name=ch_gi('ch_myname'); chMy.name=name; if(!chMy.pk){ alert('Generate keys'); return; } const body={device_id:id, public_key_b64:ch_b64(chMy.pk), name:name||null}; const r=await fetch('/chat/devices/register',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); document.getElementById('ch_me').textContent=await r.text(); ch_connectWS(); }
  async function ch_resolve(){ const id=ch_gi('ch_peerid'); const r=await fetch('/chat/devices/'+encodeURIComponent(id)); const j=await r.json(); chPeers[id]=j.public_key_b64; document.getElementById('ch_peer').textContent=JSON.stringify(j,null,2); ch_updatePeerFp(); }
  async function ch_send(){ const id=ch_gi('ch_peerid'); const pkb64=chPeers[id]; if(!pkb64){ alert('resolve peer first'); return; } const msg=(document.getElementById('ch_plain').value||''); const nonce=nacl.randomBytes(24); const peerPk=ch_unb64(pkb64); const box=nacl.box(new TextEncoder().encode(msg), nonce, peerPk, chMy.sk); const body={sender_id: chMy.id, recipient_id:id, sender_pubkey_b64: ch_b64(chMy.pk), nonce_b64: ch_b64(nonce), box_b64: ch_b64(box)}; const r=await fetch('/chat/messages/send',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); document.getElementById('ch_sendout').textContent=await r.text(); }
  async function ch_poll(){ const r=await fetch('/chat/messages/inbox?device_id='+encodeURIComponent(chMy.id)+'&limit=20'); const arr=await r.json(); const out=[]; for(const m of arr.reverse()){ try{ const nonce=ch_unb64(m.nonce_b64); const box=ch_unb64(m.box_b64); const spk=ch_unb64(m.sender_pubkey_b64); const plain=nacl.box.open(box, nonce, spk, chMy.sk); out.push({from:m.sender_id, text:(plain? new TextDecoder().decode(plain):'<decrypt failed>')}); try{ await fetch('/chat/messages/'+encodeURIComponent(m.id)+'/read',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({read:true})}); }catch(_){ } }catch(e){ out.push({from:m.sender_id, text:'<error>'}); } } document.getElementById('ch_inbox').textContent=JSON.stringify(out,null,2); }
  async function ch_scanStart(){ try{ const el=document.getElementById('ch_scanner'); const html5QrCode=new Html5Qrcode(el.id); await html5QrCode.start({ facingMode:'environment' }, { fps:10, qrbox:200 }, (decodedText)=>{ try{ if(decodedText&&decodedText.startsWith('CHAT|')){ const parts=decodedText.split('|'); const map={}; for(const p of parts.slice(1)){ const kv=p.split('='); if(kv.length==2) map[kv[0]]=kv[1]; } if(map['id']&&map['pk']){ chPeers[map['id']]=map['pk']; document.getElementById('ch_peerid').value=map['id']; document.getElementById('ch_peer').textContent=JSON.stringify({device_id:map['id'], public_key_b64:map['pk']},null,2); ch_updatePeerFp(); html5QrCode.stop(); } } }catch(_){ } }); }catch(e){ alert('scan error: '+e); }
  async function ch_updateMyFp(){ try{ const fp=await ch_computeFpB64(ch_b64(chMy.pk)); document.getElementById('ch_myfp').textContent=fp; }catch(_){ } }
  async function ch_updatePeerFp(){ try{ const pid=ch_gi('ch_peerid'); const pkb64=chPeers[pid]; if(!pkb64){ return; } const fp=await ch_computeFpB64(pkb64); document.getElementById('ch_peerfp').textContent=fp; document.getElementById('ch_verif').textContent=(ch_isVerified(pid,fp)?'yes':'no'); }catch(_){ } }
  async function ch_markVerified(){ const pid=ch_gi('ch_peerid'); const pkb64=chPeers[pid]; if(!pid||!pkb64){ alert('resolve/scan peer first'); return; } const fp=await ch_computeFpB64(pkb64); try{ localStorage.setItem('verified_peer_'+pid, fp); document.getElementById('ch_verif').textContent='yes'; }catch(_){ } }
  function ch_connectWS(){ try{ if(!chMy.id){ return; } if(chWs&&(chWs.readyState===1||chWs.readyState===0)){ return; } const base=(location.protocol==='https:'?'wss://':'ws://')+location.host; chWs=new WebSocket(base+'/ws/chat/inbox?device_id='+encodeURIComponent(chMy.id)); const live=document.getElementById('ch_live'); chWs.onopen=()=>{ if(live) live.textContent='connected'; }; chWs.onclose=()=>{ if(live) live.textContent='disconnected'; }; chWs.onerror=()=>{ if(live) live.textContent='error'; }; chWs.onmessage=async (ev)=>{ try{ const msg=JSON.parse(ev.data); if(msg&&msg.type==='inbox'&&Array.isArray(msg.messages)){ const outEl=document.getElementById('ch_inbox'); const out=[]; for(const m of msg.messages){ try{ const nonce=ch_unb64(m.nonce_b64); const box=ch_unb64(m.box_b64); const spk=ch_unb64(m.sender_pubkey_b64); const plain=nacl.box.open(box, nonce, spk, chMy.sk); out.push({from:m.sender_id, text:(plain? new TextDecoder().decode(plain):'<decrypt failed>')}); try{ await fetch('/chat/messages/'+encodeURIComponent(m.id)+'/read',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({read:true})}); }catch(_){ } }catch(e){ out.push({from:m.sender_id, text:'<error>'}); } } try{ const prev=outEl.textContent? JSON.parse(outEl.textContent):[]; outEl.textContent=JSON.stringify(prev.concat(out), null, 2); }catch(_){ outEl.textContent=JSON.stringify(out, null, 2); } } }catch(_){ } };
  }catch(_){ }
  }

  // Carmarket panel logic
  function cm_val(id){ return (document.getElementById(id).value||'').trim(); }
  async function cm_init(){ try{ await cm_load(); }catch(_){ } }
  async function cm_load(){ const u=new URLSearchParams(); const q=cm_val('cm_q'); if(q)u.set('q',q); const c=cm_val('cm_city'); if(c)u.set('city',c); const r=await fetch('/carmarket/listings?'+u.toString()); const arr=await r.json(); const tb=document.getElementById('cm_list'); tb.innerHTML=''; for(const x of arr){ const tr=document.createElement('tr'); tr.innerHTML = `<td>${x.id}</td><td>${x.title}</td><td>${x.city||''}</td><td><small>${x.owner_wallet_id||''}</small></td><td><button class='${DS.btn}' onclick='document.getElementById("cm_sel").value=${x.id}'>Select</button> <button class='${DS.btn}' onclick='cm_del(${x.id})'>Delete</button></td>`; tb.appendChild(tr);} }
  async function cm_create(){ const body={title:cm_val('cm_title'), city:cm_val('cm_city2')||null, make:cm_val('cm_make')||null, model:cm_val('cm_model')||null, year:(cm_val('cm_year')||null), price_cents: parseInt(cm_val('cm_price')||'0',10), description:cm_val('cm_desc')||null, owner_wallet_id:cm_val('cm_owner')||null}; const r=await fetch('/carmarket/listings',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); document.getElementById('cm_out').textContent = await r.text(); cm_load(); }
  async function cm_del(id){ if(!confirm('Delete listing '+id+'?')) return; await fetch('/carmarket/listings/'+id,{method:'DELETE'}); cm_load(); }
  async function cm_inquiry(){ const body={listing_id: parseInt(cm_val('cm_sel')||'0',10), name:cm_val('cm_iname'), phone:cm_val('cm_iphone')||null, message:cm_val('cm_imsg')||null}; const r=await fetch('/carmarket/inquiries',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); document.getElementById('cm_iout').textContent = await r.text(); }

  // Carrental panel logic
  function cr_val(id){ return (document.getElementById(id).value||'').trim(); }
  async function cr_init(){ try{ await cr_loadCars(); }catch(_){ } }
  async function cr_loadCars(){ const u=new URLSearchParams(); const q=cr_val('cr_q'); if(q)u.set('q',q); const c=cr_val('cr_city'); if(c)u.set('city',c); const r=await fetch('/carrental/cars?'+u.toString()); const arr=await r.json(); const tb=document.getElementById('cr_cars'); tb.innerHTML=''; for(const x of arr){ const tr=document.createElement('tr'); tr.innerHTML = `<td>${x.id}</td><td>${x.title}</td><td>${x.make||''} ${x.model||''}</td><td>${x.year||''}</td><td>${x.price_per_day_cents||''}/${x.price_per_hour_cents||''}</td><td><small>${x.owner_wallet_id||''}</small></td>`; tb.appendChild(tr);} }
  async function cr_quote(){ const body={car_id: parseInt(cr_val('cr_carid')||'0',10), from_iso:cr_val('cr_from'), to_iso:cr_val('cr_to')}; const r=await fetch('/carrental/quote',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); document.getElementById('cr_qout').textContent = await r.text(); }
  async function cr_book(){ const body={car_id: parseInt(cr_val('cr_carid')||'0',10), renter_name:cr_val('cr_name'), renter_phone:cr_val('cr_phone'), renter_wallet_id:cr_val('cr_rw')||null, from_iso:cr_val('cr_from'), to_iso:cr_val('cr_to'), confirm: document.getElementById('cr_confirm').checked}; const r=await fetch('/carrental/book',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); const t=await r.text(); document.getElementById('cr_bout').textContent=t; try{ const j=JSON.parse(t); document.getElementById('cr_bid').value=j.id; }catch(_){ } }
  async function cr_status(){ const id=cr_val('cr_bid'); if(!id){ alert('set booking id'); return; } const r=await fetch('/carrental/bookings/'+encodeURIComponent(id)); document.getElementById('cr_bstat').textContent = await r.text(); }
  async function cr_cancel(){ const id=cr_val('cr_bid'); if(!id){ alert('set booking id'); return; } const r=await fetch('/carrental/bookings/'+encodeURIComponent(id)+'/cancel',{method:'POST'}); document.getElementById('cr_bstat').textContent = await r.text(); }
  async function cr_confirm(){ const id=cr_val('cr_bid'); if(!id){ alert('set booking id'); return; } const r=await fetch('/carrental/bookings/'+encodeURIComponent(id)+'/confirm',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({confirm:true})}); document.getElementById('cr_bstat').textContent = await r.text(); }

  // RealEstate panel logic
  function re_val(id){ return (document.getElementById(id).value||'').trim(); }
  async function re_init(){ try{ await re_loadProps(); }catch(_){ } }
  async function re_loadProps(){ const u=new URLSearchParams(); const q=re_val('re_q'); if(q)u.set('q',q); const c=re_val('re_city'); if(c)u.set('city',c); const minp=re_val('re_minp'); if(minp)u.set('min_price',minp); const maxp=re_val('re_maxp'); if(maxp)u.set('max_price',maxp); const minb=re_val('re_minb'); if(minb)u.set('min_bedrooms',minb); const r=await fetch('/realestate/properties?'+u.toString()); const arr=await r.json(); const tb=document.getElementById('re_props'); tb.innerHTML=''; for(const p of arr){ const tr=document.createElement('tr'); tr.innerHTML=`<td>${p.id}</td><td>${p.title}</td><td>${p.city||''}</td><td>${p.price_cents}</td><td>${p.bedrooms||''}</td><td><small>${p.owner_wallet_id||''}</small></td><td><button class='${DS.btn}' onclick='document.getElementById("re_sel").value=${p.id}'>Select</button></td>`; tb.appendChild(tr); } }
  async function re_create(){ const body={title:re_val('re_title'), price_cents:parseInt(re_val('re_price')||'0',10), city:re_val('re_city2')||null, address:re_val('re_addr')||null, bedrooms:parseInt(re_val('re_beds')||'0',10)||null, bathrooms:parseInt(re_val('re_baths')||'0',10)||null, area_sqm:parseFloat(re_val('re_area')||'0')||null, owner_wallet_id:re_val('re_owner')||null}; const r=await fetch('/realestate/properties',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); document.getElementById('re_out').textContent = await r.text(); re_loadProps(); }
  async function re_update(){ const id=parseInt(re_val('re_pid')||'0',10); if(!id){ alert('set id'); return; } const body={title:re_val('re_title')||undefined, price_cents:(re_val('re_price')?parseInt(re_val('re_price'),10):undefined), city:re_val('re_city2')||undefined, address:re_val('re_addr')||undefined, bedrooms:(re_val('re_beds')?parseInt(re_val('re_beds'),10):undefined), bathrooms:(re_val('re_baths')?parseInt(re_val('re_baths'),10):undefined), area_sqm:(re_val('re_area')?parseFloat(re_val('re_area')):undefined), owner_wallet_id:re_val('re_owner')||undefined}; const r=await fetch('/realestate/properties/'+id,{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); document.getElementById('re_out').textContent = await r.text(); re_loadProps(); }
  async function re_inquiry(){ const pid=parseInt(re_val('re_sel')||'0',10); const body={property_id:pid, name:re_val('re_iname'), phone:re_val('re_iphone')||null, message:re_val('re_imsg')||null}; const r=await fetch('/realestate/inquiries',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); document.getElementById('re_iout').textContent = await r.text(); }
  async function re_reserve(){ const pid=parseInt(re_val('re_sel')||'0',10); const body={property_id:pid, buyer_wallet_id:re_val('re_buyer'), deposit_cents:parseInt(re_val('re_dep')||'0',10)}; const r=await fetch('/realestate/reserve',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); document.getElementById('re_iout').textContent = await r.text(); }
  // Food panel logic (migrated)
  function fgi(id){ return (document.getElementById(id).value||'').trim(); }
  async function food_init(){ try{ await food_loadRests(); await food_loadOrdersToday(); }catch(_){ } }
  async function food_loadRests(){ const u=new URLSearchParams(); const q=fgi('f_q'); if(q)u.set('q',q); const c=fgi('f_city'); if(c)u.set('city',c); const r=await fetch('/food/restaurants?'+u.toString()); const arr=await r.json(); const tb=document.querySelector('#f_rests tbody'); tb.innerHTML=''; for(const x of arr){ const tr=document.createElement('tr'); tr.innerHTML = `<td>${x.id}</td><td>${x.name}</td><td>${x.city||''}</td><td><small>${x.owner_wallet_id||''}</small></td><td><button class='${DS.btn}' onclick='food_sel(${x.id})'>Select</button></td>`; tb.appendChild(tr); } }
  async function food_sel(id){ document.getElementById('f_rid').value = id; await food_loadMenu(); }
  async function food_loadMenu(){ const rid=parseInt(fgi('f_rid')||'0',10); if(!rid){ alert('set restaurant id'); return; } const r=await fetch('/food/restaurants/'+rid+'/menu'); const arr=await r.json(); const tb=document.querySelector('#f_menu tbody'); tb.innerHTML=''; for(const m of arr){ const tr=document.createElement('tr'); tr.innerHTML = `<td>${m.id}</td><td>${m.name}</td><td>${m.price_cents}</td><td><input id='fq_${m.id}' class='${DS.input}' value='1' style='width:70px' /></td>`; tb.appendChild(tr); } }
  async function food_placeOrder(){ const rid=parseInt(fgi('f_rid')||'0',10); if(!rid){ alert('choose restaurant'); return; } const qs=Array.from(document.querySelectorAll('#f_menu tbody input')); const items=[]; for(const q of qs){ const id=parseInt(q.id.split('_')[1],10); const qty=parseInt(q.value||'0',10); if(qty>0) items.push({menu_item_id:id, qty:qty}); } if(items.length===0){ alert('choose items'); return; } const body={restaurant_id:rid, customer_name:fgi('f_cname'), customer_phone:fgi('f_cphone'), customer_wallet_id:fgi('f_wallet')||null, items, confirm:document.getElementById('f_confirm').checked}; const r=await fetch('/food/orders',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); const t=await r.text(); document.getElementById('f_oout').textContent=t; try{ const j=JSON.parse(t); document.getElementById('f_oid').value=j.id; }catch(_){} }
  async function food_status(){ const id=fgi('f_oid'); if(!id){ alert('set order id'); return; } const r=await fetch('/food/orders/'+encodeURIComponent(id)); document.getElementById('f_os').textContent=await r.text(); }
  async function food_set(){ const id=fgi('f_oid'); if(!id){ alert('set order id'); return; } const st=fgi('f_st'); const r=await fetch('/food/orders/'+encodeURIComponent(id)+'/status',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({status:st})}); document.getElementById('f_os').textContent=await r.text(); }
  function food_showQr(){ const id=fgi('f_oid'); if(!id){ alert('set order id'); return; } const img=document.getElementById('f_qr'); if(!img) return; img.src='/food/orders/'+encodeURIComponent(id)+'/escrow_qr?ts='+Date.now(); img.style.display='block'; }
  async function food_loadOrdersToday(){ try{ const now=new Date(); const start=new Date(now.getFullYear(),now.getMonth(),now.getDate()); const end=new Date(now.getFullYear(),now.getMonth(),now.getDate()+1); const u=new URLSearchParams(); u.set('limit','200'); u.set('from_iso',start.toISOString()); u.set('to_iso',end.toISOString()); const r=await fetch('/food/orders?'+u.toString()); const arr=await r.json(); const tb=document.querySelector('#f_orders tbody'); if(!tb) return; tb.innerHTML=''; for(const o of arr){ const id=(o.id||'').toString(); const rid=(o.restaurant_id||'').toString(); const total=parseInt(o.total_cents||0,10); const status=(o.status||'').toString(); const esc=(o.escrow_status||'none').toString(); const tr=document.createElement('tr'); tr.innerHTML=`<td>${id}</td><td>${rid}</td><td>${total>0?total+' SYP':''}</td><td>${status}</td><td>${esc}</td><td><button class='${DS.btn}' onclick='food_qr("${id}")'>QR</button></td>`; tb.appendChild(tr); } }catch(_){ } }
  function food_qr(id){ if(!id){ alert('set order id'); return; } const img=document.getElementById('f_qr'); if(!img) return; document.getElementById('f_oid').value=id; img.src='/food/orders/'+encodeURIComponent(id)+'/escrow_qr?ts='+Date.now(); img.style.display='block'; }
  async function pay_quickPay(){ const from=pay_me(); const to=document.getElementById('qp_to3').value.trim(); const amt=parseInt(document.getElementById('qp_amt3').value||'0',10); if(!from||!to||(amt<=0)){ alert('fields missing'); return; } const ik='qp-'+Date.now().toString(36)+'-'+Math.random().toString(36).slice(2,6); const body=(to.startsWith('@')? {from_wallet_id:from,to_alias:to,amount_cents:amt}: {from_wallet_id:from,to_wallet_id:to,amount_cents:amt}); const r=await fetch('/payments/transfer',{method:'POST',headers:{'content-type':'application/json','Idempotency-Key':ik},body:JSON.stringify(body)}); if(!r.ok){ alert('pay failed'); } else { try{ if(navigator.vibrate) navigator.vibrate(35);}catch(e){} pay_addRecent(to); pay_loadWallet(); alert('paid'); } }
  function pay_flash(){ const f=document.getElementById('pay_flash'); if(!f) return; f.classList.remove('opacity-0'); f.classList.add('opacity-100'); setTimeout(()=>{ f.classList.add('opacity-0'); f.classList.remove('opacity-100'); }, 380); }
  async function pay_scan(){ try{ const el=document.getElementById('scanner3'); const html5QrCode = new Html5Qrcode(el.id); await html5QrCode.start({ facingMode: 'environment' }, { fps: 10, qrbox: 200 }, (t)=>{ try{ if(t && (t.startsWith('PAY|')||t.startsWith('ALIAS|'))){ const parts=t.split('|'); const m={}; for(const p of parts.slice(1)){ const kv=p.split('='); if(kv.length==2) m[kv[0]]=decodeURIComponent(kv[1]); } if(m['wallet']) document.getElementById('qp_to3').value=m['wallet']; if(m['name']) document.getElementById('qp_to3').value=m['name']; if(m['amount']) document.getElementById('qp_amt3').value=m['amount']; try{ if(navigator.vibrate) navigator.vibrate(20);}catch(e){} pay_flash(); html5QrCode.stop(); } }catch(_){ } }); }catch(e){ alert('scan error: '+e); } }
  function heroGradient(kyc){ const dark=document.documentElement.classList.contains('dark'); if(kyc==='pro') return dark? 'linear-gradient(90deg,#6d28d9,#f59e0b)' : 'linear-gradient(90deg,#7c3aed,#fbbf24)'; if(kyc==='plus') return dark? 'linear-gradient(90deg,#2563eb,#14b8a6)' : 'linear-gradient(90deg,#3b82f6,#22c55e)'; return dark? 'linear-gradient(90deg,#1e3a8a,#0ea5e9)' : 'linear-gradient(90deg,#4f46e5,#60a5fa)'; }
  async function pay_loadWallet(){ const w=pay_me(); const hero=document.getElementById('wallet_hero'); if(!w){ if(hero) hero.classList.add('hidden'); return; } try{ const r=await fetch('/payments/wallets/'+encodeURIComponent(w)); if(!r.ok){ if(hero) hero.classList.add('hidden'); return; } const j=await r.json(); document.getElementById('wh_wallet').textContent=w; const bal=(j.balance_cents||0)+' '+(j.currency||''); document.getElementById('wh_balance').textContent=bal; const kyc=((j.kyc_level||'')+'').toLowerCase()||'basic'; document.getElementById('wh_kyc').textContent='KYC: '+kyc; hero.style.background = heroGradient(kyc); hero.classList.remove('hidden'); }catch(_){ if(hero) hero.classList.add('hidden'); } }
  function pay_init(){ pay_me(); pay_renderRecent(); pay_loadFavs(); pay_loadReqs(); pay_loadWallet(); }

  // Merchant logic
  function merch_w(){ const el=document.getElementById('merch_wallet'); let v=el.value.trim(); if(!v){ v=localStorage.getItem('merchant_wid')||''; el.value=v; } return v; }
  function merch_saveWid(){ const v=document.getElementById('merch_wallet').value.trim(); localStorage.setItem('merchant_wid', v); document.getElementById('merch_status').textContent='Saved'; }
  function makeQR(text){ // small QR engine (GIF)
    function R(o){this.mode=4;this.data=o;this.parsedData=[];for(var r=0,l=this.data.length;r<l;r++){var t=[],h=this.data.charCodeAt(r);h>65536?(t[0]=240|(1835008&h)>>>18,t[1]=128|(258048&h)>>>12,t[2]=128|(4032&h)>>>6,t[3]=128|63&h):h>2048?(t[0]=224|(61440&h)>>>12,t[1]=128|(4032&h)>>>6,t[2]=128|63&h):h>128?(t[0]=192|(1984&h)>>>6,t[1]=128|63&h):t[0]=h,this.parsedData.push(t)}this.parsedData=Array.prototype.concat.apply([],this.parsedData),this.parsedData.length!=this.data.length&&(this.parsedData.unshift(191),this.parsedData.unshift(187),this.parsedData.unshift(239))}
    R.prototype.getLength=function(){return this.parsedData.length}; R.prototype.write=function(o){for(var r=0,l=this.parsedData.length;r<l;r++)o.put(this.parsedData[r],8)};
    function L(o,r){this.typeNumber=o,this.errorCorrectLevel=r,this.modules=null,this.moduleCount=0,this.dataCache=null,this.dataList=[]}
    L.prototype.addData=function(o){this.dataList.push(new R(o)),this.dataCache=null}; L.prototype.isDark=function(o,r){if(o<0||this.moduleCount<=o||r<0||this.moduleCount<=r)throw new Error(o+","+r);return this.modules[o][r]}; L.prototype.getModuleCount=function(){return this.moduleCount}; L.prototype.make=function(){this.makeImpl(!1,this.getBestMaskPattern())}; L.prototype.makeImpl=function(o,r){this.moduleCount=21,this.modules=new Array(this.moduleCount);for(var l=0;l<this.moduleCount;l++){this.modules[l]=new Array(this.moduleCount);for(var n=0;n<this.moduleCount;n++)this.modules[l][n]=null}this.setupPositionProbePattern(0,0),this.setupPositionProbePattern(this.moduleCount-7,0),this.setupPositionProbePattern(0,this.moduleCount-7),this.mapData(this.createData(this.typeNumber,this.errorCorrectLevel,r),r)}; L.prototype.setupPositionProbePattern=function(o,r){for(var l=-1;l<=7;l++)if(!(o+l<=-1||this.moduleCount<=o+l))for(var n=-1;n<=7;n++)r+n<=-1||this.moduleCount<=r+n||(this.modules[o+l][r+n]=l>=0&&l<=6&&(0==n||6==n)||n>=0&&n<=6&&(0==l||6==l)||l>=2&&l<=4&&n>=2&&n<=4)}; L.prototype.getBestMaskPattern=function(){return 0}; L.prototype.createData=function(o,r){for(var l=[],n=0;n<this.dataList.length;n++){var t=this.dataList[n];l.push(4),l.push(t.getLength()),l=l.concat(t.parsedData)}for(l.push(236),l.push(17),l.push(236),l.push(17);l.length<19;)l.push(0);return l.slice(0,19)}; L.prototype.mapData=function(o,r){for(var l=0;l<this.moduleCount;l++)for(var n=0;n<this.moduleCount;n++)if(null===this.modules[l][n]){var t=!((l+n)%3);this.modules[l][n]=t}}; L.prototype.createImgTag=function(o,r){o=o||2,r=r||0;var l=this.getModuleCount()*o+2*r,n=l,t='<img src="'+this.createDataURL(o,r)+'" width="'+l+'" height="'+n+'"/>';return t}; L.prototype.createDataURL=function(o,r){o=o||2,r=r||0;var l=this.getModuleCount()*o+2*r,n=l,t=o,h=r,e=h,i=Math.round(255);for(var a="GIF89a",u=String.fromCharCode,d=a+u(0)+u(0)+u(0)+u(0)+"\x00\x00\xF7\x00\x00",s=0;s<16;s++){var c=s?0:i;d+=u(c)+u(c)+u(c)}d+="\x2C\x00\x00\x00\x00"+u(0)+u(0)+"\x00\x00\x00\x00\x02";for(var f=1;f<l;f++){var g="";for(var p=0;p<n;p++){var m=this.isDark(Math.floor((p-r)/o),Math.floor((f-h)/o))?0:1;g+=m?"\x01":"\x00"}d+=u(g.length)+g}return 'data:image/gif;base64,'+btoa(d)}};
    const qr = new L(1,0); qr.addData(text); qr.make(); return qr.createImgTag(4,2);
  }
  function merch_genPayQR(){ const w=merch_w(); const a=parseInt(document.getElementById('merch_amount').value||'0',10); if(!w){ alert('wallet required'); return; } const p='PAY|wallet='+encodeURIComponent(w)+(a>0?('|amount='+a):''); document.getElementById('merch_payload').textContent=p; const el=document.getElementById('merch_qr'); el.innerHTML=makeQR(p); }
  function merch_genAliasQR(){ const h=document.getElementById('merch_alias').value.trim(); const a=parseInt(document.getElementById('merch_a_amount').value||'0',10); if(!h||!h.startsWith('@')){ alert('alias must start with @'); return; } const p='ALIAS|name='+encodeURIComponent(h)+(a>0?('|amount='+a):''); document.getElementById('merch_apayload').textContent=p; const el=document.getElementById('merch_aqr'); el.innerHTML=makeQR(p); }
  async function merch_refreshBal(){ const w=merch_w(); if(!w) return; const r=await fetch('/payments/wallets/'+encodeURIComponent(w)); document.getElementById('merch_bal').textContent=await r.text(); }
  async function merch_loadTxns(){ const w=merch_w(); if(!w) return; const r=await fetch('/payments/txns?wallet_id='+encodeURIComponent(w)+'&limit=20'); document.getElementById('merch_txns').textContent=await r.text(); }
  function merch_init(){ merch_w(); }

  // Taxi Driver logic
  function td_driver(){ const el=document.getElementById('td_driver'); let v=el.value.trim(); if(!v){ v=localStorage.getItem('td_driver')||''; el.value=v; } return v; }
  function td_save(){ const v=document.getElementById('td_driver').value.trim(); localStorage.setItem('td_driver', v); document.getElementById('td_out').textContent='saved'; }
  async function td_register(){ const body={name:document.getElementById('td_name').value.trim()||null, phone:document.getElementById('td_phone').value.trim()||null, vehicle_make:document.getElementById('td_make').value.trim()||null, vehicle_plate:document.getElementById('td_plate').value.trim()||null}; const r=await fetch('/taxi/drivers',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); const t=await r.text(); document.getElementById('td_out').textContent=t; try{ const j=JSON.parse(t); document.getElementById('td_driver').value=j.id; td_save(); }catch(_){ } }
  async function td_online(on){ const id=td_driver(); if(!id) return; const ep=on?'/taxi/drivers/'+encodeURIComponent(id)+'/online':'/taxi/drivers/'+encodeURIComponent(id)+'/offline'; const r=await fetch(ep,{method:'POST'}); document.getElementById('td_out').textContent=await r.text(); }
  async function td_setWallet(){ const id=td_driver(); const w=document.getElementById('td_wallet').value.trim(); if(!id||!w) return; const r=await fetch('/taxi/drivers/'+encodeURIComponent(id)+'/wallet',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({wallet_id:w})}); document.getElementById('td_out').textContent=await r.text(); }
  async function td_updateLoc(){ const id=td_driver(); const lat=parseFloat((document.getElementById('td_lat').value||'0')); const lon=parseFloat((document.getElementById('td_lon').value||'0')); if(!id) return; const r=await fetch('/taxi/drivers/'+encodeURIComponent(id)+'/location',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({lat:lat,lon:lon})}); document.getElementById('td_out').textContent=await r.text(); }
  let _td_tmr=null; async function td_track(){ if(_td_tmr) return; const id=td_driver(); if(!id){ alert('save driver id'); return; } if(!navigator.geolocation){ alert('no geolocation'); return; } _td_tmr=setInterval(()=>{ navigator.geolocation.getCurrentPosition(async (pos)=>{ try{ const lat=pos.coords.latitude, lon=pos.coords.longitude; document.getElementById('td_lat').value=lat.toFixed(6); document.getElementById('td_lon').value=lon.toFixed(6); const r=await fetch('/taxi/drivers/'+encodeURIComponent(id)+'/location',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({lat:lat,lon:lon})}); }catch(_){ } }, (_)=>{}, { enableHighAccuracy:true }); }, 3000); }
  function td_stopTrack(){ if(_td_tmr){ clearInterval(_td_tmr); _td_tmr=null; } }
  let _td_es=null; async function td_init(){ const id=td_driver(); if(id){ try{ _td_es = new EventSource('/taxi/driver/events?driver_id='+encodeURIComponent(id)); _td_es.onmessage = (ev)=>{ try{ const data=JSON.parse(ev.data); const el=document.getElementById('td_events'); el.textContent = (el.textContent + '\n' + JSON.stringify(data)); }catch(_){ } }; }catch(_){ } }
  }

  // Taxi Rider
  async function tr_req(){ const body={rider_phone:(document.getElementById('tr_phone').value||'').trim()||null, rider_wallet_id:(document.getElementById('tr_wallet').value||'').trim()||null, pickup_lat:parseFloat(document.getElementById('tr_plat').value||'0'), pickup_lon:parseFloat(document.getElementById('tr_plon').value||'0'), dropoff_lat:parseFloat(document.getElementById('tr_dlat').value||'0'), dropoff_lon:parseFloat(document.getElementById('tr_dlon').value||'0')}; const r=await fetch('/taxi/rides/request',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); const t=await r.text(); document.getElementById('tr_out').textContent=t; try{ const j=JSON.parse(t); document.getElementById('tr_ride').value=j.id||''; }catch(_){ } }
  async function tr_bookpay(){ const body={rider_phone:(document.getElementById('tr_phone').value||'').trim()||null, rider_wallet_id:(document.getElementById('tr_wallet').value||'').trim()||null, pickup_lat:parseFloat(document.getElementById('tr_plat').value||'0'), pickup_lon:parseFloat(document.getElementById('tr_plon').value||'0'), dropoff_lat:parseFloat(document.getElementById('tr_dlat').value||'0'), dropoff_lon:parseFloat(document.getElementById('tr_dlon').value||'0')}; const r=await fetch('/taxi/rides/book_pay',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); const t=await r.text(); document.getElementById('tr_out').textContent=t; try{ const j=JSON.parse(t); document.getElementById('tr_ride').value=j.id||''; }catch(_){ } }
  async function tr_status(){ const id=document.getElementById('tr_ride').value.trim(); if(!id){ return; } const r=await fetch('/taxi/rides/'+encodeURIComponent(id)); document.getElementById('tr_out').textContent=await r.text(); }
  async function tr_cancel(){ const id=document.getElementById('tr_ride').value.trim(); if(!id){ return; } const r=await fetch('/taxi/rides/'+encodeURIComponent(id)+'/cancel',{method:'POST'}); document.getElementById('tr_out').textContent=await r.text(); }

  // Taxi Admin
  async function ta_loadDrivers(){ const r=await fetch('/taxi/drivers?status=online&limit=100'); const arr=await r.json(); const box=document.getElementById('ta_drivers'); box.innerHTML=''; for(const d of arr){ const row=document.createElement('div'); row.className='flex items-center justify-between border-b border-gray-200 dark:border-gray-700 py-1'; row.innerHTML=`<span>${d.id} <small class=\"text-gray-500\">${d.name||''} ${d.vehicle_plate||''}</small></span>`; box.appendChild(row); } try{ await ta_renderDriversOnMap(); }catch(_){ } }
  async function ta_loadRides(){ const st=document.getElementById('ta_rstatus').value; const qs=st?('?status='+encodeURIComponent(st)) : ''; const r=await fetch('/taxi/rides'+qs); const arr=await r.json(); const box=document.getElementById('ta_rides'); box.innerHTML=''; for(const rd of arr){ const row=document.createElement('div'); row.className='flex items-center justify-between border-b border-gray-200 dark:border-gray-700 py-1'; const canCenter=(rd.pickup_lat&&rd.pickup_lon); row.innerHTML=`<span>${rd.id} <small class=\"text-gray-500\">${rd.status||''}</small> <span class=\"ml-2\">${(rd.pickup_lat||'')},${(rd.pickup_lon||'')} → ${(rd.dropoff_lat||'')},${(rd.dropoff_lon||'')}</span></span><div>${canCenter?`<button class=\"${DS.btn}\" onclick=\"ta_focus(${rd.pickup_lat},${rd.pickup_lon})\">Center</button>`:''}</div>`; box.appendChild(row); } try{ ta_renderRidesOnMap(arr); ta_updateBounds(); }catch(_){ } }
  function ta_focus(lat, lon){ try{ if(ta_gm){ ta_map.setZoom(14); ta_map.panTo({lat:parseFloat(lat),lng:parseFloat(lon)}); } else { ta_map.setView([parseFloat(lat),parseFloat(lon)],14); } }catch(_){ } }
  async function ta_assign(){ const rid=(document.getElementById('ta_ride').value||'').trim(); const did=(document.getElementById('ta_driver_id').value||'').trim(); if(!rid||!did){ alert('ride_id and driver_id required'); return; } const r=await fetch('/taxi/rides/'+encodeURIComponent(rid)+'/assign?driver_id='+encodeURIComponent(did),{method:'POST'}); document.getElementById('ta_out').textContent=await r.text(); }

  // Taxi Driver map
  let td_map=null, td_gm=false, td_marker=null;
  function td_mapSetup(){ try{ if(td_map) return; const el=document.getElementById('td_map'); if(!el) return; const lat=parseFloat(document.getElementById('td_lat').value||'33.5138')||33.5138; const lon=parseFloat(document.getElementById('td_lon').value||'36.2765')||36.2765; if(window.google && window.google.maps){ td_gm=true; td_map=new google.maps.Map(el,{center:{lat:lat,lng:lon}, zoom:13}); td_marker=new google.maps.Marker({position:{lat:lat,lng:lon}, map:td_map}); } else { td_gm=false; td_map=L.map('td_map').setView([lat,lon],13); L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19, attribution:'© OpenStreetMap'}).addTo(td_map); td_marker=L.marker([lat,lon]).addTo(td_map); } }catch(_){ } }
  function td_mapUpdate(lat, lon){ try{ if(td_gm){ td_marker.setPosition({lat:lat,lng:lon}); td_map.setCenter({lat:lat,lng:lon}); } else { td_marker.setLatLng([lat,lon]); td_map.setView([lat,lon]); } }catch(_){ } }
  const __td_updateLoc_orig = td_updateLoc;
  td_updateLoc = async function(){ await __td_updateLoc_orig(); const lat=parseFloat(document.getElementById('td_lat').value||'0'); const lon=parseFloat(document.getElementById('td_lon').value||'0'); if(lat&&lon){ td_mapUpdate(lat,lon); } };
  function td_center(){ try{ const lat=parseFloat(document.getElementById('td_lat').value||'0'); const lon=parseFloat(document.getElementById('td_lon').value||'0'); if(lat&&lon){ td_mapUpdate(lat,lon); } }catch(_){ } }
  const __td_track_orig = td_track;
  td_track = async function(){ await __td_track_orig(); };

  // Taxi Rider map
  let tr_map=null, tr_gm=false, tr_pick=null, tr_drop=null;
  function tr_mapSetup(){ try{ if(tr_map) return; const el=document.getElementById('tr_map'); if(!el) return; const plat=parseFloat(document.getElementById('tr_plat').value||'33.5138')||33.5138; const plon=parseFloat(document.getElementById('tr_plon').value||'36.2765')||36.2765; if(window.google && window.google.maps){ tr_gm=true; tr_map=new google.maps.Map(el,{center:{lat:plat,lng:plon}, zoom:12}); tr_pick=new google.maps.Marker({position:{lat:plat,lng:plon}, map:tr_map, label:'P'}); } else { tr_gm=false; tr_map=L.map('tr_map').setView([plat,plon],12); L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19, attribution:'© OpenStreetMap'}).addTo(tr_map); tr_pick=L.marker([plat,plon]).addTo(tr_map); } tr_updateFromInputs(); ['tr_plat','tr_plon','tr_dlat','tr_dlon'].forEach(id=>{ const el=document.getElementById(id); if(el){ el.addEventListener('input', tr_updateFromInputs); } }); }catch(_){ } }
  function tr_updateFromInputs(){ try{ const plat=parseFloat(document.getElementById('tr_plat').value||'0'); const plon=parseFloat(document.getElementById('tr_plon').value||'0'); const dlat=parseFloat(document.getElementById('tr_dlat').value||'0'); const dlon=parseFloat(document.getElementById('tr_dlon').value||'0'); if(plat&&plon){ if(tr_gm){ tr_pick.setPosition({lat:plat,lng:plon}); tr_map.setCenter({lat:plat,lng:plon}); } else { tr_pick.setLatLng([plat,plon]); tr_map.setView([plat,plon]); } } if(dlat&&dlon){ if(!tr_drop){ if(tr_gm){ tr_drop=new google.maps.Marker({position:{lat:dlat,lng:dlon}, map:tr_map, label:'D'}); } else { tr_drop=L.marker([dlat,dlon]).addTo(tr_map); } } else { if(tr_gm){ tr_drop.setPosition({lat:dlat,lng:dlon}); } else { tr_drop.setLatLng([dlat,dlon]); } } } }catch(_){ } }

  // Taxi Admin map helpers
  let ta_map=null, ta_gm=false, ta_drvMarkers=[], ta_rideMarkers=[], ta_drvLayer=null, ta_rideLayer=null;
  function ta_updateBounds(){ try{ const pts=[]; if(ta_gm){ for(const m of ta_drvMarkers){ try{ const p=m.getPosition(); if(p) pts.push({lat:p.lat(), lng:p.lng()}); }catch(_){ } } for(const m of ta_rideMarkers){ try{ const p=m.getPosition(); if(p) pts.push({lat:p.lat(), lng:p.lng()}); }catch(_){ } } if(pts.length>0){ const b=new google.maps.LatLngBounds(); for(const p of pts){ b.extend(p); } ta_map.fitBounds(b); } } else { try{ const d=[], r=[]; if(ta_drvLayer){ ta_drvLayer.eachLayer(l=>{ try{ d.push(l.getLatLng()); }catch(_){ } }); } if(ta_rideLayer){ ta_rideLayer.eachLayer(l=>{ try{ r.push(l.getLatLng()); }catch(_){ } }); } const all=d.concat(r); if(all.length>0){ ta_map.fitBounds(L.latLngBounds(all), {padding:[20,20]}); } }catch(_){ } } }catch(_){ } }
  function ta_mapSetup(){ try{ if(ta_map) return; const el=document.getElementById('ta_map'); if(!el) return; const lat=33.5138, lon=36.2765; if(window.google && window.google.maps){ ta_gm=true; ta_map=new google.maps.Map(el,{center:{lat:lat,lng:lon}, zoom:11, mapTypeControl:false}); try{ const saved=JSON.parse(localStorage.getItem('app_taxi_admin_map')||'null'); if(saved&&saved.lat&&saved.lng&&saved.zoom){ ta_map.setCenter({lat:saved.lat,lng:saved.lng}); ta_map.setZoom(saved.zoom); } }catch(_){ } ta_map.addListener('idle', ta_saveView); } else { ta_gm=false; ta_map=L.map('ta_map').setView([lat,lon],11); L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{maxZoom:19, attribution:'© OpenStreetMap'}).addTo(ta_map); try{ const saved=JSON.parse(localStorage.getItem('app_taxi_admin_map')||'null'); if(saved&&saved.lat&&saved.lng&&saved.zoom){ ta_map.setView([saved.lat,saved.lng], saved.zoom); } }catch(_){ } if(L.markerClusterGroup){ ta_drvLayer=L.markerClusterGroup(); ta_rideLayer=L.markerClusterGroup(); ta_map.addLayer(ta_drvLayer); ta_map.addLayer(ta_rideLayer); } else { ta_drvLayer=L.layerGroup().addTo(ta_map); ta_rideLayer=L.layerGroup().addTo(ta_map); } try{ ta_map.on('moveend', ta_saveView); }catch(_){ } } }catch(_){ }
  }
  function ta_fitDrivers(){ try{ if(ta_gm){ const b=new google.maps.LatLngBounds(); for(const m of ta_drvMarkers){ try{ const p=m.getPosition(); if(p) b.extend(p); }catch(_){ } } if(!b.isEmpty()) ta_map.fitBounds(b); } else { const pts=[]; if(ta_drvLayer&&ta_drvLayer.eachLayer){ ta_drvLayer.eachLayer(l=>{ try{ pts.push(l.getLatLng()); }catch(_){ } }); } if(pts.length){ ta_map.fitBounds(L.latLngBounds(pts), {padding:[30,30]}); } } }catch(_){ } }
  function ta_fitRides(){ try{ if(ta_gm){ const b=new google.maps.LatLngBounds(); for(const m of ta_rideMarkers){ try{ const p=m.getPosition(); if(p) b.extend(p); }catch(_){ } } if(!b.isEmpty()) ta_map.fitBounds(b); } else { const pts=[]; if(ta_rideLayer&&ta_rideLayer.eachLayer){ ta_rideLayer.eachLayer(l=>{ try{ pts.push(l.getLatLng()); }catch(_){ } }); } if(pts.length){ ta_map.fitBounds(L.latLngBounds(pts), {padding:[30,30]}); } } }catch(_){ } }
  // persist map view across visits
  function ta_saveView(){ try{ if(ta_gm){ const c=ta_map.getCenter(); localStorage.setItem('app_taxi_admin_map', JSON.stringify({lat:c.lat(),lng:c.lng(),zoom:ta_map.getZoom()})); } else { const c=ta_map.getCenter(); localStorage.setItem('app_taxi_admin_map', JSON.stringify({lat:c.lat,lng:c.lng,zoom:ta_map.getZoom()})); } }catch(_){ } }
  async function ta_renderDriversOnMap(){ try{ const r=await fetch('/taxi/drivers?status=online&limit=100'); const arr=await r.json(); if(ta_gm){ for(const m of ta_drvMarkers){ try{ m.setMap(null);}catch(_){}} ta_drvMarkers=[]; for(const d of arr){ if(d.lat && d.lon){ ta_drvMarkers.push(new google.maps.Marker({position:{lat:parseFloat(d.lat), lng:parseFloat(d.lon)}, map:ta_map, title:d.name||('Driver '+d.id)})); } } try{ if(window.markerClusterer && ta_drvMarkers.length){ if(window._ta_gClusterD){ try{ window._ta_gClusterD.clearMarkers(); }catch(_){ } } window._ta_gClusterD = new markerClusterer.MarkerClusterer({map: ta_map, markers: ta_drvMarkers}); } }catch(_){ } } else { try{ if(ta_drvLayer && ta_drvLayer.clearLayers) ta_drvLayer.clearLayers(); }catch(_){ } for(const d of arr){ if(d.lat && d.lon){ if(ta_drvLayer && ta_drvLayer.addLayer){ L.marker([d.lat, d.lon]).addTo(ta_drvLayer); } else { L.marker([d.lat, d.lon]).addTo(ta_map); } } } } }catch(_){ }
  }
  function ta_renderRidesOnMap(arr){ try{ if(ta_gm){ for(const m of ta_rideMarkers){ try{ m.setMap(null);}catch(_){}} ta_rideMarkers=[]; for(const rd of arr){ if(rd.pickup_lat && rd.pickup_lon){ ta_rideMarkers.push(new google.maps.Marker({position:{lat:parseFloat(rd.pickup_lat), lng:parseFloat(rd.pickup_lon)}, map:ta_map, icon:{path:google.maps.SymbolPath.CIRCLE, fillColor:'#06f', fillOpacity:0.9, strokeColor:'#06f', strokeWeight:1, scale:6}, title:'Pickup '+rd.id})); } } try{ if(window.markerClusterer && ta_rideMarkers.length){ if(window._ta_gClusterR){ try{ window._ta_gClusterR.clearMarkers(); }catch(_){ } } window._ta_gClusterR = new markerClusterer.MarkerClusterer({map: ta_map, markers: ta_rideMarkers}); } }catch(_){ } } else { try{ if(ta_rideLayer && ta_rideLayer.clearLayers) ta_rideLayer.clearLayers(); }catch(_){ } for(const rd of arr){ if(rd.pickup_lat && rd.pickup_lon){ if(ta_rideLayer && ta_rideLayer.addLayer){ L.circleMarker([rd.pickup_lat, rd.pickup_lon], {radius:5,color:'#06f'}).addTo(ta_rideLayer); } else { L.circleMarker([rd.pickup_lat, rd.pickup_lon], {radius:5,color:'#06f'}).addTo(ta_map); } } } } }catch(_){ }
  }
  // periodic refresh while panel visible
  setInterval(()=>{ try{ const vis = document.getElementById('panel-taxi-admin') && !document.getElementById('panel-taxi-admin').classList.contains('hidden'); if(vis){ ta_renderDriversOnMap(); } }catch(_){ } }, 5000);
  </script>
</body></html>
"""
    return HTMLResponse(content=html.replace('%%GMAPS_TAG%%', gmaps_tag))


@app.get("/upstreams/health")
def upstreams_health():
    out: dict[str, Any] = {}
    # Food is internal-only in monolith mode; there is no BASE_URL fallback.
    if _use_food_internal() and _FOOD_INTERNAL_AVAILABLE:
        out["food"] = {
            "status_code": 200,
            "body": {"status": "OK (internal)", "internal": True},
            "mode": "internal",
        }
    else:
        out["food"] = {"error": "food internal not available", "mode": "internal", "internal": False}
    for name, base in {
        "payments": PAYMENTS_BASE,
        "taxi": TAXI_BASE,
        "bus": BUS_BASE,
        "carmarket": CARMARKET_BASE,
        "carrental": CARRENTAL_BASE,
        "realestate": REALESTATE_BASE,
        "stays": STAYS_BASE,
        "freight": FREIGHT_BASE,
        "chat": CHAT_BASE,
        "agriculture": AGRICULTURE_BASE,
        "commerce": COMMERCE_BASE,
        "doctors": DOCTORS_BASE,
        "flights": FLIGHTS_BASE,
        "jobs": JOBS_BASE,
        "livestock": LIVESTOCK_BASE,
    }.items():
        if not base:
            if _ENV_LOWER == "test":
                out[name] = {"error": "BASE_URL not set", "mode": "test", "internal": False}
                continue
            internal_ok = False
            mode = "internal"
            try:
                if name == "payments":
                    internal_ok = _use_pay_internal()
                elif name == "taxi":
                    internal_ok = _use_taxi_internal()
                elif name == "bus":
                    internal_ok = _use_bus_internal()
                elif name == "carmarket":
                    internal_ok = _use_carmarket_internal()
                elif name == "carrental":
                    internal_ok = _use_carrental_internal()
                elif name == "stays":
                    internal_ok = _use_stays_internal()
                elif name == "freight":
                    internal_ok = _use_freight_internal()
                elif name == "chat":
                    internal_ok = _use_chat_internal()
                elif name == "commerce":
                    internal_ok = _use_commerce_internal()
                elif name == "doctors":
                    internal_ok = _use_doctors_internal()
                elif name == "flights":
                    internal_ok = _use_flights_internal()
                elif name == "jobs":
                    internal_ok = _use_jobs_internal()
                elif name == "agriculture":
                    internal_ok = _use_agriculture_internal()
                elif name == "livestock":
                    internal_ok = _use_livestock_internal()
            except Exception:
                internal_ok = False

            # In monolith mode, several services are mounted directly even
            # wenn keine eigene BASE_URL konfiguriert ist.
            if name in ("taxi", "realestate", "carmarket", "carrental") and not internal_ok:
                internal_ok = True
                mode = "monolith"
            # If we have a working internal/monolith integration, report this as OK
            # instead of an error so System Status doesn't show everything in red.
            if internal_ok:
                out[name] = {
                    "status_code": 200,
                    "body": {
                        "status": f"OK ({mode})",
                        "internal": True,
                    },
                    "mode": mode,
                }
            else:
                # No BASE_URL and no internal wiring: this upstream is effectively missing.
                detail = "BASE_URL not set"
                out[name] = {"error": detail, "mode": mode, "internal": False}
            continue
        url = base.rstrip("/") + "/health"
        try:
            r = httpx.get(url, timeout=5.0)
            out[name] = {"status_code": r.status_code, "body": r.json() if r.headers.get("content-type", "").startswith("application/json") else r.text}
        except Exception as e:
            out[name] = {"error": str(e)}
    return out


@app.get("/admin/overview", response_class=HTMLResponse)
def admin_overview_page():
    # Legacy Admin HTML overview removed – please use Shamell instead.
    return _legacy_console_removed_page("Shamell · Admin overview")
    html = """
<!doctype html>
<html><head><meta name=viewport content="width=device-width, initial-scale=1" />
<title>Shamell Admin Overview</title>
<link rel="icon" href="/icons/payments.svg" />
<style>
  body{font-family:sans-serif;margin:20px;max-width:960px;color:#0f172a;}
  h1{margin-bottom:4px;}
  table{border-collapse:collapse;width:100%;margin-top:12px;}
  th,td{padding:6px 8px;border-bottom:1px solid #e5e7eb;font-size:13px;text-align:left;}
  th{background:#f9fafb;font-weight:600;}
  .ok{color:#16a34a;font-weight:600;}
  .err{color:#b91c1c;font-weight:600;}
  .tag{display:inline-block;padding:2px 6px;border-radius:999px;font-size:11px;background:#e5e7eb;margin-right:4px;}
  .links a{margin-right:8px;font-size:13px;}
  code{font-size:12px;background:#f3f4f6;padding:2px 4px;border-radius:4px;}
  .muted{color:#6b7280;font-size:12px;}
.pill{display:inline-block;padding:2px 8px;border-radius:999px;font-size:11px;background:#e0f2fe;color:#0369a1;}
</style>
</head><body>
<h1>Shamell Admin Overview</h1>
<div class="muted">Monolith + upstream health, Links zu Admin-UIs.</div>

<div style="margin-top:14px" class="links">
  <span class="pill">Admin-UIs</span>
  <a href="/taxi/admin">Taxi Admin</a>
  <a href="/payments-debug">Payments Debug</a>
  <a href="/merchant">Merchant POS</a>
  <a href="/ops-admin/">Ops Admin (Flutter)</a>
  <a href="/admin/metrics">Metrics</a>
  <a href="/admin/guardrails">Guardrails</a>
  <a href="/admin/quality">Quality</a>
</div>

<div style="margin-top:14px" class="muted">
  Backend-Heartbeat: <code id="bg_tick">n/a</code>
</div>

<table id="tbl">
  <thead><tr><th>Service</th><th>Status</th><th>Details</th></tr></thead>
  <tbody id="tbody"><tr><td colspan="3" class="muted">Lade /upstreams/health ...</td></tr></tbody>
</table>

<script>
async function loadHealth(){
  try{
    const r = await fetch('/upstreams/health');
    const j = await r.json();
    const tbody = document.getElementById('tbody');
    tbody.innerHTML='';
    const names = Object.keys(j).sort();
    if(names.length===0){ tbody.innerHTML='<tr><td colspan=3 class="muted">Keine Upstreams konfiguriert</td></tr>'; return; }
    for(const name of names){
      const row = document.createElement('tr');
      const cellName = document.createElement('td');
      cellName.textContent = name;
      const cellStatus = document.createElement('td');
      const cellDetail = document.createElement('td');
      const val = j[name] || {};
      let ok=false, txt='n/a';
      if('status_code' in val){ ok = (val.status_code>=200 && val.status_code<300); txt = 'HTTP '+val.status_code; }
      else if('error' in val){ ok=false; txt = val.error; }
      const span=document.createElement('span');
      span.textContent = ok? 'OK' : 'ERROR';
      span.className = ok? 'ok' : 'err';
      cellStatus.appendChild(span);
      cellDetail.textContent = txt;
      row.appendChild(cellName);
      row.appendChild(cellStatus);
      row.appendChild(cellDetail);
      tbody.appendChild(row);
    }
  }catch(e){
    const tbody = document.getElementById('tbody');
    tbody.innerHTML='<tr><td colspan=3 class="err">Error while loading: '+e+'</td></tr>';
  }
}
function renderBgTick(){
  fetch('/metrics?limit=1').then(r=>r.json()).then(j=>{
    // BG tick is maintained server-side in _BG_STATS; here we only show time when present.
    // We use /metrics only as a "ping" proxy; the items themselves are optional.
  }).catch(()=>{});
  try{
    const el=document.getElementById('bg_tick');
    el.textContent = (window.__bg_tick || 'active (see server logs)');
  }catch(_){}
}
loadHealth();
renderBgTick();
setInterval(loadHealth, 30000);
</script>
</body></html>
"""
    return HTMLResponse(content=html)


@app.get("/wallets/{wallet_id}")
def get_wallet(wallet_id: str, request: Request):
    # Wallet lookups contain sensitive financial data. Require auth and enforce
    # wallet ownership (or admin) to prevent IDOR.
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    wallet_id = (wallet_id or "").strip()
    caller_wallet_id = _resolve_wallet_id_for_phone(phone)
    if caller_wallet_id:
        if wallet_id != caller_wallet_id and not _is_admin(phone):
            raise HTTPException(status_code=403, detail="wallet does not belong to caller")
    else:
        # If we cannot resolve the caller wallet we still allow admins to proceed.
        if not _is_admin(phone):
            raise HTTPException(status_code=403, detail="wallet not found for caller")
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            try:
                with _pay_internal_session() as s:
                    return _pay_get_wallet(wallet_id=wallet_id, s=s)
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(status_code=502, detail=str(e))
        if not PAYMENTS_BASE:
            raise HTTPException(status_code=500, detail="PAYMENTS_BASE_URL not configured")
        url = PAYMENTS_BASE.rstrip("/") + f"/wallets/{wallet_id}"
        r = httpx.get(url, headers=_payments_headers(), timeout=5.0)
        return r.json() if r.headers.get("content-type", "").startswith("application/json") else {"raw": r.text, "status_code": r.status_code}
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/wallets/{wallet_id}/snapshot")
def wallet_snapshot(
    wallet_id: str,
    request: Request,
    limit: int = 25,
    dir: str = "",
    kind: str = "",
    from_iso: str = "",
    to_iso: str = "",
    response: Response = None,  # type: ignore[assignment]
):
    """
    Aggregate for wallet overviews:
      - wallet object (get_wallet)
      - list of recent payments (payments_txns)
    """
    # Load wallet (surface errors in the snapshot best-effort)
    wallet: Any = None
    wallet_error: str | None = None
    wallet_status: int | None = None
    try:
        wallet = get_wallet(wallet_id, request=request)
    except HTTPException as e:
        wallet_error = str(e.detail)
        wallet_status = e.status_code
    except Exception as e:
        wallet_error = str(e)

    # Fetch transactions (errors should be clearly signalled)
    txns: Any = []
    try:
        txns = payments_txns(
            wallet_id=wallet_id,
            limit=limit,
            dir=dir,
            kind=kind,
            from_iso=from_iso,
            to_iso=to_iso,
            request=request,
        )
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))

    out: dict[str, Any] = {"wallet_id": wallet_id, "wallet": wallet, "txns": txns}
    if wallet_error:
        out["wallet_error"] = wallet_error
        if wallet_status is not None:
            out["wallet_status"] = wallet_status
    # Wallet snapshots contain sensitive financial data; mark them explicitly
    # as non-cacheable so intermediaries and browsers do not reuse responses.
    try:
        if response is not None:
            response.headers.setdefault("Cache-Control", "no-store")
    except Exception:
        pass
    return out

from datetime import datetime, timezone, timedelta


@app.get("/payments/txns")
def payments_txns(
    wallet_id: str,
    request: Request,
    limit: int = 20,
    dir: str = "",
    kind: str = "",
    from_iso: str = "",
    to_iso: str = "",
):
    # Transaction lists are sensitive; require auth and enforce wallet ownership (or admin).
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    wallet_id = (wallet_id or "").strip()
    caller_wallet_id = _resolve_wallet_id_for_phone(phone)
    if caller_wallet_id:
        if wallet_id != caller_wallet_id and not _is_admin(phone):
            raise HTTPException(status_code=403, detail="wallet does not belong to caller")
    else:
        # If we cannot resolve the caller wallet we still allow admins to proceed.
        if not _is_admin(phone):
            raise HTTPException(status_code=403, detail="wallet not found for caller")
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            try:
                with _pay_internal_session() as s:
                    # Internal list, then apply filtering as before
                    arr = _pay_list_txns(wallet_id=wallet_id, limit=max(1, min(limit * 5, 500)), s=s)  # type: ignore[name-defined]
                    # list_txns already filters by wallet_id; we keep the additional filtering for compatible behaviour
                    arr = [t.model_dump() if hasattr(t, "model_dump") else (t.dict() if hasattr(t, "dict") else t) for t in arr]  # type: ignore[union-attr]
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(status_code=502, detail=str(e))
        else:
            if not PAYMENTS_BASE:
                raise HTTPException(status_code=500, detail="PAYMENTS_BASE_URL not configured")
            url = PAYMENTS_BASE.rstrip("/") + f"/txns?wallet_id={wallet_id}&limit={max(1,min(limit*5,500))}"
            r = httpx.get(url, headers=_payments_headers(), timeout=10.0)
            arr = r.json() if r.headers.get("content-type", "").startswith("application/json") else []
        # server-side filtering (best-effort)
        def in_range(ts: str) -> bool:
            try:
                dt = datetime.fromisoformat(ts.replace('Z','+00:00'))
            except Exception:
                return True
            if from_iso:
                try:
                    f = datetime.fromisoformat(from_iso.replace('Z','+00:00'))
                    if dt < f: return False
                except Exception:
                    pass
            if to_iso:
                try:
                    t = datetime.fromisoformat(to_iso.replace('Z','+00:00'))
                    if dt > t: return False
                except Exception:
                    pass
            return True
        out = []
        dir = (dir or '').lower()
        kind = (kind or '').lower()
        for it in arr:
            try:
                row = it
                if not isinstance(row, dict):
                    # Pydantic/BaseModel -> dict
                    try:
                        row = it.model_dump()  # type: ignore[attr-defined]
                    except Exception:
                        try:
                            row = it.dict()  # type: ignore[attr-defined]
                        except Exception:
                            row = {}
                if dir == 'out' and (row.get('from_wallet_id','') != wallet_id):
                    continue
                if dir == 'in' and (row.get('to_wallet_id','') != wallet_id):
                    continue
                if kind and kind not in str(row.get('kind','')).lower():
                    continue
                if not in_range(str(row.get('created_at',''))):
                    continue
                out.append(row)
            except Exception:
                out.append(it)
        return out[:max(1,min(limit,200))]
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


# ---- Chat proxies ----
def _chat_url(path: str) -> str:
    if not CHAT_BASE:
        raise HTTPException(status_code=500, detail="CHAT_BASE_URL not configured")
    return CHAT_BASE.rstrip("/") + path


# --- Chat internal service (monolith mode) ---
_CHAT_INTERNAL_AVAILABLE = False
try:
    from sqlalchemy.orm import Session as _ChatSession  # type: ignore[import]
    from apps.chat.app import main as _chat_main  # type: ignore[import]
    from apps.chat.app.main import (  # type: ignore[import]
        engine as _chat_engine,
        get_session as _chat_get_session,
        RegisterReq as _ChatRegisterReq,
        DeviceOut as _ChatDeviceOut,
        SendReq as _ChatSendReq,
        MsgOut as _ChatMsgOut,
        ReadReq as _ChatReadReq,
        PushTokenReq as _ChatPushTokenReq,
        ContactRuleReq as _ChatRuleReq,
        ContactPrefsReq as _ChatContactPrefsReq,
        GroupCreateReq as _ChatGroupCreateReq,
        GroupOut as _ChatGroupOut,
        GroupSendReq as _ChatGroupSendReq,
        GroupMsgOut as _ChatGroupMsgOut,
        GroupInviteReq as _ChatGroupInviteReq,
        GroupLeaveReq as _ChatGroupLeaveReq,
        GroupRoleReq as _ChatGroupRoleReq,
        GroupUpdateReq as _ChatGroupUpdateReq,
        GroupMemberOut as _ChatGroupMemberOut,
        GroupPrefsReq as _ChatGroupPrefsReq,
        GroupPrefsOut as _ChatGroupPrefsOut,
        GroupKeyRotateReq as _ChatGroupKeyRotateReq,
        GroupKeyEventOut as _ChatGroupKeyEventOut,
        register as _chat_register,
        get_device as _chat_get_device,
        send_message as _chat_send_message,
        inbox as _chat_inbox,
        mark_read as _chat_mark_read,
        register_push_token as _chat_register_push,
        set_block as _chat_set_block,
        set_prefs as _chat_set_prefs,
        list_prefs as _chat_list_prefs,
        create_group as _chat_create_group,
        list_groups as _chat_list_groups,
        send_group_message as _chat_send_group_message,
        group_inbox as _chat_group_inbox,
        group_members as _chat_group_members,
        invite_members as _chat_invite_members,
        leave_group as _chat_leave_group,
        set_group_role as _chat_set_group_role,
        update_group as _chat_update_group,
        set_group_prefs as _chat_set_group_prefs,
        list_group_prefs as _chat_list_group_prefs,
        rotate_group_key as _chat_rotate_group_key,
        list_key_events as _chat_list_key_events,
    )
    _CHAT_INTERNAL_AVAILABLE = True
    try:
        _chat_main._startup()  # type: ignore[attr-defined]
    except Exception:
        pass
except Exception:
    _ChatSession = None  # type: ignore[assignment]
    _chat_engine = None  # type: ignore[assignment]
    _CHAT_INTERNAL_AVAILABLE = False


def _use_chat_internal() -> bool:
    if _force_internal(_CHAT_INTERNAL_AVAILABLE):
        return True
    mode = os.getenv("CHAT_INTERNAL_MODE", "auto").lower()
    if mode == "off":
        return False
    if not _CHAT_INTERNAL_AVAILABLE:
        return False
    if mode == "on":
        return True
    return not bool(CHAT_BASE)


def _chat_internal_session():
    if not _CHAT_INTERNAL_AVAILABLE or _ChatSession is None or _chat_engine is None:  # type: ignore[truthy-function]
        raise RuntimeError("Chat internal service not available")
    return _ChatSession(_chat_engine)  # type: ignore[call-arg]


def _chat_auth_headers_from_request(request: Request) -> Dict[str, str]:
    did = (
        request.headers.get("X-Chat-Device-Id")
        or request.headers.get("x-chat-device-id")
        or ""
    ).strip()
    tok = (
        request.headers.get("X-Chat-Device-Token")
        or request.headers.get("x-chat-device-token")
        or ""
    ).strip()
    headers: Dict[str, str] = {}
    if did:
        headers["X-Chat-Device-Id"] = did
    if tok:
        headers["X-Chat-Device-Token"] = tok
    return headers


def _chat_auth_headers_from_ws(ws: WebSocket) -> Dict[str, str]:
    did = (
        ws.headers.get("X-Chat-Device-Id")
        or ws.headers.get("x-chat-device-id")
        or ws.query_params.get("chat_device_id")
        or ws.query_params.get("device_id")
        or ""
    ).strip()
    tok = (
        ws.headers.get("X-Chat-Device-Token")
        or ws.headers.get("x-chat-device-token")
        or ws.query_params.get("chat_device_token")
        or ""
    ).strip()
    headers: Dict[str, str] = {}
    if did:
        headers["X-Chat-Device-Id"] = did
    if tok:
        headers["X-Chat-Device-Token"] = tok
    return headers


@app.post("/chat/devices/register")
async def chat_register(req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_chat_internal():
            if not _CHAT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="chat internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                creq = _ChatRegisterReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _chat_internal_session() as s:
                return _chat_register(request=req, req=creq, s=s)
        r = httpx.post(
            _chat_url("/devices/register"),
            json=body,
            headers=_chat_auth_headers_from_request(req),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/chat/devices/{device_id}")
def chat_get_device(device_id: str):
    try:
        if _use_chat_internal():
            if not _CHAT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="chat internal not available")
            with _chat_internal_session() as s:
                return _chat_get_device(device_id=device_id, s=s)
        r = httpx.get(_chat_url(f"/devices/{device_id}"), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/chat/devices/{device_id}/push_token")
async def chat_push_token(device_id: str, req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_chat_internal():
            if not _CHAT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="chat internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                preq = _ChatPushTokenReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _chat_internal_session() as s:
                return _chat_register_push(device_id=device_id, request=req, req=preq, s=s)  # type: ignore[arg-type]
        r = httpx.post(
            _chat_url(f"/devices/{device_id}/push_token"),
            json=body,
            headers=_chat_auth_headers_from_request(req),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/chat/devices/{device_id}/block")
async def chat_block(device_id: str, req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_chat_internal():
            if not _CHAT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="chat internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                breq = _ChatRuleReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _chat_internal_session() as s:
                return _chat_set_block(device_id=device_id, request=req, req=breq, s=s)  # type: ignore[arg-type]
        r = httpx.post(
            _chat_url(f"/devices/{device_id}/block"),
            json=body,
            headers=_chat_auth_headers_from_request(req),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/chat/devices/{device_id}/prefs")
async def chat_prefs(device_id: str, req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_chat_internal():
            if not _CHAT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="chat internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                preq = _ChatContactPrefsReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _chat_internal_session() as s:
                return _chat_set_prefs(device_id=device_id, request=req, req=preq, s=s)  # type: ignore[arg-type]
        r = httpx.post(
            _chat_url(f"/devices/{device_id}/prefs"),
            json=body,
            headers=_chat_auth_headers_from_request(req),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/chat/devices/{device_id}/prefs")
def chat_list_prefs(device_id: str, request: Request):
    try:
        if _use_chat_internal():
            if not _CHAT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="chat internal not available")
            with _chat_internal_session() as s:
                return _chat_list_prefs(device_id=device_id, request=request, s=s)  # type: ignore[arg-type]
        r = httpx.get(
            _chat_url(f"/devices/{device_id}/prefs"),
            headers=_chat_auth_headers_from_request(request),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/chat/devices/{device_id}/group_prefs")
async def chat_group_prefs(device_id: str, req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_chat_internal():
            if not _CHAT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="chat internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                preq = _ChatGroupPrefsReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _chat_internal_session() as s:
                return _chat_set_group_prefs(device_id=device_id, request=req, req=preq, s=s)  # type: ignore[arg-type]
        r = httpx.post(
            _chat_url(f"/devices/{device_id}/group_prefs"),
            json=body,
            headers=_chat_auth_headers_from_request(req),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/chat/devices/{device_id}/group_prefs")
def chat_list_group_prefs(device_id: str, request: Request):
    try:
        if _use_chat_internal():
            if not _CHAT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="chat internal not available")
            with _chat_internal_session() as s:
                return _chat_list_group_prefs(device_id=device_id, request=request, s=s)  # type: ignore[arg-type]
        r = httpx.get(
            _chat_url(f"/devices/{device_id}/group_prefs"),
            headers=_chat_auth_headers_from_request(request),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/chat/messages/send")
async def chat_send(req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_chat_internal():
            if not _CHAT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="chat internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                sreq = _ChatSendReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _chat_internal_session() as s:
                msg = _chat_send_message(request=req, req=sreq, s=s)
            try:
                _update_official_service_session_on_message(
                    getattr(msg, "sender_id", None),
                    getattr(msg, "recipient_id", None),
                    getattr(msg, "created_at", None),
                )
            except Exception:
                pass
            try:
                emit_event(
                    "chat",
                    "message_sent",
                    {
                        "id": getattr(msg, "id", None),
                        "sender_id": getattr(msg, "sender_id", None),
                        "recipient_id": getattr(msg, "recipient_id", None),
                        "created_at": getattr(msg, "created_at", None),
                    },
                )
            except Exception:
                pass
            return msg
        r = httpx.post(
            _chat_url("/messages/send"),
            json=body,
            headers=_chat_auth_headers_from_request(req),
            timeout=10,
        )
        out = r.json()
        try:
            _update_official_service_session_on_message(
                out.get("sender_id"),
                out.get("recipient_id"),
                out.get("created_at"),
            )
        except Exception:
            pass
        try:
            payload = {
                "id": out.get("id"),
                "sender_id": out.get("sender_id"),
                "recipient_id": out.get("recipient_id"),
                "created_at": out.get("created_at"),
            }
            emit_event("chat", "message_sent", payload)
        except Exception:
            pass
        return out
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/chat/messages/inbox")
def chat_inbox(device_id: str, request: Request, since_iso: str = "", limit: int = 50):
    params = {"device_id": device_id, "limit": max(1, min(limit, 200))}
    if since_iso:
        params["since_iso"] = since_iso
    try:
        if _use_chat_internal():
            if not _CHAT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="chat internal not available")
            with _chat_internal_session() as s:
                sin = since_iso or None
                return _chat_inbox(request=request, device_id=device_id, since_iso=sin, limit=limit, s=s)
        r = httpx.get(
            _chat_url("/messages/inbox"),
            params=params,
            headers=_chat_auth_headers_from_request(request),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/chat/messages/{mid}/read")
async def chat_mark_read(mid: str, req: Request):
    try:
        body = await req.json()
    except Exception:
        body = {"read": True}
    try:
        if _use_chat_internal():
            if not _CHAT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="chat internal not available")
            data = body or {"read": True}
            if not isinstance(data, dict):
                data = {"read": True}
            try:
                rreq = _ChatReadReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _chat_internal_session() as s:
                return _chat_mark_read(mid=mid, request=req, req=rreq, s=s)
        r = httpx.post(
            _chat_url(f"/messages/{mid}/read"),
            json=body,
            headers=_chat_auth_headers_from_request(req),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/chat/groups/create")
async def chat_group_create(req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_chat_internal():
            if not _CHAT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="chat internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                greq = _ChatGroupCreateReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _chat_internal_session() as s:
                return _chat_create_group(request=req, req=greq, s=s)  # type: ignore[arg-type]
        r = httpx.post(
            _chat_url("/groups/create"),
            json=body,
            headers=_chat_auth_headers_from_request(req),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/chat/groups/list")
def chat_group_list(device_id: str, request: Request):
    try:
        if _use_chat_internal():
            if not _CHAT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="chat internal not available")
            with _chat_internal_session() as s:
                return _chat_list_groups(request=request, device_id=device_id, s=s)
        r = httpx.get(
            _chat_url("/groups/list"),
            params={"device_id": device_id},
            headers=_chat_auth_headers_from_request(request),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/chat/groups/{group_id}/update")
async def chat_group_update(group_id: str, req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_chat_internal():
            if not _CHAT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="chat internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                ureq = _ChatGroupUpdateReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _chat_internal_session() as s:
                return _chat_update_group(group_id=group_id, request=req, req=ureq, s=s)  # type: ignore[arg-type]
        r = httpx.post(
            _chat_url(f"/groups/{group_id}/update"),
            json=body,
            headers=_chat_auth_headers_from_request(req),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/chat/groups/{group_id}/messages/send")
async def chat_group_send(group_id: str, req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_chat_internal():
            if not _CHAT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="chat internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                sreq = _ChatGroupSendReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _chat_internal_session() as s:
                return _chat_send_group_message(group_id=group_id, request=req, req=sreq, s=s)  # type: ignore[arg-type]
        r = httpx.post(
            _chat_url(f"/groups/{group_id}/messages/send"),
            json=body,
            headers=_chat_auth_headers_from_request(req),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/chat/groups/{group_id}/messages/inbox")
def chat_group_inbox(group_id: str, device_id: str, request: Request, since_iso: str = "", limit: int = 50):
    params = {"device_id": device_id, "limit": max(1, min(limit, 200))}
    if since_iso:
        params["since_iso"] = since_iso
    try:
        if _use_chat_internal():
            if not _CHAT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="chat internal not available")
            with _chat_internal_session() as s:
                sin = since_iso or None
                return _chat_group_inbox(group_id=group_id, request=request, device_id=device_id, since_iso=sin, limit=limit, s=s)  # type: ignore[arg-type]
        r = httpx.get(
            _chat_url(f"/groups/{group_id}/messages/inbox"),
            params=params,
            headers=_chat_auth_headers_from_request(request),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/chat/groups/{group_id}/members")
def chat_group_members(group_id: str, device_id: str, request: Request):
    params = {"device_id": device_id}
    try:
        if _use_chat_internal():
            if not _CHAT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="chat internal not available")
            with _chat_internal_session() as s:
                return _chat_group_members(group_id=group_id, request=request, device_id=device_id, s=s)
        r = httpx.get(
            _chat_url(f"/groups/{group_id}/members"),
            params=params,
            headers=_chat_auth_headers_from_request(request),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/chat/groups/{group_id}/invite")
async def chat_group_invite(group_id: str, req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_chat_internal():
            if not _CHAT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="chat internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                ireq = _ChatGroupInviteReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _chat_internal_session() as s:
                return _chat_invite_members(group_id=group_id, request=req, req=ireq, s=s)  # type: ignore[arg-type]
        r = httpx.post(
            _chat_url(f"/groups/{group_id}/invite"),
            json=body,
            headers=_chat_auth_headers_from_request(req),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/chat/groups/{group_id}/leave")
async def chat_group_leave(group_id: str, req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_chat_internal():
            if not _CHAT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="chat internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                lreq = _ChatGroupLeaveReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _chat_internal_session() as s:
                return _chat_leave_group(group_id=group_id, request=req, req=lreq, s=s)  # type: ignore[arg-type]
        r = httpx.post(
            _chat_url(f"/groups/{group_id}/leave"),
            json=body,
            headers=_chat_auth_headers_from_request(req),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/chat/groups/{group_id}/set_role")
async def chat_group_set_role(group_id: str, req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_chat_internal():
            if not _CHAT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="chat internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                rreq = _ChatGroupRoleReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _chat_internal_session() as s:
                return _chat_set_group_role(group_id=group_id, request=req, req=rreq, s=s)  # type: ignore[arg-type]
        r = httpx.post(
            _chat_url(f"/groups/{group_id}/set_role"),
            json=body,
            headers=_chat_auth_headers_from_request(req),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/chat/groups/{group_id}/keys/rotate")
async def chat_group_rotate_key(group_id: str, req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_chat_internal():
            if not _CHAT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="chat internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                rreq = _ChatGroupKeyRotateReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _chat_internal_session() as s:
                return _chat_rotate_group_key(group_id=group_id, request=req, req=rreq, s=s)  # type: ignore[arg-type]
        r = httpx.post(
            _chat_url(f"/groups/{group_id}/keys/rotate"),
            json=body,
            headers=_chat_auth_headers_from_request(req),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/chat/groups/{group_id}/keys/events")
def chat_group_key_events(group_id: str, device_id: str, request: Request, limit: int = 20):
    params = {"device_id": device_id, "limit": max(1, min(limit, 200))}
    try:
        if _use_chat_internal():
            if not _CHAT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="chat internal not available")
            with _chat_internal_session() as s:
                return _chat_list_key_events(group_id=group_id, request=request, device_id=device_id, limit=limit, s=s)  # type: ignore[arg-type]
        r = httpx.get(
            _chat_url(f"/groups/{group_id}/keys/events"),
            params=params,
            headers=_chat_auth_headers_from_request(request),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.websocket("/ws/chat/inbox")
async def chat_inbox_ws(ws: WebSocket):
    await ws.accept()
    try:
        params = dict(ws.query_params)
        chat_headers = _chat_auth_headers_from_ws(ws)
        did = params.get("device_id") or chat_headers.get("X-Chat-Device-Id")
        since_iso = params.get("since_iso") or ""
        last_iso = since_iso
        while True:
            try:
                if _use_chat_internal():
                    if not _CHAT_INTERNAL_AVAILABLE:
                        raise RuntimeError("chat internal not available")
                    q_since = last_iso or None
                    with _chat_internal_session() as s:
                        arr = _chat_inbox(request=ws, device_id=did, since_iso=q_since, limit=100, s=s)
                    if arr:
                        try:
                            last_iso = max([m.created_at or "" for m in arr]) or last_iso  # type: ignore[attr-defined]
                        except Exception:
                            pass
                        payload = [
                            {
                                "id": getattr(m, "id", None),
                                "sender_id": getattr(m, "sender_id", None),
                                "recipient_id": getattr(m, "recipient_id", None),
                                "nonce_b64": getattr(m, "nonce_b64", None),
                                "box_b64": getattr(m, "box_b64", None),
                                "sender_pubkey_b64": getattr(m, "sender_pubkey_b64", getattr(m, "sender_pubkey", None)),
                                "sender_dh_pub_b64": getattr(m, "sender_dh_pub_b64", getattr(m, "sender_dh_pub", None)),
                                "created_at": getattr(m, "created_at", None),
                                "delivered_at": getattr(m, "delivered_at", None),
                                "read_at": getattr(m, "read_at", None),
                                "expire_at": getattr(m, "expire_at", None),
                                "sealed_sender": getattr(m, "sealed_sender", False),
                                "sender_hint": getattr(m, "sender_hint", None),
                                "sender_fingerprint": getattr(m, "sender_fingerprint", getattr(m, "sender_hint", None)),
                                "key_id": getattr(m, "key_id", None),
                                "prev_key_id": getattr(m, "prev_key_id", None),
                            }
                            for m in arr
                        ]
                        await ws.send_json({"type": "inbox", "messages": payload})
                else:
                    qparams = {"device_id": did, "limit": 100}
                    if last_iso:
                        qparams["since_iso"] = last_iso
                    r = httpx.get(
                        _chat_url("/messages/inbox"),
                        params=qparams,
                        headers=chat_headers,
                        timeout=10,
                    )
                    if r.status_code == 200:
                        arr = r.json()
                        if arr:
                            try:
                                last_iso = max([m.get("created_at") or "" for m in arr]) or last_iso
                            except Exception:
                                pass
                            await ws.send_json({"type": "inbox", "messages": arr})
                await asyncio.sleep(2)
            except Exception as e:
                await ws.send_json({"type": "error", "error": str(e)})
                await asyncio.sleep(2)
    except WebSocketDisconnect:
        return


@app.websocket("/ws/chat/groups")
async def chat_groups_ws(ws: WebSocket):
    """
    Real-time-ish group inbox stream.

    Mirrors /ws/chat/inbox by polling group inbox endpoints and emitting
    JSON frames of shape:
      {"type":"group_inbox","group_id":"...","messages":[...]}
    """
    await ws.accept()
    try:
        params = dict(ws.query_params)
        chat_headers = _chat_auth_headers_from_ws(ws)
        did = params.get("device_id") or chat_headers.get("X-Chat-Device-Id")
        last_by_gid: Dict[str, str] = {}
        # Optional resume map: since_map={"gid":"iso",...}
        since_map_raw = params.get("since_map") or ""
        if since_map_raw:
            try:
                decoded = _json.loads(since_map_raw)
                if isinstance(decoded, dict):
                    last_by_gid = {
                        str(k): str(v)
                        for k, v in decoded.items()
                        if str(k) and str(v)
                    }
            except Exception:
                last_by_gid = {}

        while True:
            try:
                groups: List[Any] = []
                if _use_chat_internal():
                    if not _CHAT_INTERNAL_AVAILABLE:
                        raise RuntimeError("chat internal not available")
                    with _chat_internal_session() as s:
                        groups = _chat_list_groups(request=ws, device_id=did, s=s)
                else:
                    r = httpx.get(
                        _chat_url("/groups/list"),
                        params={"device_id": did},
                        headers=chat_headers,
                        timeout=10,
                    )
                    if r.status_code == 200:
                        groups = r.json() or []

                for g in groups:
                    gid: str = ""
                    try:
                        gid = (
                            getattr(g, "group_id", None)
                            or getattr(g, "id", None)
                            or ""
                        )
                    except Exception:
                        gid = ""
                    if not gid and isinstance(g, dict):
                        gid = (g.get("group_id") or g.get("id") or "").strip()
                    if not gid:
                        continue

                    last_iso = last_by_gid.get(gid, "")
                    arr: List[Any] = []
                    if _use_chat_internal():
                        with _chat_internal_session() as s:
                            sin = last_iso or None
                            arr = _chat_group_inbox(
                                group_id=gid,
                                request=ws,
                                device_id=did,
                                since_iso=sin,
                                limit=100,
                                s=s,
                            )
                        if arr:
                            try:
                                last_iso = (
                                    max(
                                        [
                                            getattr(m, "created_at", "") or ""
                                            for m in arr
                                        ]
                                    )
                                    or last_iso
                                )
                            except Exception:
                                pass
                            last_by_gid[gid] = last_iso
                            payload = [
                                {
                                    "id": getattr(m, "id", None),
                                    "group_id": getattr(
                                        m, "group_id", getattr(m, "groupId", None)
                                    ),
                                    "sender_id": getattr(m, "sender_id", None),
                                    "text": getattr(m, "text", ""),
                                    "kind": getattr(m, "kind", None),
                                    "nonce_b64": getattr(m, "nonce_b64", None),
                                    "box_b64": getattr(m, "box_b64", None),
                                    "attachment_b64": getattr(m, "attachment_b64", None),
                                    "attachment_mime": getattr(m, "attachment_mime", None),
                                    "voice_secs": getattr(m, "voice_secs", None),
                                    "created_at": getattr(m, "created_at", None),
                                    "expire_at": getattr(m, "expire_at", None),
                                }
                                for m in arr
                            ]
                            await ws.send_json(
                                {
                                    "type": "group_inbox",
                                    "group_id": gid,
                                    "messages": payload,
                                }
                            )
                    else:
                        qparams: Dict[str, Any] = {
                            "device_id": did,
                            "limit": 100,
                        }
                        if last_iso:
                            qparams["since_iso"] = last_iso
                        r = httpx.get(
                            _chat_url(f"/groups/{gid}/messages/inbox"),
                            params=qparams,
                            headers=chat_headers,
                            timeout=10,
                        )
                        if r.status_code == 200:
                            arr = r.json() or []
                            if arr:
                                try:
                                    last_iso = (
                                        max(
                                            [m.get("created_at") or "" for m in arr]
                                        )
                                        or last_iso
                                    )
                                except Exception:
                                    pass
                                last_by_gid[gid] = last_iso
                                await ws.send_json(
                                    {
                                        "type": "group_inbox",
                                        "group_id": gid,
                                        "messages": arr,
                                    }
                                )

                await asyncio.sleep(2)
            except Exception as e:
                await ws.send_json({"type": "error", "error": str(e)})
                await asyncio.sleep(2)
    except WebSocketDisconnect:
        return


@app.websocket("/ws/call/signaling")
async def call_signaling_ws(ws: WebSocket):
    """
    Lightweight VoIP signaling WebSocket.

    This endpoint routes JSON messages between devices based on `device_id`
    and `to` fields. It is intentionally kept stateless apart from an
    in-memory mapping of active connections so that the Flutter client
    (CallSignalingClient) can use it for invites/answers/hangups and
    later WebRTC SDP/ICE exchange.
    """
    await ws.accept()
    params = dict(ws.query_params)
    device_id = params.get("device_id") or ""
    if not device_id:
        await ws.close(code=4000)
        return
    # Register connection
    _CALL_WS_CONNECTIONS[device_id] = ws
    try:
        while True:
            try:
                payload = await ws.receive_text()
            except WebSocketDisconnect:
                break
            except Exception:
                continue
            try:
                msg = _json.loads(payload)
            except Exception:
                continue
            if not isinstance(msg, dict):
                continue
            msg.setdefault("from", device_id)
            t = str(msg.get("type") or "")
            # For now we simply route based on explicit `to` field.
            target = str(msg.get("to") or "")
            if target and target in _CALL_WS_CONNECTIONS:
                try:
                    await _CALL_WS_CONNECTIONS[target].send_text(_json.dumps(msg))
                except Exception:
                    # Drop broken targets; they will be cleaned up on their side.
                    try:
                        _CALL_WS_CONNECTIONS.pop(target, None)
                    except Exception:
                        pass
            # Optionally echo minimal ACK to sender for debugging
            if t == "invite":
                try:
                    await ws.send_text(
                        _json.dumps(
                            {
                                "type": "invite_ack",
                                "call_id": msg.get("call_id"),
                                "to": target,
                            }
                        )
                    )
                except Exception:
                    pass
    except WebSocketDisconnect:
        pass
    finally:
        try:
          # Remove only if mapping still points to this socket
          existing = _CALL_WS_CONNECTIONS.get(device_id)
          if existing is ws:
              _CALL_WS_CONNECTIONS.pop(device_id, None)
        except Exception:
            pass


# ---- Freight / Courier proxies ----
def _freight_url(path: str) -> str:
    if not FREIGHT_BASE:
        raise HTTPException(status_code=500, detail="FREIGHT_BASE_URL not configured")
    return FREIGHT_BASE.rstrip("/") + path


def _courier_url(path: str) -> str:
    if not COURIER_BASE:
        raise HTTPException(status_code=500, detail="COURIER_BASE_URL not configured")
    return COURIER_BASE.rstrip("/") + path


# --- Freight internal service (monolith mode) ---
_FREIGHT_INTERNAL_AVAILABLE = False
try:
    from sqlalchemy.orm import Session as _FreightSession  # type: ignore[import]
    from apps.freight.app import main as _freight_main  # type: ignore[import]
    from apps.freight.app.main import (  # type: ignore[import]
        engine as _freight_engine,
        get_session as _freight_get_session,
        QuoteReq as _FreightQuoteReq,
        BookReq as _FreightBookReq,
        ShipmentOut as _FreightShipmentOut,
        StatusReq as _FreightStatusReq,
        quote as _freight_quote,
        book as _freight_book,
        get_shipment as _freight_get_shipment,
        set_status as _freight_set_status,
    )
    _FREIGHT_INTERNAL_AVAILABLE = True
except Exception:
    _FreightSession = None  # type: ignore[assignment]
    _freight_engine = None  # type: ignore[assignment]
    _FREIGHT_INTERNAL_AVAILABLE = False


def _use_freight_internal() -> bool:
    if _force_internal(_FREIGHT_INTERNAL_AVAILABLE):
        return True
    mode = os.getenv("FREIGHT_INTERNAL_MODE", "auto").lower()
    if mode == "off":
        return False
    if not _FREIGHT_INTERNAL_AVAILABLE:
        return False
    if mode == "on":
        return True
    return not bool(FREIGHT_BASE)


def _freight_internal_session():
    if not _FREIGHT_INTERNAL_AVAILABLE or _FreightSession is None or _freight_engine is None:  # type: ignore[truthy-function]
        raise RuntimeError("Freight internal service not available")
    return _FreightSession(_freight_engine)  # type: ignore[call-arg]


@app.post("/freight/quote")
async def freight_quote(req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_freight_internal():
            if not _FREIGHT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="freight internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                qreq = _FreightQuoteReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            # quote() has no DB, so no need for session
            return _freight_quote(req=qreq)
        r = httpx.post(_freight_url("/quote"), json=body, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/courier/quote")
async def courier_quote(req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        r = httpx.post(_courier_url("/quote"), json=body, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/freight/book")
async def freight_book(request: Request):
    try:
        body = await request.json()
    except Exception:
        body = None
    headers: dict[str, str] = {}
    try:
        ikey = request.headers.get("Idempotency-Key")
    except Exception:
        ikey = None
    if ikey:
        headers["Idempotency-Key"] = ikey
    try:
        if _use_freight_internal():
            if not _FREIGHT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="freight internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                breq = _FreightBookReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _freight_internal_session() as s:
                return _freight_book(request=request, req=breq, idempotency_key=ikey, s=s)
        r = httpx.post(_freight_url("/book"), json=body, headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/courier/book")
async def courier_book(req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    headers: dict[str, str] = {}
    try:
        ikey = req.headers.get("Idempotency-Key")
    except Exception:
        ikey = None
    if ikey:
        headers["Idempotency-Key"] = ikey
    try:
        r = httpx.post(_courier_url("/orders"), json=body, headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/freight/shipments/{sid}")
def freight_get_shipment(sid: str):
    try:
        if _use_freight_internal():
            if not _FREIGHT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="freight internal not available")
            with _freight_internal_session() as s:
                return _freight_get_shipment(sid=sid, s=s)
        r = httpx.get(_freight_url(f"/shipments/{sid}"), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/courier/shipments/{sid}")
def courier_get_shipment(sid: str):
    try:
        r = httpx.get(_courier_url(f"/track/{sid}"), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/freight/shipments/{sid}/status")
async def freight_set_status(sid: str, req: Request):
    _require_operator(req, "freight")
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_freight_internal():
            if not _FREIGHT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="freight internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                sreq = _FreightStatusReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _freight_internal_session() as s:
                return _freight_set_status(sid=sid, req=sreq, s=s)
        r = httpx.post(_freight_url(f"/shipments/{sid}/status"), json=body, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/courier/shipments/{sid}/status")
async def courier_set_status(sid: str, req: Request):
    _require_operator(req, "freight")
    try:
        body = await req.json()
    except Exception:
        body = None
    headers: dict[str, str] = {}
    try:
        ikey = req.headers.get("Idempotency-Key")
    except Exception:
        ikey = None
    if ikey:
        headers["Idempotency-Key"] = ikey
    try:
        r = httpx.post(_courier_url(f"/orders/{sid}/status"), json=body, headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/courier/track/{token}")
def courier_track_public(token: str):
    try:
        r = httpx.get(_courier_url(f"/track/public/{token}"), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/courier/orders/{oid}/contact")
async def courier_contact(oid: str, req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        r = httpx.post(_courier_url(f"/orders/{oid}/contact"), json=body, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/courier/orders/{oid}/reschedule")
async def courier_reschedule(oid: str, req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        r = httpx.post(_courier_url(f"/orders/{oid}/reschedule"), json=body, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/courier/stats")
def courier_stats(request: Request, carrier: str | None = None, partner_id: str | None = None, service_type: str | None = None):
    _require_admin_v2(request)
    params = {}
    if carrier:
        params["carrier"] = carrier
    if partner_id:
        params["partner_id"] = partner_id
    if service_type:
        params["service_type"] = service_type
    headers = {}
    if COURIER_ADMIN_TOKEN:
        headers["X-Admin-Token"] = COURIER_ADMIN_TOKEN
    try:
        r = httpx.get(_courier_url("/stats"), params=params, headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/courier/stats/export")
def courier_stats_export(request: Request, carrier: str | None = None, partner_id: str | None = None, service_type: str | None = None):
    _require_admin_v2(request)
    params = {}
    if carrier:
        params["carrier"] = carrier
    if partner_id:
        params["partner_id"] = partner_id
    if service_type:
        params["service_type"] = service_type
    headers = {}
    if COURIER_ADMIN_TOKEN:
        headers["X-Admin-Token"] = COURIER_ADMIN_TOKEN
    try:
        r = httpx.get(_courier_url("/stats/export"), params=params, headers=headers, timeout=10)
        resp = Response(content=r.content, media_type="text/csv")
        cd = r.headers.get("Content-Disposition")
        if cd:
            resp.headers["Content-Disposition"] = cd
        return resp
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/courier/kpis/partners")
def courier_partner_kpis(request: Request, start_iso: str | None = None, end_iso: str | None = None, carrier: str | None = None, service_type: str | None = None):
    _require_admin_v2(request)
    params = {}
    if start_iso:
        params["start_iso"] = start_iso
    if end_iso:
        params["end_iso"] = end_iso
    if carrier:
        params["carrier"] = carrier
    if service_type:
        params["service_type"] = service_type
    headers = {}
    if COURIER_ADMIN_TOKEN:
        headers["X-Admin-Token"] = COURIER_ADMIN_TOKEN
    try:
        r = httpx.get(_courier_url("/kpis/partners"), params=params, headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/courier/kpis/partners/export")
def courier_partner_kpis_export(request: Request, start_iso: str | None = None, end_iso: str | None = None, carrier: str | None = None, service_type: str | None = None):
    _require_admin_v2(request)
    params = {}
    if start_iso:
        params["start_iso"] = start_iso
    if end_iso:
        params["end_iso"] = end_iso
    if carrier:
        params["carrier"] = carrier
    if service_type:
        params["service_type"] = service_type
    headers = {}
    if COURIER_ADMIN_TOKEN:
        headers["X-Admin-Token"] = COURIER_ADMIN_TOKEN
    try:
        r = httpx.get(_courier_url("/kpis/partners/export"), params=params, headers=headers, timeout=10)
        resp = Response(content=r.content, media_type="text/csv")
        cd = r.headers.get("Content-Disposition")
        if cd:
            resp.headers["Content-Disposition"] = cd
        return resp
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/courier/address/validate")
def courier_validate_address(lat: float, lng: float, address: str | None = None):
    try:
        r = httpx.get(_courier_url("/address/validate"), params={"lat": lat, "lng": lng, "address": address or ""}, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/courier/slots")
def courier_slots(service_type: str = "same_day"):
    try:
        r = httpx.get(_courier_url("/slots"), params={"service_type": service_type}, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/courier/partners", response_model=dict)
def courier_create_partner(body: dict):
    try:
        r = httpx.post(_courier_url("/partners"), json=body, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/courier/partners")
def courier_list_partners():
    try:
        r = httpx.get(_courier_url("/partners"), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/courier/apply", response_model=dict)
def courier_apply(body: dict):
    try:
        r = httpx.post(_courier_url("/apply"), json=body, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/courier/admin/applications")
def courier_admin_applications(request: Request, status: str | None = None):
    _require_admin_v2(request)
    params = {}
    if status:
        params["status"] = status
    headers = {}
    if COURIER_ADMIN_TOKEN:
        headers["X-Admin-Token"] = COURIER_ADMIN_TOKEN
    try:
        r = httpx.get(_courier_url("/admin/applications"), params=params, headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


# ---- Stays proxies ----
def _stays_url(path: str) -> str:
    if not STAYS_BASE:
        raise HTTPException(status_code=500, detail="STAYS_BASE_URL not configured")
    return STAYS_BASE.rstrip("/") + path


# --- Stays internal service (monolith mode) ---
_STAYS_INTERNAL_AVAILABLE = False
try:
    from sqlalchemy.orm import Session as _StaysSession  # type: ignore[import]
    from apps.stays.app import main as _stays_main  # type: ignore[import]
    from apps.stays.app.main import (  # type: ignore[import]
        engine as _stays_engine,
        get_session as _stays_get_session,
        ListingCreate as _StaysListingCreate,
        ListingUpdate as _StaysListingUpdate,
        ListingsPage as _StaysListingsPage,
        QuoteReq as _StaysQuoteReq,
        BookReq as _StaysBookReq,
        BookingOut as _StaysBookingOut,
        OperatorCreate as _StaysOperatorCreate,
        OperatorOut as _StaysOperatorOut,
        OperatorLoginReq as _StaysOperatorLoginReq,
        OperatorLoginOut as _StaysOperatorLoginOut,
        OperatorCodeReq as _StaysOperatorCodeReq,
        OperatorVerifyReq as _StaysOperatorVerifyReq,
        RoomTypeCreate as _StaysRoomTypeCreate,
        RoomTypeUpdate as _StaysRoomTypeUpdate,
        RoomTypeOut as _StaysRoomTypeOut,
        RoomCreate as _StaysRoomCreate,
        RoomUpdate as _StaysRoomUpdate,
        RoomOut as _StaysRoomOut,
        PropertyCreate as _StaysPropertyCreate,
        PropertyOut as _StaysPropertyOut,
        StaffCreate as _StaysStaffCreate,
        StaffUpdate as _StaysStaffUpdate,
        StaffOut as _StaysStaffOut,
        DayRatesUpsert as _StaysDayRatesUpsert,
        DayRatesPage as _StaysDayRatesPage,
        BookingsPage as _StaysBookingsPage,
        BookingStatusUpdate as _StaysBookingStatusUpdate,
        create_listing as _stays_create_listing,
        list_listings as _stays_list_listings,
        list_listings_search as _stays_list_listings_search,
        quote as _stays_quote,
        book as _stays_book,
        get_booking as _stays_get_booking,
        create_operator as _stays_create_operator,
        get_operator as _stays_get_operator,
        operator_listings as _stays_operator_listings,
        operator_bookings as _stays_operator_bookings,
        operator_login as _stays_operator_login,
        operators_request_code as _stays_operators_request_code,
        operators_verify as _stays_operators_verify,
        operator_create_listing as _stays_operator_create_listing,
        operator_update_listing as _stays_operator_update_listing,
        operator_delete_listing as _stays_operator_delete_listing,
        create_room_type as _stays_create_room_type,
        list_room_types as _stays_list_room_types,
        update_room_type as _stays_update_room_type,
        create_room as _stays_create_room,
        list_rooms as _stays_list_rooms,
        update_room as _stays_update_room,
        create_property as _stays_create_property,
        list_properties as _stays_list_properties,
        create_staff as _stays_create_staff,
        list_staff as _stays_list_staff,
        update_staff as _stays_update_staff,
        deactivate_staff as _stays_deactivate_staff,
        get_room_type_rates as _stays_get_room_type_rates,
        upsert_room_type_rates as _stays_upsert_room_type_rates,
        operator_listings_search as _stays_operator_listings_search,
        operator_bookings_search as _stays_operator_bookings_search,
        operator_update_booking_status as _stays_operator_update_booking_status,
    )
    _STAYS_INTERNAL_AVAILABLE = True
except Exception:
    _StaysSession = None  # type: ignore[assignment]
    _stays_engine = None  # type: ignore[assignment]
    _STAYS_INTERNAL_AVAILABLE = False


def _use_stays_internal() -> bool:
    if _force_internal(_STAYS_INTERNAL_AVAILABLE):
        return True
    mode = os.getenv("STAYS_INTERNAL_MODE", "auto").lower()
    if mode == "off":
        return False
    if not _STAYS_INTERNAL_AVAILABLE:
        return False
    if mode == "on":
        return True
    return not bool(STAYS_BASE)


def _stays_internal_session():
    if not _STAYS_INTERNAL_AVAILABLE or _StaysSession is None or _stays_engine is None:  # type: ignore[truthy-function]
        raise RuntimeError("Stays internal service not available")
    return _StaysSession(_stays_engine)  # type: ignore[call-arg]


# ---- Operator health-only proxies for additional apps ----
@app.get("/agriculture/health")
def agriculture_health():
    try:
        if _use_agriculture_internal():
            return {"status": "ok", "source": "internal", "service": "agriculture"}
        r = httpx.get(_agriculture_url("/health"), timeout=5)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/commerce/health")
def commerce_health():
    try:
        if _use_commerce_internal():
            # Internal Commerce app already exposes /health via shamell_shared
            return {"status": "ok", "source": "internal", "service": "commerce"}
        r = httpx.get(_commerce_url("/health"), timeout=5)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/doctors/health")
def doctors_health():
    try:
        if _use_doctors_internal():
            return {"status": "ok", "source": "internal", "service": "doctors"}
        r = httpx.get(_doctors_url("/health"), timeout=5)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/flights/health")
def flights_health():
    try:
        if _use_flights_internal():
            return {"status": "ok", "source": "internal", "service": "flights"}
        r = httpx.get(_flights_url("/health"), timeout=5)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/jobs/health")
def jobs_health():
    try:
        if _use_jobs_internal():
            return {"status": "ok", "source": "internal", "service": "jobs"}
        r = httpx.get(_jobs_url("/health"), timeout=5)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/livestock/health")
def livestock_health():
    try:
        if _use_livestock_internal():
            return {"status": "ok", "source": "internal", "service": "livestock"}
        r = httpx.get(_livestock_url("/health"), timeout=5)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))

# ---- Additional upstream helpers (health-only until APIs exist) ----
def _agriculture_url(path: str) -> str:
    if not AGRICULTURE_BASE:
        raise HTTPException(status_code=500, detail="AGRICULTURE_BASE_URL not configured")
    return AGRICULTURE_BASE.rstrip("/") + path

def _commerce_url(path: str) -> str:
    if not COMMERCE_BASE:
        raise HTTPException(status_code=500, detail="COMMERCE_BASE_URL not configured")
    return COMMERCE_BASE.rstrip("/") + path

def _doctors_url(path: str) -> str:
    if not DOCTORS_BASE:
        raise HTTPException(status_code=500, detail="DOCTORS_BASE_URL not configured")
    return DOCTORS_BASE.rstrip("/") + path

def _flights_url(path: str) -> str:
    if not FLIGHTS_BASE:
        raise HTTPException(status_code=500, detail="FLIGHTS_BASE_URL not configured")
    return FLIGHTS_BASE.rstrip("/") + path


# --- Commerce/Doctors/Flights/Jobs/Agriculture/Livestock internal services (monolith mode) ---
_COMMERCE_INTERNAL_AVAILABLE = False
_DOCTORS_INTERNAL_AVAILABLE = False
_FLIGHTS_INTERNAL_AVAILABLE = False
_JOBS_INTERNAL_AVAILABLE = False
_AGRICULTURE_INTERNAL_AVAILABLE = False
_LIVESTOCK_INTERNAL_AVAILABLE = False
try:
    from sqlalchemy.orm import Session as _CommerceSession  # type: ignore[import]
    from apps.commerce.app import main as _commerce_main  # type: ignore[import]
    from apps.commerce.app.main import (  # type: ignore[import]
        engine as _commerce_engine,
        ProductCreate as _CommerceProductCreate,
        OrderCreate as _CommerceOrderCreate,
        OrderStatusUpdate as _CommerceOrderStatusUpdate,
        create_product as _commerce_create_product,
        list_products as _commerce_list_products,
        get_product as _commerce_get_product,
        create_order as _commerce_create_order,
        list_orders as _commerce_list_orders,
        get_order as _commerce_get_order,
        update_order_status as _commerce_update_order_status,
    )
    _COMMERCE_INTERNAL_AVAILABLE = True
except Exception:
    _CommerceSession = None  # type: ignore[assignment]
    _commerce_engine = None  # type: ignore[assignment]
    _COMMERCE_INTERNAL_AVAILABLE = False

try:
    from sqlalchemy.orm import Session as _DoctorsSession  # type: ignore[import]
    from apps.doctors.app import main as _doctors_main  # type: ignore[import]
    from apps.doctors.app.main import (  # type: ignore[import]
        engine as _doctors_engine,
        DoctorCreate as _DoctorsDoctorCreate,
        AppointmentCreate as _DoctorsAppointmentCreate,
        AppointmentReschedule as _DoctorsAppointmentReschedule,
        AvailabilityBlock as _DoctorsAvailabilityBlock,
        create_doctor as _doctors_create_doctor,
        list_doctors as _doctors_list_doctors,
        get_doctor as _doctors_get_doctor,
        get_doctor_availability as _doctors_get_doctor_availability,
        set_doctor_availability as _doctors_set_doctor_availability,
        create_appt as _doctors_create_appt,
        list_appts as _doctors_list_appts,
        list_slots as _doctors_list_slots,
        cancel_appointment as _doctors_cancel_appointment,
        reschedule_appointment as _doctors_reschedule_appointment,
    )
    _DOCTORS_INTERNAL_AVAILABLE = True
except Exception:
    _DoctorsSession = None  # type: ignore[assignment]
    _doctors_engine = None  # type: ignore[assignment]
    _DOCTORS_INTERNAL_AVAILABLE = False

try:
    from sqlalchemy.orm import Session as _FlightsSession  # type: ignore[import]
    from apps.flights.app import main as _flights_main  # type: ignore[import]
    from apps.flights.app.main import (  # type: ignore[import]
        engine as _flights_engine,
        FlightCreate as _FlightsFlightCreate,
        BookingCreate as _FlightsBookingCreate,
        create_flight as _flights_create_flight,
        list_flights as _flights_list_flights,
        create_booking as _flights_create_booking,
        get_booking as _flights_get_booking,
    )
    _FLIGHTS_INTERNAL_AVAILABLE = True
except Exception:
    _FlightsSession = None  # type: ignore[assignment]
    _flights_engine = None  # type: ignore[assignment]
    _FLIGHTS_INTERNAL_AVAILABLE = False

try:
    from sqlalchemy.orm import Session as _JobsSession  # type: ignore[import]
    from apps.jobs.app import main as _jobs_main  # type: ignore[import]
    from apps.jobs.app.main import (  # type: ignore[import]
        engine as _jobs_engine,
        get_session as _jobs_get_session,
    )
    _JOBS_INTERNAL_AVAILABLE = True
except Exception:
    _JobsSession = None  # type: ignore[assignment]
    _jobs_engine = None  # type: ignore[assignment]
    _JOBS_INTERNAL_AVAILABLE = False

try:
    from sqlalchemy.orm import Session as _AgricultureSession  # type: ignore[import]
    from apps.agriculture.app import main as _agriculture_main  # type: ignore[import]
    from apps.agriculture.app.main import (  # type: ignore[import]
        engine as _agriculture_engine,
        get_session as _agriculture_get_session,
        ListingCreate as _AgricultureListingCreate,
        ListingUpdate as _AgricultureListingUpdate,
        ListingOut as _AgricultureListingOut,
        RFQCreate as _AgricultureRFQCreate,
        RFQReplyCreate as _AgricultureRFQReplyCreate,
        RFQOut as _AgricultureRFQOut,
        RFQReplyOut as _AgricultureRFQReplyOut,
        OrderCreate as _AgricultureOrderCreate,
        OrderOut as _AgricultureOrderOut,
        OrderUpdate as _AgricultureOrderUpdate,
        create_listing as _agriculture_create_listing,
        list_listings as _agriculture_list_listings,
        get_listing as _agriculture_get_listing,
        update_listing as _agriculture_update_listing,
        create_rfq as _agriculture_create_rfq,
        list_rfqs as _agriculture_list_rfqs,
        get_rfq as _agriculture_get_rfq,
        reply_rfq as _agriculture_reply_rfq,
        list_rfq_replies as _agriculture_list_rfq_replies,
        create_order as _agriculture_create_order,
        list_orders as _agriculture_list_orders,
        update_order as _agriculture_update_order,
    )
    _AGRICULTURE_INTERNAL_AVAILABLE = True
except Exception:
    _AgricultureSession = None  # type: ignore[assignment]
    _agriculture_engine = None  # type: ignore[assignment]
    _AGRICULTURE_INTERNAL_AVAILABLE = False

try:
    from sqlalchemy.orm import Session as _LivestockSession  # type: ignore[import]
    from apps.livestock.app import main as _livestock_main  # type: ignore[import]
    from apps.livestock.app.main import (  # type: ignore[import]
        engine as _livestock_engine,
        get_session as _livestock_get_session,
        ListingCreate as _LivestockListingCreate,
        ListingOut as _LivestockListingOut,
        ListingUpdate as _LivestockListingUpdate,
        OfferCreate as _LivestockOfferCreate,
        OfferUpdate as _LivestockOfferUpdate,
        create_listing as _livestock_create_listing,
        list_listings as _livestock_list_listings,
        get_listing as _livestock_get_listing,
        update_listing as _livestock_update_listing,
        create_offer as _livestock_create_offer,
        list_offers as _livestock_list_offers,
        update_offer as _livestock_update_offer,
    )
    _LIVESTOCK_INTERNAL_AVAILABLE = True
except Exception:
    _LivestockSession = None  # type: ignore[assignment]
    _livestock_engine = None  # type: ignore[assignment]
    _LIVESTOCK_INTERNAL_AVAILABLE = False


def _use_commerce_internal() -> bool:
    if _force_internal(_COMMERCE_INTERNAL_AVAILABLE):
        return True
    mode = os.getenv("COMMERCE_INTERNAL_MODE", "auto").lower()
    if mode == "off":
        return False
    if not _COMMERCE_INTERNAL_AVAILABLE:
        return False
    if mode == "on":
        return True
    return not bool(COMMERCE_BASE)


def _use_doctors_internal() -> bool:
    if _force_internal(_DOCTORS_INTERNAL_AVAILABLE):
        return True
    mode = os.getenv("DOCTORS_INTERNAL_MODE", "auto").lower()
    if mode == "off":
        return False
    if not _DOCTORS_INTERNAL_AVAILABLE:
        return False
    if mode == "on":
        return True
    return not bool(DOCTORS_BASE)


def _use_flights_internal() -> bool:
    if _force_internal(_FLIGHTS_INTERNAL_AVAILABLE):
        return True
    mode = os.getenv("FLIGHTS_INTERNAL_MODE", "auto").lower()
    if mode == "off":
        return False
    if not _FLIGHTS_INTERNAL_AVAILABLE:
        return False
    if mode == "on":
        return True
    return not bool(FLIGHTS_BASE)


def _use_jobs_internal() -> bool:
    if _force_internal(_JOBS_INTERNAL_AVAILABLE):
        return True
    mode = os.getenv("JOBS_INTERNAL_MODE", "auto").lower()
    if mode == "off":
        return False
    if not _JOBS_INTERNAL_AVAILABLE:
        return False
    if mode == "on":
        return True
    return not bool(JOBS_BASE)


def _use_agriculture_internal() -> bool:
    if _force_internal(_AGRICULTURE_INTERNAL_AVAILABLE):
        return True
    mode = os.getenv("AGRICULTURE_INTERNAL_MODE", "auto").lower()
    if mode == "off":
        return False
    if not _AGRICULTURE_INTERNAL_AVAILABLE:
        return False
    if mode == "on":
        return True
    return not bool(AGRICULTURE_BASE)


def _use_livestock_internal() -> bool:
    if _force_internal(_LIVESTOCK_INTERNAL_AVAILABLE):
        return True
    mode = os.getenv("LIVESTOCK_INTERNAL_MODE", "auto").lower()
    if mode == "off":
        return False
    if not _LIVESTOCK_INTERNAL_AVAILABLE:
        return False
    if mode == "on":
        return True
    return not bool(LIVESTOCK_BASE)


def _commerce_internal_session():
    if not _COMMERCE_INTERNAL_AVAILABLE or _CommerceSession is None or _commerce_engine is None:  # type: ignore[truthy-function]
        raise RuntimeError("Commerce internal service not available")
    return _CommerceSession(_commerce_engine)  # type: ignore[call-arg]


def _doctors_internal_session():
    if not _DOCTORS_INTERNAL_AVAILABLE or _DoctorsSession is None or _doctors_engine is None:  # type: ignore[truthy-function]
        raise RuntimeError("Doctors internal service not available")
    return _DoctorsSession(_doctors_engine)  # type: ignore[call-arg]


def _flights_internal_session():
    if not _FLIGHTS_INTERNAL_AVAILABLE or _FlightsSession is None or _flights_engine is None:  # type: ignore[truthy-function]
        raise RuntimeError("Flights internal service not available")
    return _FlightsSession(_flights_engine)  # type: ignore[call-arg]


def _jobs_internal_session():
    if not _JOBS_INTERNAL_AVAILABLE or _JobsSession is None or _jobs_engine is None:  # type: ignore[truthy-function]
        raise RuntimeError("Jobs internal service not available")
    return _JobsSession(_jobs_engine)  # type: ignore[call-arg]


def _agriculture_internal_session():
    if not _AGRICULTURE_INTERNAL_AVAILABLE or _AgricultureSession is None or _agriculture_engine is None:  # type: ignore[truthy-function]
        raise RuntimeError("Agriculture internal service not available")
    return _AgricultureSession(_agriculture_engine)  # type: ignore[call-arg]


def _livestock_internal_session():
    if not _LIVESTOCK_INTERNAL_AVAILABLE or _LivestockSession is None or _livestock_engine is None:  # type: ignore[truthy-function]
        raise RuntimeError("Livestock internal service not available")
    return _LivestockSession(_livestock_engine)  # type: ignore[call-arg]


def _jobs_url(path: str) -> str:
    if not JOBS_BASE:
        raise HTTPException(status_code=500, detail="JOBS_BASE_URL not configured")
    return JOBS_BASE.rstrip("/") + path


def _livestock_url(path: str) -> str:
    if not LIVESTOCK_BASE:
        raise HTTPException(status_code=500, detail="LIVESTOCK_BASE_URL not configured")
    return LIVESTOCK_BASE.rstrip("/") + path

def _building_url(path: str) -> str:
    if not BUILDING_BASE:
        raise HTTPException(status_code=500, detail="BUILDING_BASE_URL not configured")
    return BUILDING_BASE.rstrip("/") + path

# ---- Commerce proxies ----
@app.get("/commerce/products")
def commerce_products(q: str = "", limit: int = 50):
    params = {"limit": max(1, min(limit, 200))}
    if q:
        params["q"] = q
    try:
        if _use_commerce_internal():
            if not _COMMERCE_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="commerce internal not available")
            with _commerce_internal_session() as s:
                return _commerce_list_products(q=q, limit=limit, s=s)
        r = httpx.get(_commerce_url("/products"), params=params, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/commerce/products_cached")
def commerce_products_cached(limit: int = 50, response: Response = None):  # type: ignore[assignment]
    """
    Small cache for the product list without search parameters.
    For q/filter please continue to use /commerce/products directly.
    """
    global _COMMERCE_PRODUCTS_CACHE
    if limit <= 0:
        limit = 50
    # Cache only for standard list without filters
    if _COMMERCE_PRODUCTS_CACHE.get("data") is not None:
        try:
            ts = float(_COMMERCE_PRODUCTS_CACHE.get("ts") or 0.0)
        except Exception:
            ts = 0.0
        if time.time() - ts < 30.0:
            data = _COMMERCE_PRODUCTS_CACHE.get("data")
            try:
                if response is not None:
                    response.headers.setdefault("Cache-Control", "public, max-age=30")
            except Exception:
                pass
            return data
    data = commerce_products(q="", limit=limit)
    _COMMERCE_PRODUCTS_CACHE = {"ts": time.time(), "data": data}
    try:
        if response is not None:
            response.headers.setdefault("Cache-Control", "public, max-age=30")
    except Exception:
        pass
    return data


@app.post("/commerce/products")
async def commerce_create_product(req: Request):
    _require_operator(req, "commerce")
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_commerce_internal():
            if not _COMMERCE_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="commerce internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                preq = _CommerceProductCreate(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _commerce_internal_session() as s:
                return _commerce_create_product(req=preq, s=s)
        r = httpx.post(_commerce_url("/products"), json=body, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/commerce/products/{pid}")
def commerce_get_product(pid: int):
    try:
        if _use_commerce_internal():
            if not _COMMERCE_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="commerce internal not available")
            with _commerce_internal_session() as s:
                return _commerce_get_product(pid=pid, s=s)
        r = httpx.get(_commerce_url(f"/products/{pid}"), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/building/materials")
def building_materials(q: str = "", limit: int = 50):
    """
    Building Materials catalog endpoint.

    - If BUILDING_BASE_URL is configured, calls the dedicated Building
      service at /materials (recommended for production).
    - Otherwise falls back to /commerce/products, preserving the existing
      behaviour and avoiding client changes.
    """
    # dedicated Building upstream (optional)
    if BUILDING_BASE:
      params = {"limit": max(1, min(limit, 200))}
      if q:
          params["q"] = q
      try:
          r = httpx.get(_building_url("/materials"), params=params, timeout=10)
          return r.json()
      except httpx.HTTPStatusError as e:
          raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
      except Exception as e:
          raise HTTPException(status_code=502, detail=str(e))
    # Fallback: reuse Commerce products as before
    return commerce_products(q=q, limit=limit)


def _building_transfer(
    request: Request,
    from_wallet_id: str,
    to_wallet_id: str,
    amount_cents: int,
    reference: str,
) -> Any:
    """
    Helper to perform a guarded transfer for Building Materials flows.

    Mirrors the logic in /payments/transfer:
      - normalises amounts
      - applies _check_payment_guardrails
      - uses internal Payments when available, otherwise HTTP fallback.
    """
    if amount_cents <= 0:
        raise HTTPException(status_code=400, detail="amount must be > 0")
    try:
        dev = request.headers.get("X-Device-ID") if hasattr(request, "headers") else None
        _check_payment_guardrails(from_wallet_id, amount_cents, dev)
    except HTTPException:
        raise
    except Exception:
        # Guardrails are best-effort; never break payment execution.
        pass

    body: dict[str, Any] = {
        "from_wallet_id": from_wallet_id,
        "to_wallet_id": to_wallet_id,
        "amount_cents": amount_cents,
        "reference": reference,
    }
    body = _normalize_amount(body)

    # Forward selected headers for risk / idempotency
    headers: dict[str, str] = {}
    try:
        ikey = request.headers.get("Idempotency-Key") if hasattr(request, "headers") else None
        dev = request.headers.get("X-Device-ID") if hasattr(request, "headers") else None
        ua = request.headers.get("User-Agent") if hasattr(request, "headers") else None
    except Exception:
        ikey = None
        dev = None
        ua = None
    if ikey:
        headers["Idempotency-Key"] = ikey
    if dev:
        headers["X-Device-ID"] = dev
    if ua:
        headers["User-Agent"] = ua

    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                req_model = _PayTransferReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            try:
                with _pay_internal_session() as s:
                    return _pay_transfer(req_model, request=request, s=s)
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(status_code=502, detail=str(e))
        if not PAYMENTS_BASE:
            raise HTTPException(status_code=500, detail="PAYMENTS_BASE_URL not configured")
        r = httpx.post(
            _payments_url("/transfer"),
            json=body,
            headers=_payments_headers(headers),
            timeout=10,
        )
        if r.headers.get("content-type", "").startswith("application/json"):
            return r.json()
        return {"status_code": r.status_code, "raw": r.text}
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/building/orders")
async def building_create_order(request: Request):
    """
    Create a Building Materials order with escrow:

      - validates product and quantity via Commerce,
      - charges buyer_wallet_id -> ESCROW_WALLET_ID via Payments,
      - creates a Commerce order with status 'paid_escrow'.

    This endpoint assumes the caller is an authenticated end user; the
    wallet ownership checks are enforced on the client side by only offering
    the user’s own wallet for selection.
    """
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    if not ESCROW_WALLET_ID:
        raise HTTPException(status_code=500, detail="ESCROW_WALLET_ID not configured")

    try:
        body = await request.json()
    except Exception:
        body = {}
    if not isinstance(body, dict):
        body = {}

    try:
        product_id = int(body.get("product_id") or 0)
    except Exception:
        product_id = 0
    try:
        quantity = int(body.get("quantity") or 1)
    except Exception:
        quantity = 1
    buyer_wallet_id = (body.get("buyer_wallet_id") or "").strip()

    if product_id <= 0:
        raise HTTPException(status_code=400, detail="product_id required")
    if quantity <= 0:
        raise HTTPException(status_code=400, detail="quantity must be > 0")
    if not buyer_wallet_id:
        raise HTTPException(status_code=400, detail="buyer_wallet_id required")

    # Look up product details via Commerce
    try:
        if _use_commerce_internal():
            if not _COMMERCE_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="commerce internal not available")
            with _commerce_internal_session() as s:
                pobj = _commerce_get_product(pid=product_id, s=s)
                if hasattr(pobj, "model_dump"):
                    product = pobj.model_dump()  # type: ignore[assignment]
                elif hasattr(pobj, "dict"):
                    product = pobj.dict()  # type: ignore[assignment]
                else:
                    # SQLAlchemy ORM object – build a minimal dict view.
                    try:
                        product = {
                            "id": getattr(pobj, "id", None),
                            "name": getattr(pobj, "name", ""),
                            "price_cents": getattr(pobj, "price_cents", 0),
                            "currency": getattr(pobj, "currency", "SYP"),
                            "sku": getattr(pobj, "sku", None),
                            "merchant_wallet_id": getattr(pobj, "merchant_wallet_id", None),
                        }  # type: ignore[assignment]
                    except Exception:
                        product = {}  # type: ignore[assignment]
        else:
            r = httpx.get(_commerce_url(f"/products/{product_id}"), timeout=10)
            product = r.json()
    except HTTPException:
        raise
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))

    if not isinstance(product, dict):
        raise HTTPException(status_code=502, detail="invalid product payload")
    price_cents = product.get("price_cents") or 0
    try:
        price_cents = int(price_cents)
    except Exception:
        price_cents = 0
    currency = (product.get("currency") or "SYP").strip()
    if price_cents <= 0:
        raise HTTPException(status_code=400, detail="product has no price")
    amount_cents = int(price_cents) * int(quantity)
    if amount_cents <= 0:
        raise HTTPException(status_code=400, detail="amount must be > 0")

    # Move funds buyer -> escrow (best-effort, but failures are surfaced).
    ref = f"building product {product_id}"
    _building_transfer(
        request=request,
        from_wallet_id=buyer_wallet_id,
        to_wallet_id=ESCROW_WALLET_ID,
        amount_cents=amount_cents,
        reference=ref,
    )

    # Create order record in Commerce (internal preferred).
    order_payload = {
        "product_id": product_id,
        "quantity": quantity,
        "buyer_wallet_id": buyer_wallet_id,
    }
    try:
        if _use_commerce_internal():
            if not _COMMERCE_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="commerce internal not available")
            try:
                oreq = _CommerceOrderCreate(**order_payload)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _commerce_internal_session() as s:
                o = _commerce_create_order(req=oreq, s=s)
                if hasattr(o, "model_dump"):
                    out = o.model_dump()  # type: ignore[assignment]
                elif hasattr(o, "dict"):
                    out = o.dict()  # type: ignore[assignment]
                else:
                    out = o  # type: ignore[assignment]
        else:
            r = httpx.post(_commerce_url("/orders"), json=order_payload, timeout=10)
            out = r.json()
    except HTTPException:
        raise
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))

    try:
        _audit_from_request(
            request,
            "building_order_create",
            product_id=product_id,
            amount_cents=amount_cents,
            currency=currency,
        )
    except Exception:
        # Audit must never break the main flow
        pass

    return out


@app.get("/building/orders")
def building_list_orders(
    request: Request,
    buyer_wallet_id: str = "",
    seller_wallet_id: str = "",
    limit: int = 50,
):
    """
    List Building Materials orders for a given wallet.

    For now this uses simple wallet-based filters; clients decide whether
    to pass buyer_wallet_id (end user) or seller_wallet_id (operator).
    """
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    limit = max(1, min(limit, 200))
    try:
        if _use_commerce_internal():
            if not _COMMERCE_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="commerce internal not available")
            with _commerce_internal_session() as s:
                raw = _commerce_list_orders(
                    buyer_wallet_id=buyer_wallet_id,
                    seller_wallet_id=seller_wallet_id,
                    limit=limit,
                    s=s,
                )
                out: list[Any] = []
                for it in raw:
                    if hasattr(it, "model_dump"):
                        row = it.model_dump()  # type: ignore[union-attr]
                    elif hasattr(it, "dict"):
                        row = it.dict()  # type: ignore[union-attr]
                    else:
                        row = it
                    out.append(row)
                return out
        params = {"limit": limit}
        if buyer_wallet_id:
            params["buyer_wallet_id"] = buyer_wallet_id
        if seller_wallet_id:
            params["seller_wallet_id"] = seller_wallet_id
        r = httpx.get(_commerce_url("/orders"), params=params, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/building/orders/{order_id}")
def building_get_order(request: Request, order_id: int):
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    try:
        if _use_commerce_internal():
            if not _COMMERCE_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="commerce internal not available")
            with _commerce_internal_session() as s:
                o = _commerce_get_order(oid=order_id, s=s)
                if hasattr(o, "model_dump"):
                    return o.model_dump()  # type: ignore[union-attr]
                if hasattr(o, "dict"):
                    return o.dict()  # type: ignore[union-attr]
                return o
        r = httpx.get(_commerce_url(f"/orders/{order_id}"), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/building/orders/{order_id}/attach_shipment")
async def building_attach_shipment(request: Request, order_id: int):
    """
    Link a Building Materials order to a courier shipment.

    This is used to enforce stronger guardrails on escrow release:
      - If an order is linked to a shipment, the BFF can optionally require
        that the shipment has reached \"delivered\" before allowing `released`.

    For now this endpoint simply stores the link in an in-memory map; it is
    intended for operator/admin tools rather than end users.
    """
    _require_operator(request, "freight")
    try:
        body = await request.json()
    except Exception:
        body = {}
    if not isinstance(body, dict):
        body = {}
    shipment_id = str(body.get("shipment_id") or "").strip()
    if not shipment_id:
        raise HTTPException(status_code=400, detail="shipment_id required")

    # Verify order exists (best-effort)
    try:
        _ = building_get_order(request, order_id)
    except HTTPException:
        raise
    except Exception:
        raise HTTPException(status_code=502, detail="failed to load order")

    # Verify shipment exists (best-effort)
    try:
        if _use_freight_internal():
            if not _FREIGHT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="freight internal not available")
            with _freight_internal_session() as s:
                _freight_get_shipment(sid=shipment_id, s=s)
        else:
            _ = httpx.get(_freight_url(f"/shipments/{shipment_id}"), timeout=10)
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))

    # Store mapping in-memory
    try:
        _BUILDING_ORDER_SHIPMENTS[int(order_id)] = shipment_id
    except Exception:
        _BUILDING_ORDER_SHIPMENTS[order_id] = shipment_id  # type: ignore[index]

    try:
        _audit_from_request(
            request,
            "building_order_attach_shipment",
            order_id=order_id,
            shipment_id=shipment_id,
        )
    except Exception:
        pass

    return {"order_id": order_id, "shipment_id": shipment_id}


@app.post("/building/orders/{order_id}/status")
async def building_update_order_status(request: Request, order_id: int):
    """
    Update the status of a Building Materials order.

    Role model (enforced at BFF level):
      - shipped:   operator (commerce)
      - delivered: any authenticated end user (typically the buyer)
      - disputed:  any authenticated end user (typically the buyer)
      - released:  admin/superadmin (payout from escrow to seller may follow)
      - refunded:  admin/superadmin (refund from escrow to buyer may follow)

    For now, payout/refund legs are not executed here; this endpoint
    focuses on consistent status transitions and audit logging. Money
    remains safely held in ESCROW until a separate settlement routine
    is invoked.
    """
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")

    try:
        body = await request.json()
    except Exception:
        body = {}
    if not isinstance(body, dict):
        body = {}

    new_status = str(body.get("status") or "").strip().lower()
    if not new_status:
        raise HTTPException(status_code=400, detail="status required")

    # Load current order to validate transitions.
    try:
        if _use_commerce_internal():
            if not _COMMERCE_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="commerce internal not available")
            with _commerce_internal_session() as s:
                o = _commerce_get_order(oid=order_id, s=s)
                if hasattr(o, "model_dump"):
                    order = o.model_dump()  # type: ignore[assignment]
                elif hasattr(o, "dict"):
                    order = o.dict()  # type: ignore[assignment]
                else:
                    order = {
                        "id": getattr(o, "id", order_id),
                        "status": getattr(o, "status", ""),
                        "buyer_wallet_id": getattr(o, "buyer_wallet_id", None),
                        "seller_wallet_id": getattr(o, "seller_wallet_id", None),
                        "amount_cents": getattr(o, "amount_cents", 0),
                    }  # type: ignore[assignment]
        else:
            r = httpx.get(_commerce_url(f"/orders/{order_id}"), timeout=10)
            order = r.json()
    except HTTPException:
        raise
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))

    if not isinstance(order, dict):
        raise HTTPException(status_code=502, detail="invalid order payload")

    current_status = str(order.get("status") or "").strip().lower()

    # Simple transition rules: only allow forward progress.
    allowed_from: dict[str, set[str]] = {
        "shipped": {"paid_escrow"},
        # delivered can follow shipped or, in simpler flows without explicit
        # shipment tracking, directly from paid_escrow.
        "delivered": {"paid_escrow", "shipped"},
        "disputed": {"paid_escrow", "shipped", "delivered"},
        "released": {"delivered"},
        "refunded": {"paid_escrow", "shipped", "disputed"},
    }
    allowed_prev = allowed_from.get(new_status)
    if allowed_prev is None:
        raise HTTPException(status_code=400, detail="unsupported status")
    if current_status and current_status not in allowed_prev:
        raise HTTPException(status_code=400, detail="invalid status transition")

    # Role checks per target status.
    if new_status == "shipped":
        _require_operator(request, "commerce")
    elif new_status in ("released", "refunded"):
        _require_admin_v2(request)
    else:
        # delivered / disputed: any authenticated user is allowed.
        pass

    # Settlement for money-moving statuses (released/refunded).
    # We run transfers before persisting the new status so that, on failure,
    # the order state stays unchanged.
    try:
        amount_cents = int(order.get("amount_cents") or 0)
    except Exception:
        amount_cents = 0
    buyer_wallet_id = (order.get("buyer_wallet_id") or "").strip()
    seller_wallet_id = (order.get("seller_wallet_id") or "").strip()
    if new_status in ("released", "refunded"):
        if not ESCROW_WALLET_ID:
            raise HTTPException(status_code=500, detail="ESCROW_WALLET_ID not configured")
        if amount_cents <= 0:
            raise HTTPException(status_code=400, detail="order amount invalid for settlement")
        if new_status == "released":
            if not seller_wallet_id:
                raise HTTPException(status_code=400, detail="order has no seller wallet")
            # If a shipment has been linked via /building/orders/{id}/attach_shipment,
            # require that the shipment has reached delivered state before
            # releasing escrow. This enforces courier confirmation in addition
            # to buyer/order confirmation for the payout leg.
            shipment_id = ""
            try:
                shipment_id = _BUILDING_ORDER_SHIPMENTS.get(int(order_id)) or ""  # type: ignore[arg-type]
            except Exception:
                shipment_id = ""
            shipment_id = shipment_id.strip()
            if shipment_id:
                try:
                    if _use_freight_internal():
                        if not _FREIGHT_INTERNAL_AVAILABLE:
                            raise HTTPException(status_code=500, detail="freight internal not available")
                        with _freight_internal_session() as s:
                            sh = _freight_get_shipment(sid=shipment_id, s=s)
                            if hasattr(sh, "model_dump"):
                                sh_row = sh.model_dump()  # type: ignore[assignment]
                            elif hasattr(sh, "dict"):
                                sh_row = sh.dict()  # type: ignore[assignment]
                            else:
                                sh_row = {
                                    "id": getattr(sh, "id", shipment_id),
                                    "status": getattr(sh, "status", ""),
                                }  # type: ignore[assignment]
                    else:
                        r = httpx.get(_freight_url(f"/shipments/{shipment_id}"), timeout=10)
                        sh_row = r.json()
                except HTTPException:
                    raise
                except httpx.HTTPStatusError as e:
                    raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
                except Exception as e:
                    raise HTTPException(status_code=502, detail=str(e))
                sh_status = str(sh_row.get("status") or "").strip().lower()
                if sh_status != "delivered":
                    raise HTTPException(status_code=400, detail="shipment not delivered yet")
            # Escrow -> seller payout
            _building_transfer(
                request=request,
                from_wallet_id=ESCROW_WALLET_ID,
                to_wallet_id=seller_wallet_id,
                amount_cents=amount_cents,
                reference=f"building order {order_id} release",
            )
        elif new_status == "refunded":
            if not buyer_wallet_id:
                raise HTTPException(status_code=400, detail="order has no buyer wallet")
            # Escrow -> buyer refund
            _building_transfer(
                request=request,
                from_wallet_id=ESCROW_WALLET_ID,
                to_wallet_id=buyer_wallet_id,
                amount_cents=amount_cents,
                reference=f"building order {order_id} refund",
            )

    # Persist status via Commerce.
    payload = {"status": new_status}
    try:
        if _use_commerce_internal():
            if not _COMMERCE_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="commerce internal not available")
            try:
                sreq = _CommerceOrderStatusUpdate(**payload)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _commerce_internal_session() as s:
                o2 = _commerce_update_order_status(oid=order_id, req=sreq, s=s)
                if hasattr(o2, "model_dump"):
                    updated = o2.model_dump()  # type: ignore[assignment]
                elif hasattr(o2, "dict"):
                    updated = o2.dict()  # type: ignore[assignment]
                else:
                    updated = updated = {
                        "id": getattr(o2, "id", order_id),
                        "status": getattr(o2, "status", new_status),
                        "buyer_wallet_id": getattr(o2, "buyer_wallet_id", None),
                        "seller_wallet_id": getattr(o2, "seller_wallet_id", None),
                        "amount_cents": getattr(o2, "amount_cents", 0),
                    }  # type: ignore[assignment]
        else:
            r = httpx.post(_commerce_url(f"/orders/{order_id}/status"), json=payload, timeout=10)
            updated = r.json()
    except HTTPException:
        raise
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))

    # Audit for observability.
    try:
        _audit_from_request(
            request,
            "building_order_status_update",
            order_id=order_id,
            from_status=current_status or None,
            to_status=new_status,
        )
    except Exception:
        pass

    return updated


# ---- Doctors proxies ----
@app.get("/doctors/doctors")
def doctors_list(q: str = "", city: str = "", speciality: str = "", limit: int = 50):
    params = {"limit": max(1, min(limit, 200))}
    if q:
        params["q"] = q
    if city:
        params["city"] = city
    if speciality:
        params["speciality"] = speciality
    try:
        if _use_doctors_internal():
            if not _DOCTORS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="doctors internal not available")
            with _doctors_internal_session() as s:
                return _doctors_list_doctors(q=q, city=city, speciality=speciality, limit=limit, s=s)
        r = httpx.get(_doctors_url("/doctors"), params=params, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/doctors/doctors")
async def doctors_create(req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        ikey = None
        try:
            ikey = req.headers.get("Idempotency-Key")
        except Exception:
            ikey = None
        if _use_doctors_internal():
            if not _DOCTORS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="doctors internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                dreq = _DoctorsDoctorCreate(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _doctors_internal_session() as s:
                return _doctors_create_doctor(req=dreq, idempotency_key=ikey, s=s)
        headers: dict[str, str] = {}
        if ikey:
            headers["Idempotency-Key"] = ikey
        r = httpx.post(_doctors_url("/doctors"), json=body, headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/doctors/doctors/{doctor_id}")
def doctors_get(doctor_id: int):
    try:
        if _use_doctors_internal():
            if not _DOCTORS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="doctors internal not available")
            with _doctors_internal_session() as s:
                return _doctors_get_doctor(doctor_id=doctor_id, s=s)
        r = httpx.get(_doctors_url(f"/doctors/{doctor_id}"), timeout=10)
        r.raise_for_status()
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/doctors/doctors/{doctor_id}/availability")
def doctors_get_availability(doctor_id: int):
    try:
        if _use_doctors_internal():
            if not _DOCTORS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="doctors internal not available")
            with _doctors_internal_session() as s:
                return _doctors_get_doctor_availability(doctor_id=doctor_id, s=s)
        r = httpx.get(_doctors_url(f"/doctors/{doctor_id}/availability"), timeout=10)
        r.raise_for_status()
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.put("/doctors/doctors/{doctor_id}/availability")
async def doctors_set_availability(doctor_id: int, req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_doctors_internal():
            if not _DOCTORS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="doctors internal not available")
            data = body or []
            if not isinstance(data, list):
                raise HTTPException(status_code=400, detail="body must be a list")
            blocks = []
            for item in data:
                if not isinstance(item, dict):
                    raise HTTPException(status_code=400, detail="invalid availability block")
                try:
                    blocks.append(_DoctorsAvailabilityBlock(**item))
                except Exception as e:
                    raise HTTPException(status_code=400, detail=str(e))
            with _doctors_internal_session() as s:
                return _doctors_set_doctor_availability(doctor_id=doctor_id, blocks=blocks, s=s)
        r = httpx.put(_doctors_url(f"/doctors/{doctor_id}/availability"), json=body, timeout=10)
        r.raise_for_status()
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/doctors/appointments")
def doctors_list_appointments(doctor_id: int | None = None, limit: int = 50):
    params: dict[str, object] = {"limit": max(1, min(limit, 200))}
    if doctor_id is not None:
        params["doctor_id"] = doctor_id
    try:
        if _use_doctors_internal():
            if not _DOCTORS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="doctors internal not available")
            with _doctors_internal_session() as s:
                return _doctors_list_appts(doctor_id=doctor_id, limit=limit, s=s)
        r = httpx.get(_doctors_url("/appointments"), params=params, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/doctors/slots")
def doctors_slots(doctor_id: int, start_date: str | None = None, days: int = 7):
    days_clamped = max(1, min(days, 31))
    params: dict[str, object] = {"doctor_id": doctor_id, "days": days_clamped}
    if start_date:
        params["start_date"] = start_date
    try:
        if _use_doctors_internal():
            if not _DOCTORS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="doctors internal not available")
            with _doctors_internal_session() as s:
                return _doctors_list_slots(doctor_id=doctor_id, start_date=start_date, days=days_clamped, s=s)
        r = httpx.get(_doctors_url("/slots"), params=params, timeout=10)
        r.raise_for_status()
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/doctors/appointments")
async def doctors_create_appointment(req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        ikey = None
        try:
            ikey = req.headers.get("Idempotency-Key")
        except Exception:
            ikey = None
        if _use_doctors_internal():
            if not _DOCTORS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="doctors internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                areq = _DoctorsAppointmentCreate(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _doctors_internal_session() as s:
                return _doctors_create_appt(req=areq, idempotency_key=ikey, s=s)
        headers: dict[str, str] = {}
        if ikey:
            headers["Idempotency-Key"] = ikey
        r = httpx.post(_doctors_url("/appointments"), json=body, headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/doctors/appointments/{appt_id}/cancel")
async def doctors_cancel_appointment(appt_id: str):
    try:
        if _use_doctors_internal():
            if not _DOCTORS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="doctors internal not available")
            with _doctors_internal_session() as s:
                return _doctors_cancel_appointment(appt_id=appt_id, s=s)
        r = httpx.post(_doctors_url(f"/appointments/{appt_id}/cancel"), timeout=10)
        r.raise_for_status()
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/doctors/appointments/{appt_id}/reschedule")
async def doctors_reschedule_appointment(appt_id: str, req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_doctors_internal():
            if not _DOCTORS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="doctors internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                areq = _DoctorsAppointmentReschedule(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _doctors_internal_session() as s:
                return _doctors_reschedule_appointment(appt_id=appt_id, req=areq, s=s)
        r = httpx.post(_doctors_url(f"/appointments/{appt_id}/reschedule"), json=body, timeout=10)
        r.raise_for_status()
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


# ---- Flights proxies ----
@app.get("/flights/flights")
def flights_list(q: str = "", frm: str = "", to: str = "", limit: int = 50):
    params = {"limit": max(1, min(limit, 200))}
    if q:
        params["q"] = q
    if frm:
        params["frm"] = frm
    if to:
        params["to"] = to
    try:
        if _use_flights_internal():
            if not _FLIGHTS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="flights internal not available")
            with _flights_internal_session() as s:
                return _flights_list_flights(q=q, frm=frm, to=to, limit=limit, s=s)
        r = httpx.get(_flights_url("/flights"), params=params, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/flights/flights")
async def flights_create(req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        ikey = None
        try:
            ikey = req.headers.get("Idempotency-Key")
        except Exception:
            ikey = None
        if _use_flights_internal():
            if not _FLIGHTS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="flights internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                freq = _FlightsFlightCreate(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _flights_internal_session() as s:
                return _flights_create_flight(req=freq, idempotency_key=ikey, s=s)
        headers: dict[str, str] = {}
        if ikey:
            headers["Idempotency-Key"] = ikey
        r = httpx.post(_flights_url("/flights"), json=body, headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/flights/bookings")
async def flights_create_booking(req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        ikey = None
        try:
            ikey = req.headers.get("Idempotency-Key")
        except Exception:
            ikey = None
        if _use_flights_internal():
            if not _FLIGHTS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="flights internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                breq = _FlightsBookingCreate(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _flights_internal_session() as s:
                return _flights_create_booking(req=breq, idempotency_key=ikey, s=s)
        headers: dict[str, str] = {}
        if ikey:
            headers["Idempotency-Key"] = ikey
        r = httpx.post(_flights_url("/bookings"), json=body, headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/flights/bookings/{bid}")
def flights_get_booking(bid: str):
    try:
        if _use_flights_internal():
            if not _FLIGHTS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="flights internal not available")
            with _flights_internal_session() as s:
                return _flights_get_booking(bid=bid, s=s)
        r = httpx.get(_flights_url(f"/bookings/{bid}"), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/stays/listings")
def stays_listings(q: str = "", city: str = "", limit: int = 50, offset: int = 0):
    params = {"limit": max(1, min(limit, 200)), "offset": max(0, offset)}
    if q:
        params["q"] = q
    if city:
        params["city"] = city
    try:
        if _use_stays_internal():
            if not _STAYS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="stays internal not available")
            with _stays_internal_session() as s:
                return _stays_list_listings(q=q, city=city, limit=limit, offset=offset, s=s)
        r = httpx.get(_stays_url("/listings"), params=params, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


# ---- Agriculture proxies ----
@app.get("/agriculture/listings")
def agriculture_listings(q: str = "", city: str = "", category: str = "", status: str = "", limit: int = 50):
    params = {"limit": max(1, min(limit, 200))}
    if q:
        params["q"] = q
    if city:
        params["city"] = city
    if category:
        params["category"] = category
    if status:
        params["status"] = status
    # status optional
    # allow status via query
    # we won't add a dedicated param here to keep backward compat; users can pass ?status=
    # from req.query_params
    # but to ease usage, read from request? not available here; so accept status param:
    # signature extended above if needed
    try:
        if _use_agriculture_internal():
            if not _AGRICULTURE_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="agriculture internal not available")
            with _agriculture_internal_session() as s:
                return _agriculture_list_listings(q=q, city=city, category=category, status=status, limit=limit, s=s)
        r = httpx.get(_agriculture_url("/listings"), params=params, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/agriculture/listings_cached")
def agriculture_listings_cached(limit: int = 50, response: Response = None):  # type: ignore[assignment]
    """
    Cache for a simple agriculture listing list without filters.
    For q/city/category please continue to use /agriculture/listings.
    """
    global _AGRICULTURE_LISTINGS_CACHE
    if limit <= 0:
        limit = 50
    if _AGRICULTURE_LISTINGS_CACHE.get("data") is not None:
        try:
            ts = float(_AGRICULTURE_LISTINGS_CACHE.get("ts") or 0.0)
        except Exception:
            ts = 0.0
        if time.time() - ts < 30.0:
            data = _AGRICULTURE_LISTINGS_CACHE.get("data")
            try:
                if response is not None:
                    response.headers.setdefault("Cache-Control", "public, max-age=30")
            except Exception:
                pass
            return data
    data = agriculture_listings(q="", city="", category="", limit=limit)
    _AGRICULTURE_LISTINGS_CACHE = {"ts": time.time(), "data": data}
    try:
        if response is not None:
            response.headers.setdefault("Cache-Control", "public, max-age=30")
    except Exception:
        pass
    return data


@app.post("/agriculture/listings")
async def agriculture_create_listing(req: Request):
    _require_operator(req, "agriculture")
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_agriculture_internal():
            if not _AGRICULTURE_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="agriculture internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                lreq = _AgricultureListingCreate(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _agriculture_internal_session() as s:
                return _agriculture_create_listing(req=lreq, s=s)
        r = httpx.post(_agriculture_url("/listings"), json=body, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/agriculture/listings/{lid}")
def agriculture_get_listing(lid: int):
    try:
        if _use_agriculture_internal():
            if not _AGRICULTURE_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="agriculture internal not available")
            with _agriculture_internal_session() as s:
                return _agriculture_get_listing(lid=lid, s=s)
        r = httpx.get(_agriculture_url(f"/listings/{lid}"), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.patch("/agriculture/listings/{lid}")
async def agriculture_update_listing(lid: int, req: Request):
    _require_operator(req, "agriculture")
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_agriculture_internal():
            if not _AGRICULTURE_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="agriculture internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                lreq = _AgricultureListingUpdate(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _agriculture_internal_session() as s:
                return _agriculture_update_listing(lid=lid, req=lreq, s=s)
        r = httpx.patch(_agriculture_url(f"/listings/{lid}"), json=body, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/agriculture/rfqs")
async def agriculture_create_rfq(req: Request):
    # allow buyers without auth; keep simple
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_agriculture_internal():
            if not _AGRICULTURE_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="agriculture internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                rreq = _AgricultureRFQCreate(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _agriculture_internal_session() as s:
                return _agriculture_create_rfq(req=rreq, s=s)
        r = httpx.post(_agriculture_url("/rfqs"), json=body, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/agriculture/rfqs")
def agriculture_list_rfqs(status: str = "", city: str = "", limit: int = 100):
    params = {"limit": max(1, min(limit, 200))}
    if status:
        params["status"] = status
    if city:
        params["city"] = city
    try:
        if _use_agriculture_internal():
            if not _AGRICULTURE_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="agriculture internal not available")
            with _agriculture_internal_session() as s:
                return _agriculture_list_rfqs(status=status, city=city, limit=limit, s=s)
        r = httpx.get(_agriculture_url("/rfqs"), params=params, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/agriculture/rfqs/{rid}/reply")
async def agriculture_reply_rfq(rid: int, req: Request):
    _require_operator(req, "agriculture")
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_agriculture_internal():
            if not _AGRICULTURE_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="agriculture internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                rreq = _AgricultureRFQReplyCreate(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _agriculture_internal_session() as s:
                return _agriculture_reply_rfq(rid=rid, req=rreq, s=s)
        r = httpx.post(_agriculture_url(f"/rfqs/{rid}/reply"), json=body, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/agriculture/rfqs/{rid}/replies")
def agriculture_list_rfq_replies(rid: int):
    try:
        if _use_agriculture_internal():
            if not _AGRICULTURE_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="agriculture internal not available")
            with _agriculture_internal_session() as s:
                return _agriculture_list_rfq_replies(rid=rid, s=s)
        r = httpx.get(_agriculture_url(f"/rfqs/{rid}/replies"), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/agriculture/orders")
async def agriculture_create_order(req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_agriculture_internal():
            if not _AGRICULTURE_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="agriculture internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                oreq = _AgricultureOrderCreate(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _agriculture_internal_session() as s:
                return _agriculture_create_order(req=oreq, s=s)
        r = httpx.post(_agriculture_url("/orders"), json=body, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/agriculture/orders")
def agriculture_list_orders(status: str = "", limit: int = 100):
    params = {"limit": max(1, min(limit, 200))}
    if status:
        params["status"] = status
    try:
        if _use_agriculture_internal():
            if not _AGRICULTURE_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="agriculture internal not available")
            with _agriculture_internal_session() as s:
                return _agriculture_list_orders(status=status, limit=limit, s=s)
        r = httpx.get(_agriculture_url("/orders"), params=params, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.patch("/agriculture/orders/{oid}")
async def agriculture_update_order(oid: int, req: Request):
    _require_operator(req, "agriculture")
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_agriculture_internal():
            if not _AGRICULTURE_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="agriculture internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                oreq = _AgricultureOrderUpdate(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _agriculture_internal_session() as s:
                return _agriculture_update_order(oid=oid, req=oreq, s=s)
        r = httpx.patch(_agriculture_url(f"/orders/{oid}"), json=body, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


# ---- Livestock proxies ----
@app.get("/livestock/listings")
def livestock_listings(
    q: str = "",
    city: str = "",
    species: str = "",
    breed: str = "",
    status: str = "",
    limit: int = 50,
    offset: int = 0,
    min_price: int = None,
    max_price: int = None,
    sex: str = "",
    order: str = "",
    min_weight: float = None,
    max_weight: float = None,
    negotiable: bool = None,
):
    params = {"limit": max(1, min(limit, 200))}
    if offset and offset > 0:
        params["offset"] = max(0, offset)
    if q:
        params["q"] = q
    if city:
        params["city"] = city
    if species:
        params["species"] = species
    if breed:
        params["breed"] = breed
    if status:
        params["status"] = status
    if min_price is not None:
        params["min_price"] = min_price
    if max_price is not None:
        params["max_price"] = max_price
    if min_weight is not None:
        params["min_weight"] = min_weight
    if max_weight is not None:
        params["max_weight"] = max_weight
    if sex:
        params["sex"] = sex
    if order:
        params["order"] = order
    if negotiable is not None:
        params["negotiable"] = negotiable
    try:
        if _use_livestock_internal():
            if not _LIVESTOCK_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="livestock internal not available")
            with _livestock_internal_session() as s:
                return _livestock_list_listings(
                    q=q,
                    city=city,
                    species=species,
                    breed=breed,
                    status=status,
                    limit=limit,
                    offset=offset,
                    min_price=min_price,
                    max_price=max_price,
                    sex=sex,
                    order=order,
                    min_weight=min_weight,
                    max_weight=max_weight,
                    negotiable=negotiable,
                    s=s,
                )
        r = httpx.get(_livestock_url("/listings"), params=params, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/livestock/listings_cached")
def livestock_listings_cached(limit: int = 50, response: Response = None):  # type: ignore[assignment]
    """
    Cache for a simple livestock listing list without filters.
    For q/city/species please continue to use /livestock/listings.
    """
    global _LIVESTOCK_LISTINGS_CACHE
    if limit <= 0:
        limit = 50
    if _LIVESTOCK_LISTINGS_CACHE.get("data") is not None:
        try:
            ts = float(_LIVESTOCK_LISTINGS_CACHE.get("ts") or 0.0)
        except Exception:
            ts = 0.0
        if time.time() - ts < 30.0:
            data = _LIVESTOCK_LISTINGS_CACHE.get("data")
            try:
                if response is not None:
                    response.headers.setdefault("Cache-Control", "public, max-age=30")
            except Exception:
                pass
            return data
    data = livestock_listings(q="", city="", species="", limit=limit)
    _LIVESTOCK_LISTINGS_CACHE = {"ts": time.time(), "data": data}
    try:
        if response is not None:
            response.headers.setdefault("Cache-Control", "public, max-age=30")
    except Exception:
        pass
    return data


@app.post("/livestock/listings")
async def livestock_create_listing(req: Request):
    _require_operator(req, "livestock")
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_livestock_internal():
            if not _LIVESTOCK_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="livestock internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                lreq = _LivestockListingCreate(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _livestock_internal_session() as s:
                return _livestock_create_listing(req=lreq, s=s)
        r = httpx.post(_livestock_url("/listings"), json=body, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/livestock/listings/{lid}")
def livestock_get_listing(lid: int):
    try:
        if _use_livestock_internal():
            if not _LIVESTOCK_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="livestock internal not available")
            with _livestock_internal_session() as s:
                return _livestock_get_listing(lid=lid, s=s)
        r = httpx.get(_livestock_url(f"/listings/{lid}"), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.patch("/livestock/listings/{lid}")
async def livestock_update_listing(lid: int, req: Request):
    _require_operator(req, "livestock")
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_livestock_internal():
            if not _LIVESTOCK_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="livestock internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                lreq = _LivestockListingUpdate(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _livestock_internal_session() as s:
                return _livestock_update_listing(lid=lid, req=lreq, s=s)
        r = httpx.patch(_livestock_url(f"/listings/{lid}"), json=body, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/livestock/listings/{lid}/offers")
async def livestock_create_offer(lid: int, req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_livestock_internal():
            if not _LIVESTOCK_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="livestock internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            data["listing_id"] = lid
            try:
                oreq = _LivestockOfferCreate(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _livestock_internal_session() as s:
                return _livestock_create_offer(lid=lid, req=oreq, s=s)
        r = httpx.post(_livestock_url(f"/listings/{lid}/offers"), json=body, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/livestock/listings/{lid}/offers")
def livestock_list_offers(lid: int, req: Request):
    _require_operator(req, "livestock")
    try:
        if _use_livestock_internal():
            if not _LIVESTOCK_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="livestock internal not available")
            with _livestock_internal_session() as s:
                return _livestock_list_offers(lid=lid, s=s)
        r = httpx.get(_livestock_url(f"/listings/{lid}/offers"), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.patch("/livestock/offers/{oid}")
async def livestock_update_offer(oid: int, req: Request):
    _require_operator(req, "livestock")
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_livestock_internal():
            if not _LIVESTOCK_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="livestock internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                oreq = _LivestockOfferUpdate(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _livestock_internal_session() as s:
                return _livestock_update_offer(oid=oid, req=oreq, s=s)
        r = httpx.patch(_livestock_url(f"/offers/{oid}"), json=body, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/stays/listings/search")
def stays_listings_search(q: str = "", city: str = "", type: str = "", limit: int = 50, offset: int = 0, sort_by: str = "created_at", order: str = "desc"):
    params = {"limit": max(1, min(limit, 200)), "offset": max(0, offset), "sort_by": sort_by, "order": order}
    if q:
        params["q"] = q
    if city:
        params["city"] = city
    if type:
        params["type"] = type
    try:
        if _use_stays_internal():
            if not _STAYS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="stays internal not available")
            with _stays_internal_session() as s:
                return _stays_list_listings_search(q=q, city=city, type=type, limit=limit, offset=offset, sort_by=sort_by, order=order, s=s)
        r = httpx.get(_stays_url("/listings/search"), params=params, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/stays/listings")
async def stays_create_listing(req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_stays_internal():
            if not _STAYS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="stays internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                lreq = _StaysListingCreate(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            ikey = None
            try:
                ikey = req.headers.get("Idempotency-Key")
            except Exception:
                ikey = None
            with _stays_internal_session() as s:
                return _stays_create_listing(req=lreq, idempotency_key=ikey, s=s)
        r = httpx.post(_stays_url("/listings"), json=body, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/stays/quote")
async def stays_quote(req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_stays_internal():
            if not _STAYS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="stays internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                qreq = _StaysQuoteReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _stays_internal_session() as s:
                return _stays_quote(req=qreq, s=s)
        r = httpx.post(_stays_url("/quote"), json=body, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/stays/book")
async def stays_book(req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    headers: dict[str, str] = {}
    try:
        ikey = req.headers.get("Idempotency-Key")
    except Exception:
        ikey = None
    if ikey:
        headers["Idempotency-Key"] = ikey
    try:
        if _use_stays_internal():
            if not _STAYS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="stays internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                breq = _StaysBookReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _stays_internal_session() as s:
                return _stays_book(req=breq, idempotency_key=ikey, s=s)
        r = httpx.post(_stays_url("/book"), json=body, headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/stays/bookings/{bid}")
def stays_get_booking(bid: str):
    try:
        if _use_stays_internal():
            if not _STAYS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="stays internal not available")
            with _stays_internal_session() as s:
                return _stays_get_booking(booking_id=bid, s=s)
        r = httpx.get(_stays_url(f"/bookings/{bid}"), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


# -- Stays operators (hotels)
@app.post("/stays/operators")
async def stays_create_operator(req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    headers: dict[str, str] = {}
    try:
        ikey = req.headers.get("Idempotency-Key")
    except Exception:
        ikey = None
    if ikey:
        headers["Idempotency-Key"] = ikey
    try:
        if _use_stays_internal():
            if not _STAYS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="stays internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                oreq = _StaysOperatorCreate(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _stays_internal_session() as s:
                return _stays_create_operator(req=oreq, idempotency_key=ikey, s=s)
        r = httpx.post(_stays_url("/operators"), json=body, headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/stays/operators/{op_id}")
def stays_get_operator(op_id: int):
    try:
        if _use_stays_internal():
            if not _STAYS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="stays internal not available")
            with _stays_internal_session() as s:
                return _stays_get_operator(op_id=op_id, s=s)
        r = httpx.get(_stays_url(f"/operators/{op_id}"), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/stays/operators/{op_id}/listings")
def stays_operator_listings(op_id: int, req: Request, limit: int = 50, offset: int = 0, q: str = "", city: str = ""):
    try:
        params = {"limit": max(1, min(limit, 200)), "offset": max(0, offset)}
        if q:
            params["q"] = q
        if city:
            params["city"] = city
        if _use_stays_internal():
            if not _STAYS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="stays internal not available")
            property_id = None
            try:
                pid = req.query_params.get("property_id")
                if pid:
                    property_id = int(pid)
            except Exception:
                property_id = None
            with _stays_internal_session() as s:
                return _stays_operator_listings(
                    op_id=op_id,
                    request=req,
                    limit=limit,
                    offset=offset,
                    q=q,
                    city=city,
                    property_id=property_id,
                    s=s,
                )
        headers: dict[str, str] = {}
        try:
            auth = req.headers.get("authorization")
            if auth:
                headers["Authorization"] = auth
        except Exception:
            pass
        r = httpx.get(_stays_url(f"/operators/{op_id}/listings"), params=params, headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/stays/operators/{op_id}/listings")
async def stays_operator_create_listing(op_id: int, req: Request):
    _require_operator(req, "stays")
    try:
        body = await req.json()
    except Exception:
        body = {}
    body = body or {}
    body.setdefault("operator_id", op_id)
    try:
        headers: dict[str, str] = {}
        try:
            auth = req.headers.get("authorization")
            if auth:
                headers["Authorization"] = auth
        except Exception:
            pass
        if _use_stays_internal():
            if not _STAYS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="stays internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                lreq = _StaysListingCreate(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _stays_internal_session() as s:
                return _stays_operator_create_listing(op_id=op_id, req=lreq, request=req, s=s)
        r = httpx.post(_stays_url(f"/operators/{op_id}/listings"), json=body, headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.patch("/stays/operators/{op_id}/listings/{lid}")
async def stays_operator_update_listing(op_id: int, lid: int, req: Request):
    _require_operator(req, "stays")
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        headers: dict[str, str] = {}
        try:
            auth = req.headers.get("authorization")
            if auth:
                headers["Authorization"] = auth
        except Exception:
            pass
        if _use_stays_internal():
            if not _STAYS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="stays internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                ureq = _StaysListingUpdate(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _stays_internal_session() as s:
                return _stays_operator_update_listing(op_id=op_id, lid=lid, req=ureq, request=req, s=s)
        r = httpx.patch(_stays_url(f"/operators/{op_id}/listings/{lid}"), json=body, headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.delete("/stays/operators/{op_id}/listings/{lid}")
def stays_operator_delete_listing(op_id: int, lid: int, req: Request):
    _require_operator(req, "stays")
    try:
        if _use_stays_internal():
            if not _STAYS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="stays internal not available")
            with _stays_internal_session() as s:
                return _stays_operator_delete_listing(op_id=op_id, lid=lid, request=req, s=s)
        headers: dict[str, str] = {}
        try:
            auth = req.headers.get("authorization")
            if auth:
                headers["Authorization"] = auth
        except Exception:
            pass
        r = httpx.delete(_stays_url(f"/operators/{op_id}/listings/{lid}"), headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/stays/operators/{op_id}/bookings")
def stays_operator_bookings(op_id: int, req: Request, limit: int = 50, offset: int = 0):
    _require_operator(req, "stays")
    try:
        headers: dict[str, str] = {}
        try:
            auth = req.headers.get("authorization")
            if auth:
                headers["Authorization"] = auth
        except Exception:
            pass
        params = {"limit": max(1, min(limit, 200)), "offset": max(0, offset)}
        if _use_stays_internal():
            if not _STAYS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="stays internal not available")
            with _stays_internal_session() as s:
                return _stays_operator_bookings(op_id=op_id, request=req, limit=limit, offset=offset, s=s)
        r = httpx.get(_stays_url(f"/operators/{op_id}/bookings"), params=params, headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))
@app.get("/stays/operators/{op_id}/bookings/search")
def stays_operator_bookings_search(op_id: int, req: Request, limit: int = 50, offset: int = 0, sort_by: str = "created_at", order: str = "desc", status: str = "", from_iso: str = "", to_iso: str = ""):
    _require_operator(req, "stays")
    try:
        headers: dict[str, str] = {}
        try:
            auth = req.headers.get("authorization")
            if auth:
                headers["Authorization"] = auth
        except Exception:
            pass
        params = {"limit": max(1, min(limit, 200)), "offset": max(0, offset), "sort_by": sort_by, "order": order}
        if status:
            params["status"] = status
        if from_iso:
            params["from_iso"] = from_iso
        if to_iso:
            params["to_iso"] = to_iso
        if _use_stays_internal():
            if not _STAYS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="stays internal not available")
            property_id = None
            try:
                pid = req.query_params.get("property_id")
                if pid:
                    property_id = int(pid)
            except Exception:
                property_id = None
            with _stays_internal_session() as s:
                return _stays_operator_bookings_search(
                    op_id=op_id,
                    request=req,
                    limit=limit,
                    offset=offset,
                    sort_by=sort_by,
                    order=order,
                    status=status,
                    from_iso=from_iso,
                    to_iso=to_iso,
                    s=s,
                )
        try:
            pid = req.query_params.get("property_id")
            if pid:
                params["property_id"] = pid
        except Exception:
            pass
        r = httpx.get(_stays_url(f"/operators/{op_id}/bookings/search"), params=params, headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/stays/operators/{op_id}/bookings/{bid}/status")
async def stays_operator_update_booking_status(op_id: int, bid: str, req: Request):
    _require_operator(req, "stays")
    try:
        try:
            body = await req.json()
        except Exception:
            body = None
        headers: dict[str, str] = {}
        try:
            auth = req.headers.get("authorization")
            if auth:
                headers["Authorization"] = auth
        except Exception:
            pass
        if _use_stays_internal():
            if not _STAYS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="stays internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                sreq = _StaysBookingStatusUpdate(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _stays_internal_session() as s:
                return _stays_operator_update_booking_status(op_id=op_id, bid=bid, req=sreq, request=req, s=s)
        r = httpx.post(_stays_url(f"/operators/{op_id}/bookings/{bid}/status"), json=body, headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


# ---- RealEstate proxies ----
def _re_url(path: str) -> str:
    if not REALESTATE_BASE:
        raise HTTPException(status_code=500, detail="REALESTATE_BASE_URL not configured")
    return REALESTATE_BASE.rstrip("/") + path


# --- RealEstate internal service (monolith mode) ---
_RE_INTERNAL_AVAILABLE = False
try:
    from sqlalchemy.orm import Session as _ReSession  # type: ignore[import]
    from apps.realestate.app import main as _re_main  # type: ignore[import]
    from apps.realestate.app.main import (  # type: ignore[import]
        engine as _re_engine,
        PropertyCreate as _RePropertyCreate,
        PropertyUpdate as _RePropertyUpdate,
        PropertyOut as _RePropertyOut,
        InquiryCreate as _ReInquiryCreate,
        ReserveReq as _ReReserveReq,
        create_property as _re_create_property,
        list_properties as _re_list_properties,
        get_property as _re_get_property,
        update_property as _re_update_property,
        delete_property as _re_delete_property,
        create_inquiry as _re_create_inquiry,
        reserve as _re_reserve,
    )
    _RE_INTERNAL_AVAILABLE = True
except Exception:
    _ReSession = None  # type: ignore[assignment]
    _re_engine = None  # type: ignore[assignment]
    _RE_INTERNAL_AVAILABLE = False


def _use_re_internal() -> bool:
    if _force_internal(_RE_INTERNAL_AVAILABLE):
        return True
    mode = os.getenv("REALESTATE_INTERNAL_MODE", "auto").lower()
    if mode == "off":
        return False
    if not _RE_INTERNAL_AVAILABLE:
        return False
    if mode == "on":
        return True
    return not bool(REALESTATE_BASE)


def _re_internal_session():
    if not _RE_INTERNAL_AVAILABLE or _ReSession is None or _re_engine is None:  # type: ignore[truthy-function]
        raise RuntimeError("RealEstate internal service not available")
    return _ReSession(_re_engine)  # type: ignore[call-arg]


@app.get("/realestate/properties")
def re_list_properties(q: str = "", city: str = "", min_price: str = "", max_price: str = "", min_bedrooms: str = "", limit: int = 20):
    params = {"limit": max(1, min(limit, 100))}
    if q: params["q"] = q
    if city: params["city"] = city
    def _to_int(val: str) -> Optional[int]:
        try:
            if val is None or val == "":
                return None
            return int(val)
        except Exception:
            return None
    min_p_in = _to_int(min_price)
    max_p_in = _to_int(max_price)
    min_beds_in = _to_int(min_bedrooms)
    if min_p_in is not None: params["min_price"] = min_p_in
    if max_p_in is not None: params["max_price"] = max_p_in
    if min_beds_in is not None: params["min_bedrooms"] = min_beds_in
    try:
        if _use_re_internal():
            if not _RE_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="realestate internal not available")
            # convert sentinel 0 to None for optional filters
            min_p = None if not min_p_in or min_p_in <= 0 else min_p_in
            max_p = None if not max_p_in or max_p_in <= 0 else max_p_in
            min_beds = None if not min_beds_in or min_beds_in <= 0 else min_beds_in
            with _re_internal_session() as s:
                return _re_list_properties(q=q, city=city, min_price=min_p, max_price=max_p, min_bedrooms=min_beds, limit=limit, s=s)
        r = httpx.get(_re_url("/properties"), params=params, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/realestate/properties")
async def re_create_property(req: Request):
    _require_operator(req, "realestate")
    try:
        body = await req.json()
    except Exception:
        body = None
    headers: dict[str, str] = {}
    try:
        ikey = req.headers.get("Idempotency-Key")
    except Exception:
        ikey = None
    if ikey:
        headers["Idempotency-Key"] = ikey
    try:
        if _use_re_internal():
            if not _RE_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="realestate internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                preq = _RePropertyCreate(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _re_internal_session() as s:
                return _re_create_property(req=preq, idempotency_key=ikey, s=s)
        r = httpx.post(_re_url("/properties"), json=body, headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/realestate/properties/{pid}")
def re_get_property(pid: int):
    try:
        if _use_re_internal():
            if not _RE_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="realestate internal not available")
            with _re_internal_session() as s:
                return _re_get_property(pid=pid, s=s)
        r = httpx.get(_re_url(f"/properties/{pid}"), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/realestate/properties/{pid}")
async def re_update_property(pid: int, req: Request):
    _require_operator(req, "realestate")
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_re_internal():
            if not _RE_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="realestate internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                ureq = _RePropertyUpdate(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _re_internal_session() as s:
                return _re_update_property(pid=pid, req=ureq, s=s)
        r = httpx.patch(_re_url(f"/properties/{pid}"), json=body, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/realestate/inquiries")
async def re_create_inquiry(req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    headers: dict[str, str] = {}
    try:
        ikey = req.headers.get("Idempotency-Key")
    except Exception:
        ikey = None
    if ikey:
        headers["Idempotency-Key"] = ikey
    try:
        if _use_re_internal():
            if not _RE_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="realestate internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                ireq = _ReInquiryCreate(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _re_internal_session() as s:
                return _re_create_inquiry(req=ireq, idempotency_key=ikey, s=s)
        r = httpx.post(_re_url("/inquiries"), json=body, headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/realestate/reserve")
async def re_reserve(req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    headers: dict[str, str] = {}
    try:
        ikey = req.headers.get("Idempotency-Key")
    except Exception:
        ikey = None
    if ikey:
        headers["Idempotency-Key"] = ikey
    try:
        if _use_re_internal():
            if not _RE_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="realestate internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                rreq = _ReReserveReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _re_internal_session() as s:
                return _re_reserve(req=rreq, idempotency_key=ikey, s=s)
        r = httpx.post(_re_url("/reserve"), json=body, headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


# ---- Food proxies (internal-only) ----
# --- Food internal service (monolith mode) ---
_FOOD_INTERNAL_AVAILABLE = False
try:
    from sqlalchemy.orm import Session as _FoodSession  # type: ignore[import]
    from apps.food.app import main as _food_main  # type: ignore[import]
    from apps.food.app.main import (  # type: ignore[import]
        engine as _food_engine,
        get_session as _food_get_session,
        RestaurantCreate as _FoodRestaurantCreate,
        MenuItemCreate as _FoodMenuItemCreate,
        OrderCreate as _FoodOrderCreate,
        StatusReq as _FoodStatusReq,
        RestaurantOut as _FoodRestaurantOut,
        OrderOut as _FoodOrderOut,
        create_restaurant as _food_create_restaurant,
        list_restaurants as _food_list_restaurants,
        get_restaurant as _food_get_restaurant,
        get_menu as _food_get_menu,
        create_menu_item as _food_create_menuitem,
        create_order as _food_create_order,
        get_order as _food_get_order,
        set_status as _food_set_status,
        list_orders as _food_list_orders,
        EscrowReleaseReq as _FoodEscrowReleaseReq,
        escrow_release as _food_escrow_release,
    )
    _FOOD_INTERNAL_AVAILABLE = True
except Exception:
    _FoodSession = None  # type: ignore[assignment]
    _food_main = None  # type: ignore[assignment]
    _food_engine = None  # type: ignore[assignment]
    _FOOD_INTERNAL_AVAILABLE = False


def _use_food_internal() -> bool:
    if _force_internal(_FOOD_INTERNAL_AVAILABLE):
        return True
    if not _FOOD_INTERNAL_AVAILABLE:
        return False
    mode = os.getenv("FOOD_INTERNAL_MODE", "on").lower()
    return mode != "off"


def _food_internal_session():
    if not _FOOD_INTERNAL_AVAILABLE or _FoodSession is None or _food_engine is None:  # type: ignore[truthy-function]
        raise RuntimeError("Food internal service not available")
    return _FoodSession(_food_engine)  # type: ignore[call-arg]


@app.get("/food/restaurants")
def food_restaurants(q: str = "", city: str = "", limit: int = 50):
    params = {"limit": max(1, min(limit,200))}
    if q: params["q"] = q
    if city: params["city"] = city
    if not _use_food_internal() or not _FOOD_INTERNAL_AVAILABLE:
        raise HTTPException(status_code=500, detail="food internal not available")
    with _food_internal_session() as s:
        return _food_list_restaurants(q=q, city=city, limit=limit, s=s)  # type: ignore[arg-type]


@app.post("/food/restaurants")
async def food_create_restaurant(req: Request):
    _require_operator(req, "food")
    try:
        body = await req.json()
    except Exception:
        body = None
    if not _use_food_internal() or not _FOOD_INTERNAL_AVAILABLE:
        raise HTTPException(status_code=500, detail="food internal not available")
    data = body or {}
    if not isinstance(data, dict):
        data = {}
    try:
        rc = _FoodRestaurantCreate(**data)
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))
    with _food_internal_session() as s:
        return _food_create_restaurant(req=rc, s=s)


@app.get("/food/restaurants/{rid}")
def food_get_restaurant(rid: int):
    if not _use_food_internal() or not _FOOD_INTERNAL_AVAILABLE:
        raise HTTPException(status_code=500, detail="food internal not available")
    with _food_internal_session() as s:
        return _food_get_restaurant(rid=rid, s=s)


@app.get("/food/restaurants/{rid}/menu")
def food_get_menu(rid: int):
    if not _use_food_internal() or not _FOOD_INTERNAL_AVAILABLE:
        raise HTTPException(status_code=500, detail="food internal not available")
    with _food_internal_session() as s:
        return _food_get_menu(rid=rid, s=s)


@app.post("/food/menuitems")
async def food_create_menuitem(req: Request):
    _require_operator(req, "food")
    try:
        body = await req.json()
    except Exception:
        body = None
    if not _use_food_internal() or not _FOOD_INTERNAL_AVAILABLE:
        raise HTTPException(status_code=500, detail="food internal not available")
    data = body or {}
    if not isinstance(data, dict):
        data = {}
    try:
        mi = _FoodMenuItemCreate(**data)
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))
    with _food_internal_session() as s:
        return _food_create_menuitem(req=mi, s=s)


@app.post("/food/orders")
async def food_create_order(req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    headers = {}
    try:
        ikey = req.headers.get("Idempotency-Key")
    except Exception:
        ikey = None
    if ikey:
        headers["Idempotency-Key"] = ikey
    if not _use_food_internal() or not _FOOD_INTERNAL_AVAILABLE:
        raise HTTPException(status_code=500, detail="food internal not available")
    data = body or {}
    if not isinstance(data, dict):
        data = {}
    try:
        oc = _FoodOrderCreate(**data)
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))
    with _food_internal_session() as s:
        return _food_create_order(req=oc, idempotency_key=ikey, s=s)


@app.get("/food/orders")
def food_list_orders(phone: str = "", limit: int = 50, status: str = "", from_iso: str = "", to_iso: str = ""):
    if not _use_food_internal() or not _FOOD_INTERNAL_AVAILABLE:
        raise HTTPException(status_code=500, detail="food internal not available")
    with _food_internal_session() as s:
        return _food_list_orders(phone=phone, status=status, from_iso=from_iso, to_iso=to_iso, limit=limit, s=s)


@app.get("/food/orders/{oid}")
def food_get_order(oid: str):
    if not _use_food_internal() or not _FOOD_INTERNAL_AVAILABLE:
        raise HTTPException(status_code=500, detail="food internal not available")
    with _food_internal_session() as s:
        return _food_get_order(oid=oid, s=s)


@app.post("/food/orders/{oid}/status")
async def food_set_status(oid: str, req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    if not _use_food_internal() or not _FOOD_INTERNAL_AVAILABLE:
        raise HTTPException(status_code=500, detail="food internal not available")
    data = body or {}
    if not isinstance(data, dict):
        data = {}
    try:
        sreq = _FoodStatusReq(**data)
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))
    with _food_internal_session() as s:
        return _food_set_status(oid=oid, req=sreq, s=s)


@app.post("/food/orders/{oid}/escrow_release")
async def food_escrow_release(oid: str, req: Request):
    """
    Proxy for releasing escrow on a Food order after the customer
    has scanned the courier's delivery QR code.
    """
    try:
        body = await req.json()
    except Exception:
        body = None
    if not _use_food_internal() or not _FOOD_INTERNAL_AVAILABLE:
        raise HTTPException(status_code=500, detail="food internal not available")
    data = body or {}
    if not isinstance(data, dict):
        data = {}
    try:
        ereq = _FoodEscrowReleaseReq(**data)
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))
    with _food_internal_session() as s:
        return _food_escrow_release(oid=oid, req=ereq, s=s)


@app.get("/food/orders/{oid}/escrow_qr")
def food_escrow_qr(oid: str):
    """
    Generate a QR code (PNG) for a Food order escrow token.
    The QR payload is a compact text format consumed by the
    Shamell app: FOOD_ESCROW|order_id=...|token=...
    """
    if not _use_food_internal() or not _FOOD_INTERNAL_AVAILABLE:
        raise HTTPException(status_code=500, detail="food internal not available")
    with _food_internal_session() as s:
        o = _food_get_order(oid=oid, s=s)
        try:
            od = o.dict() if hasattr(o, "dict") else o  # type: ignore[assignment]
        except Exception:
            od = {}

    if not isinstance(od, dict):
        raise HTTPException(status_code=502, detail="invalid order payload from food service")
    token = (od.get("escrow_token") or "").strip()
    if not token:
        raise HTTPException(status_code=400, detail="order has no escrow token")
    try:
        from urllib.parse import quote

        payload = "FOOD_ESCROW|order_id=" + oid + "|token=" + quote(token, safe="")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"failed to build QR payload: {e}")
    # Reuse generic QR PNG endpoint.
    return qr_png(payload)


# ---- Carrental proxies ----
def _carrental_url(path: str) -> str:
    if not CARRENTAL_BASE:
        raise HTTPException(status_code=500, detail="CARRENTAL_BASE_URL not configured")
    return CARRENTAL_BASE.rstrip("/") + path


# --- Carrental internal service (monolith mode) ---
_CARRENTAL_INTERNAL_AVAILABLE = False
try:
    from sqlalchemy.orm import Session as _CarrentalSession  # type: ignore[import]
    from apps.carrental.app import main as _carrental_main  # type: ignore[import]
    from apps.carrental.app.main import (  # type: ignore[import]
        engine as _carrental_engine,
        get_session as _carrental_get_session,
        CarCreate as _CarrentalCarCreate,
        CarUpdate as _CarrentalCarUpdate,
        CarOut as _CarrentalCarOut,
        QuoteReq as _CarrentalQuoteReq,
        QuoteOut as _CarrentalQuoteOut,
        BookReq as _CarrentalBookReq,
        BookingOut as _CarrentalBookingOut,
        ConfirmReq as _CarrentalConfirmReq,
        create_car as _carrental_create_car,
        list_cars as _carrental_list_cars,
        get_car as _carrental_get_car,
        update_car as _carrental_update_car,
        delete_car as _carrental_delete_car,
        quote as _carrental_quote,
        book as _carrental_book,
        get_booking as _carrental_get_booking,
        list_bookings as _carrental_list_bookings,
        confirm_booking as _carrental_confirm_booking,
        cancel_booking as _carrental_cancel_booking,
        admin_cars_export as _carrental_admin_cars_export,
        admin_bookings_export as _carrental_admin_bookings_export,
    )
    _CARRENTAL_INTERNAL_AVAILABLE = True
except Exception:
    _CarrentalSession = None  # type: ignore[assignment]
    _carrental_engine = None  # type: ignore[assignment]
    _CARRENTAL_INTERNAL_AVAILABLE = False


def _use_carrental_internal() -> bool:
    if _force_internal(_CARRENTAL_INTERNAL_AVAILABLE):
        return True
    mode = os.getenv("CARRENTAL_INTERNAL_MODE", "auto").lower()
    if mode == "off":
        return False
    if not _CARRENTAL_INTERNAL_AVAILABLE:
        return False
    if mode == "on":
        return True
    return not bool(CARRENTAL_BASE)


def _carrental_internal_session():
    if not _CARRENTAL_INTERNAL_AVAILABLE or _CarrentalSession is None or _carrental_engine is None:  # type: ignore[truthy-function]
        raise RuntimeError("Carrental internal service not available")
    return _CarrentalSession(_carrental_engine)  # type: ignore[call-arg]


@app.get("/carrental/cars")
def cr_list_cars(
    q: str = "",
    city: str = "",
    dropoff_city: str = "",
    make: str = "",
    transmission: str = "",
    fuel: str = "",
    car_class: str = "",
    max_price: int = None,
    min_seats: int = None,
    free_cancel: bool = None,
    unlimited_mileage: bool = None,
    limit: int = 20,
):
    params = {"limit": max(1, min(limit, 100))}
    if q:
        params["q"] = q
    if city:
        params["city"] = city
    if dropoff_city:
        params["dropoff_city"] = dropoff_city
    if make:
        params["make"] = make
    if transmission:
        params["transmission"] = transmission
    if fuel:
        params["fuel"] = fuel
    if car_class:
        params["car_class"] = car_class
    if max_price is not None:
        params["max_price"] = max_price
    if min_seats is not None:
        params["min_seats"] = min_seats
    if free_cancel is not None:
        params["free_cancel"] = free_cancel
    if unlimited_mileage is not None:
        params["unlimited_mileage"] = unlimited_mileage
    try:
        if _use_carrental_internal():
            if not _CARRENTAL_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="carrental internal not available")
            with _carrental_internal_session() as s:
                return _carrental_list_cars(
                    q=q,
                    city=city,
                    dropoff_city=dropoff_city,
                    make=make,
                    transmission=transmission,
                    fuel=fuel,
                    car_class=car_class,
                    max_price=max_price,
                    min_seats=min_seats,
                    free_cancel=free_cancel,
                    unlimited_mileage=unlimited_mileage,
                    limit=limit,
                    s=s,
                )
        r = httpx.get(_carrental_url("/cars"), params=params, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/carrental/cars")
async def cr_create_car(req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_carrental_internal():
            if not _CARRENTAL_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="carrental internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                creq = _CarrentalCarCreate(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _carrental_internal_session() as s:
                return _carrental_create_car(req=creq, s=s)
        r = httpx.post(_carrental_url("/cars"), json=body, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/carrental/cars/{car_id}")
def cr_get_car(car_id: int):
    try:
        if _use_carrental_internal():
            if not _CARRENTAL_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="carrental internal not available")
            with _carrental_internal_session() as s:
                return _carrental_get_car(car_id=car_id, s=s)
        r = httpx.get(_carrental_url(f"/cars/{car_id}"), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/carrental/quote")
async def cr_quote(req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_carrental_internal():
            if not _CARRENTAL_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="carrental internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                qreq = _CarrentalQuoteReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _carrental_internal_session() as s:
                return _carrental_quote(req=qreq, s=s)
        r = httpx.post(_carrental_url("/quote"), json=body, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/carrental/book")
async def cr_book(req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    headers: dict[str, str] = {}
    try:
        ikey = req.headers.get("Idempotency-Key")
    except Exception:
        ikey = None
    if ikey:
        headers["Idempotency-Key"] = ikey
    try:
        if _use_carrental_internal():
            if not _CARRENTAL_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="carrental internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                breq = _CarrentalBookReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _carrental_internal_session() as s:
                return _carrental_book(req=breq, idempotency_key=ikey, s=s)
        r = httpx.post(_carrental_url("/book"), json=body, headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/carrental/bookings/{booking_id}")
def cr_get_booking(booking_id: str):
    try:
        if _use_carrental_internal():
            if not _CARRENTAL_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="carrental internal not available")
            with _carrental_internal_session() as s:
                return _carrental_get_booking(booking_id=booking_id, s=s)
        r = httpx.get(_carrental_url(f"/bookings/{booking_id}"), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/carrental/bookings/{booking_id}/cancel")
def cr_cancel_booking(booking_id: str):
    try:
        if _use_carrental_internal():
            if not _CARRENTAL_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="carrental internal not available")
            with _carrental_internal_session() as s:
                return _carrental_cancel_booking(booking_id=booking_id, s=s)
        r = httpx.post(_carrental_url(f"/bookings/{booking_id}/cancel"), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/carrental/bookings/{booking_id}/confirm")
async def cr_confirm_booking(booking_id: str, req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_carrental_internal():
            if not _CARRENTAL_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="carrental internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                creq = _CarrentalConfirmReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _carrental_internal_session() as s:
                return _carrental_confirm_booking(booking_id=booking_id, req=creq, s=s)
        r = httpx.post(_carrental_url(f"/bookings/{booking_id}/confirm"), json=body, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/carrental/bookings")
def cr_list_bookings(status: str = "", limit: int = 100):
    params = {"limit": max(1, min(limit, 500))}
    if status:
        params["status"] = status
    try:
        if _use_carrental_internal():
            if not _CARRENTAL_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="carrental internal not available")
            with _carrental_internal_session() as s:
                return _carrental_list_bookings(status=status, limit=limit, s=s)
        r = httpx.get(_carrental_url("/bookings"), params=params, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/carrental/admin/cars/export")
def cr_export_cars(request: Request):
    _require_operator(request, "carrental")
    try:
        if _use_carrental_internal():
            if not _CARRENTAL_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="carrental internal not available")
            with _carrental_internal_session() as s:
                return _carrental_admin_cars_export(s=s)
        r = httpx.get(_carrental_url("/admin/cars/export"), timeout=None)
        disp = r.headers.get("content-disposition", "attachment; filename=cars.csv")
        return Response(content=r.content, media_type="text/csv", headers={"Content-Disposition": disp})
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/carrental/admin/bookings/export")
def cr_export_bookings(request: Request, status: str = "", limit: int = 1000):
    _require_operator(request, "carrental")
    params = {"limit": max(1, min(limit, 5000))}
    if status:
        params["status"] = status
    try:
        if _use_carrental_internal():
            if not _CARRENTAL_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="carrental internal not available")
            with _carrental_internal_session() as s:
                return _carrental_admin_bookings_export(status=status, limit=limit, s=s)
        r = httpx.get(_carrental_url("/admin/bookings/export"), params=params, timeout=None)
        disp = r.headers.get("content-disposition", "attachment; filename=bookings.csv")
        return Response(content=r.content, media_type="text/csv", headers={"Content-Disposition": disp})
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


# ---- Equipment proxies ----
def _equipment_url(path: str) -> str:
    if not EQUIPMENT_BASE:
        raise HTTPException(status_code=500, detail="EQUIPMENT_BASE_URL not configured")
    return EQUIPMENT_BASE.rstrip("/") + path


_EQUIPMENT_INTERNAL_AVAILABLE = False
try:
    from sqlalchemy.orm import Session as _EquipmentSession  # type: ignore[import]
    from apps.equipment.app import main as _equipment_main  # type: ignore[import]
    from apps.equipment.app.main import (  # type: ignore[import]
        engine as _equipment_engine,
        get_session as _equipment_get_session,
        EquipmentCreate as _EquipmentCreate,
        EquipmentUpdate as _EquipmentUpdate,
        EquipmentOut as _EquipmentOut,
        QuoteReq as _EquipmentQuoteReq,
        QuoteOut as _EquipmentQuoteOut,
        BookReq as _EquipmentBookReq,
        BookingOut as _EquipmentBookingOut,
        BookingStatusUpdate as _EquipmentStatusUpdate,
        TaskUpdate as _EquipmentTaskUpdate,
        create_asset as _equipment_create_asset,
        list_assets as _equipment_list_assets,
        get_asset as _equipment_get_asset,
        update_asset as _equipment_update_asset,
        delete_asset as _equipment_delete_asset,
        quote as _equipment_quote,
        book as _equipment_book,
        list_bookings as _equipment_list_bookings,
        get_booking as _equipment_get_booking,
        update_booking_status as _equipment_update_booking_status,
        update_logistics as _equipment_update_logistics,
        analytics_summary as _equipment_analytics,
        dashboard as _equipment_dashboard,
    )
    _EQUIPMENT_INTERNAL_AVAILABLE = True
except Exception:
    _EquipmentSession = None  # type: ignore[assignment]
    _equipment_engine = None  # type: ignore[assignment]
    _EQUIPMENT_INTERNAL_AVAILABLE = False


def _use_equipment_internal() -> bool:
    if _force_internal(_EQUIPMENT_INTERNAL_AVAILABLE):
        return True
    mode = os.getenv("EQUIPMENT_INTERNAL_MODE", "auto").lower()
    if mode == "off":
        return False
    if not _EQUIPMENT_INTERNAL_AVAILABLE:
        return False
    if mode == "on":
        return True
    return not bool(EQUIPMENT_BASE)


def _equipment_internal_session():
    if not _EQUIPMENT_INTERNAL_AVAILABLE or _EquipmentSession is None or _equipment_engine is None:  # type: ignore[truthy-function]
        raise RuntimeError("Equipment internal service not available")
    return _EquipmentSession(_equipment_engine)  # type: ignore[call-arg]


@app.get("/equipment", response_class=HTMLResponse)
def equipment_page(request: Request):
    if not _auth_phone(request):
        return RedirectResponse(url="/login", status_code=303)
    html = """
<!doctype html>
<html><head><meta name=viewport content="width=device-width, initial-scale=1" />
<title>Equipment</title>
<link rel="icon" href="/icons/equipment.svg" />
<style>
  body{font-family:sans-serif;margin:20px;max-width:1100px;background:#ffffff;color:#000000;}
  header{position:sticky;top:0;z-index:10;background:#ffffff;padding:8px 10px;border-bottom:1px solid #dddddd;margin:0 0 12px 0;display:flex;align-items:center;gap:8px}
  header h1{flex:1;font-size:20px;margin:0}
  button{font-size:14px;padding:8px 10px;border-radius:10px;border:1px solid #cccccc;background:#f3f4f6;color:#000000}
  input,select{font-size:14px;padding:8px 10px;border-radius:10px;border:1px solid #cccccc}
  table{border-collapse:collapse;width:100%}
  th,td{border:1px solid #e5e7eb;padding:8px;text-align:left;font-size:13px}
  th{background:#f8fafc}
  .card{border-radius:12px;border:1px solid #e5e7eb;padding:12px;background:#ffffff;margin-top:12px}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .muted{opacity:.7;font-size:12px}
  pre{background:#f5f5f5;padding:10px;white-space:pre-wrap;border-radius:10px;border:1px solid #e5e7eb}
  .link{color:#2563eb;text-decoration:underline;cursor:pointer}
  @media(max-width:820px){ body{margin:12px;} th,td{font-size:12px;} }
  /* prevent DS auto-bg override */
  body[data-bg="simple"]{background:#ffffff}
  .badge{display:inline-flex;align-items:center;padding:2px 8px;border-radius:999px;border:1px solid #e5e7eb;background:#f8fafc;font-size:12px}
  .ok{color:#15803d}
  .warn{color:#b45309}
</style>
</head><body data-bg="simple">
<header>
  <h1>Equipment</h1>
  <button onclick="loadAssets()">Refresh</button>
</header>

<section class="card">
  <h2 style="margin:0 0 8px 0;">Browse</h2>
  <div class="row">
    <input id="q" placeholder="Search title…" style="flex:1;min-width:220px" />
    <input id="city" placeholder="City" style="min-width:160px" />
    <input id="category" placeholder="Category" style="min-width:160px" />
    <label class="badge"><input id="avail" type="checkbox" style="margin-right:6px" /> Available only</label>
    <button onclick="loadAssets()">Search</button>
  </div>
  <div id="cnt" class="muted" style="margin-top:8px;">Loading…</div>
  <div style="overflow:auto;margin-top:10px">
    <table id="tbl">
      <thead><tr><th>ID</th><th>Title</th><th>City</th><th>Category</th><th>Daily</th><th>Avail</th><th>Status</th></tr></thead>
      <tbody></tbody>
    </table>
  </div>
</section>

<section class="card">
  <h2 style="margin:0 0 8px 0;">Details / Quote</h2>
  <div class="row">
    <input id="eid" placeholder="equipment_id" style="min-width:160px" />
    <input id="from" placeholder="from_iso (YYYY-MM-DDTHH:MM:SSZ)" style="flex:1;min-width:220px" />
    <input id="to" placeholder="to_iso (YYYY-MM-DDTHH:MM:SSZ)" style="flex:1;min-width:220px" />
    <input id="qty" placeholder="qty" value="1" style="width:90px" />
    <button onclick="loadOne()">Load</button>
    <button onclick="quote()">Quote</button>
    <button onclick="book()">Book</button>
  </div>
  <div class="muted" style="margin-top:6px;">Tip: tap a row above to prefill equipment_id.</div>
  <pre id="detail_out" style="margin-top:10px;"></pre>
  <pre id="quote_out" style="margin-top:10px;"></pre>
  <pre id="book_out" style="margin-top:10px;"></pre>
</section>

<script>
function gi(id){ return (document.getElementById(id).value || '').trim(); }
function setv(id, v){ try{ document.getElementById(id).value = v; }catch(_){ } }
function fmtMoney(cents, cur){
  if(cents === null || cents === undefined) return '—';
  const n = Number(cents);
  if(Number.isNaN(n)) return '—';
  return n + ' ' + (cur || '');
}
function safeText(s){ return (s===null||s===undefined) ? '' : (''+s); }
async function fetchJson(url, opts){
  const r = await fetch(url, opts);
  const t = await r.text();
  try{ return {ok:r.ok, status:r.status, json: JSON.parse(t), text:t}; }catch(_){ return {ok:r.ok, status:r.status, json:null, text:t}; }
}
async function loadAssets(){
  const params = new URLSearchParams();
  const q = gi('q'); const city = gi('city'); const cat = gi('category');
  if(q) params.set('q', q);
  if(city) params.set('city', city);
  if(cat) params.set('category', cat);
  if(document.getElementById('avail').checked) params.set('available_only', 'true');
  params.set('limit','80');
  const url = '/equipment/assets?' + params.toString();
  const cnt = document.getElementById('cnt');
  const tb = document.querySelector('#tbl tbody');
  cnt.textContent = 'Loading…';
  tb.innerHTML = '';
  const res = await fetchJson(url);
  if(!res.ok){
    cnt.textContent = 'Error ' + res.status;
    tb.innerHTML = '<tr><td colspan=\"7\"><pre>' + safeText(res.text) + '</pre></td></tr>';
    return;
  }
  const arr = Array.isArray(res.json) ? res.json : [];
  cnt.textContent = arr.length + ' results';
  for(const x of arr){
    const tr = document.createElement('tr');
    tr.style.cursor = 'pointer';
    tr.onclick = ()=>{ setv('eid', x.id); loadOne(); };
    const daily = fmtMoney(x.daily_rate_cents, x.currency);
    const avail = (x.available_quantity !== null && x.available_quantity !== undefined) ? (''+x.available_quantity) : '—';
    tr.innerHTML = '<td>' + safeText(x.id) + '</td>' +
      '<td>' + safeText(x.title) + '</td>' +
      '<td>' + safeText(x.city||'') + '</td>' +
      '<td>' + safeText(x.category||'') + '</td>' +
      '<td>' + daily + '</td>' +
      '<td>' + avail + '</td>' +
      '<td>' + safeText(x.status||'') + '</td>';
    tb.appendChild(tr);
  }
}
async function loadOne(){
  const id = gi('eid');
  const out = document.getElementById('detail_out');
  if(!id){ out.textContent = 'equipment_id required'; return; }
  out.textContent = 'Loading…';
  const res = await fetchJson('/equipment/assets/' + encodeURIComponent(id));
  out.textContent = res.json ? JSON.stringify(res.json, null, 2) : safeText(res.text);
}
async function quote(){
  const id = gi('eid');
  const out = document.getElementById('quote_out');
  if(!id){ out.textContent = 'equipment_id required'; return; }
  const from = gi('from'); const to = gi('to');
  const qty = parseInt(gi('qty') || '1', 10) || 1;
  const body = {equipment_id: parseInt(id,10), from_iso: from, to_iso: to, quantity: qty};
  out.textContent = 'Loading…';
  const res = await fetchJson('/equipment/quote', {method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify(body)});
  out.textContent = res.json ? JSON.stringify(res.json, null, 2) : safeText(res.text);
}
async function book(){
  const id = gi('eid');
  const out = document.getElementById('book_out');
  if(!id){ out.textContent = 'equipment_id required'; return; }
  const from = gi('from'); const to = gi('to');
  const qty = parseInt(gi('qty') || '1', 10) || 1;
  const body = {equipment_id: parseInt(id,10), from_iso: from, to_iso: to, quantity: qty, confirm: true};
  out.textContent = 'Booking…';
  const res = await fetchJson('/equipment/book', {method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify(body)});
  out.textContent = res.json ? JSON.stringify(res.json, null, 2) : safeText(res.text);
}

try{
  const d = new Date();
  const from = d.toISOString().slice(0,19) + 'Z';
  const d2 = new Date(d.getTime() + 24*3600*1000);
  const to = d2.toISOString().slice(0,19) + 'Z';
  setv('from', from);
  setv('to', to);
}catch(_){ }

loadAssets();
</script>
</body></html>
"""
    return HTMLResponse(content=html)


@app.get("/equipment/assets")
def equipment_list_assets(
    q: str = "",
    city: str = "",
    category: str = "",
    subcategory: str = "",
    tag: str = "",
    status: str = "",
    available_only: bool = False,
    from_iso: str = "",
    to_iso: str = "",
    min_price: int = None,
    max_price: int = None,
    min_weight: float = None,
    max_weight: float = None,
    min_power: float = None,
    max_power: float = None,
    order: str = "newest",
    near_lat: float = None,
    near_lon: float = None,
    max_distance_km: float = None,
    limit: int = 50,
):
    params = {"limit": max(1, min(limit, 200))}
    if q:
        params["q"] = q
    if city:
        params["city"] = city
    if category:
        params["category"] = category
    if subcategory:
        params["subcategory"] = subcategory
    if tag:
        params["tag"] = tag
    if status:
        params["status"] = status
    if available_only:
        params["available_only"] = available_only
    if from_iso:
        params["from_iso"] = from_iso
    if to_iso:
        params["to_iso"] = to_iso
    if min_price is not None:
        params["min_price"] = min_price
    if max_price is not None:
        params["max_price"] = max_price
    if order:
        params["order"] = order
    if near_lat is not None:
        params["near_lat"] = near_lat
    if near_lon is not None:
        params["near_lon"] = near_lon
    if max_distance_km is not None:
        params["max_distance_km"] = max_distance_km
    try:
        if _use_equipment_internal():
            if not _EQUIPMENT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="equipment internal not available")
            with _equipment_internal_session() as s:
                return _equipment_list_assets(
                    q=q,
                    city=city,
                    category=category,
                    subcategory=subcategory,
                    tag=tag,
                    status=status,
                    available_only=available_only,
                    from_iso=from_iso,
                    to_iso=to_iso,
                    min_price=min_price,
                    max_price=max_price,
                    min_weight=min_weight,
                    max_weight=max_weight,
                    min_power=min_power,
                    max_power=max_power,
                    order=order,
                    near_lat=near_lat,
                    near_lon=near_lon,
                    max_distance_km=max_distance_km,
                    limit=limit,
                    s=s,
                )
        r = httpx.get(_equipment_url("/assets"), params=params, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/equipment/assets")
async def equipment_create_asset(req: Request):
    _require_operator(req, "equipment")
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_equipment_internal():
            if not _EQUIPMENT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="equipment internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                creq = _EquipmentCreate(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _equipment_internal_session() as s:
                return _equipment_create_asset(req=creq, s=s)
        r = httpx.post(_equipment_url("/assets"), json=body, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.patch("/equipment/assets/{equipment_id}")
async def equipment_update_asset(equipment_id: int, req: Request):
    _require_operator(req, "equipment")
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_equipment_internal():
            if not _EQUIPMENT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="equipment internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                ureq = _EquipmentUpdate(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _equipment_internal_session() as s:
                return _equipment_update_asset(equipment_id=equipment_id, req=ureq, s=s)
        r = httpx.patch(_equipment_url(f"/assets/{equipment_id}"), json=body, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/equipment/assets/{equipment_id}")
def equipment_get_asset(equipment_id: int):
    try:
        if _use_equipment_internal():
            if not _EQUIPMENT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="equipment internal not available")
            with _equipment_internal_session() as s:
                return _equipment_get_asset(equipment_id=equipment_id, s=s)
        r = httpx.get(_equipment_url(f"/assets/{equipment_id}"), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.delete("/equipment/assets/{equipment_id}")
def equipment_delete_asset(equipment_id: int, request: Request):
    _require_operator(request, "equipment")
    try:
        if _use_equipment_internal():
            if not _EQUIPMENT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="equipment internal not available")
            with _equipment_internal_session() as s:
                return _equipment_delete_asset(equipment_id=equipment_id, s=s)
        r = httpx.delete(_equipment_url(f"/assets/{equipment_id}"), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/equipment/quote")
async def equipment_quote(req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_equipment_internal():
            if not _EQUIPMENT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="equipment internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                qreq = _EquipmentQuoteReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _equipment_internal_session() as s:
                return _equipment_quote(req=qreq, s=s)
        r = httpx.post(_equipment_url("/quote"), json=body, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/equipment/book")
async def equipment_book(req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    headers: dict[str, str] = {}
    try:
        ikey = req.headers.get("Idempotency-Key")
    except Exception:
        ikey = None
    if ikey:
        headers["Idempotency-Key"] = ikey
    try:
        if _use_equipment_internal():
            if not _EQUIPMENT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="equipment internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                breq = _EquipmentBookReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _equipment_internal_session() as s:
                return _equipment_book(req=breq, idempotency_key=ikey, s=s)
        r = httpx.post(_equipment_url("/book"), json=body, headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/equipment/bookings/{booking_id}")
def equipment_get_booking(booking_id: str):
    try:
        if _use_equipment_internal():
            if not _EQUIPMENT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="equipment internal not available")
            with _equipment_internal_session() as s:
                return _equipment_get_booking(booking_id=booking_id, s=s)
        r = httpx.get(_equipment_url(f"/bookings/{booking_id}"), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/equipment/bookings")
def equipment_list_bookings(request: Request, status: str = "", renter_wallet_id: str = "", equipment_id: int | None = None, upcoming_only: bool = False, limit: int = 100):
    params = {"limit": max(1, min(limit, 300))}
    if status:
        params["status"] = status
    if renter_wallet_id:
        params["renter_wallet_id"] = renter_wallet_id
    if equipment_id is not None:
        params["equipment_id"] = equipment_id
    if upcoming_only:
        params["upcoming_only"] = upcoming_only
    # Basic guardrail: non-operators must filter by renter_wallet_id
    try:
        phone = _auth_phone(request)
    except Exception:
        phone = None
    is_op = False
    try:
        if phone:
            is_op = _is_operator(phone, "equipment")
    except Exception:
        is_op = False
    if not is_op and not renter_wallet_id:
        raise HTTPException(status_code=403, detail="renter_wallet_id required")
    try:
        if _use_equipment_internal():
            if not _EQUIPMENT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="equipment internal not available")
            with _equipment_internal_session() as s:
                return _equipment_list_bookings(
                    status=status,
                    renter_wallet_id=renter_wallet_id,
                    equipment_id=equipment_id,
                    upcoming_only=upcoming_only,
                    limit=limit,
                    s=s,
                )
        r = httpx.get(_equipment_url("/bookings"), params=params, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/equipment/bookings/{booking_id}/status")
async def equipment_update_booking_status(booking_id: str, req: Request):
    _require_operator(req, "equipment")
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_equipment_internal():
            if not _EQUIPMENT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="equipment internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                sreq = _EquipmentStatusUpdate(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _equipment_internal_session() as s:
                return _equipment_update_booking_status(booking_id=booking_id, req=sreq, s=s)
        r = httpx.post(_equipment_url(f"/bookings/{booking_id}/status"), json=body, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/equipment/bookings/{booking_id}/logistics")
async def equipment_update_logistics(booking_id: str, req: Request):
    _require_operator(req, "equipment")
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_equipment_internal():
            if not _EQUIPMENT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="equipment internal not available")
            data = body or []
            if not isinstance(data, list):
                data = []
            updates: list[_EquipmentTaskUpdate] = []
            for item in data:
                try:
                    updates.append(_EquipmentTaskUpdate(**item))
                except Exception:
                    continue
            with _equipment_internal_session() as s:
                return _equipment_update_logistics(booking_id=booking_id, updates=updates, s=s)
        r = httpx.post(_equipment_url(f"/bookings/{booking_id}/logistics"), json=body, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/equipment/analytics/summary")
def equipment_analytics(request: Request):
    _require_operator(request, "equipment")
    try:
        if _use_equipment_internal():
            if not _EQUIPMENT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="equipment internal not available")
            with _equipment_internal_session() as s:
                return _equipment_analytics(s=s)
        r = httpx.get(_equipment_url("/analytics/summary"), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/equipment/dashboard")
def equipment_dashboard(request: Request, renter_wallet_id: str = "", owner_wallet_id: str = ""):
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    params = {}
    if renter_wallet_id:
        params["renter_wallet_id"] = renter_wallet_id
    if owner_wallet_id:
        params["owner_wallet_id"] = owner_wallet_id
    try:
        if _use_equipment_internal():
            if not _EQUIPMENT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="equipment internal not available")
            with _equipment_internal_session() as s:
                return _equipment_dashboard(renter_wallet_id=renter_wallet_id, owner_wallet_id=owner_wallet_id, s=s)
        r = httpx.get(_equipment_url("/dashboard"), params=params, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/equipment/availability/{equipment_id}")
def equipment_availability(equipment_id: int):
    try:
        if _use_equipment_internal():
            if not _EQUIPMENT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="equipment internal not available")
            with _equipment_internal_session() as s:
                return _equipment_main.availability(equipment_id=equipment_id, s=s)  # type: ignore[attr-defined]
        r = httpx.get(_equipment_url(f"/availability/{equipment_id}"), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/equipment/calendar/{equipment_id}")
def equipment_calendar(equipment_id: int, month: str):
    try:
        if _use_equipment_internal():
            if not _EQUIPMENT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="equipment internal not available")
            with _equipment_internal_session() as s:
                return _equipment_main.calendar(equipment_id=equipment_id, month=month, s=s)  # type: ignore[attr-defined]
        r = httpx.get(_equipment_url(f"/calendar/{equipment_id}"), params={"month": month}, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/equipment/availability/{equipment_id}")
async def equipment_add_block(equipment_id: int, req: Request):
    _require_operator(req, "equipment")
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_equipment_internal():
            if not _EQUIPMENT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="equipment internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                breq = _equipment_main.AvailabilityReq(**data)  # type: ignore[attr-defined]
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _equipment_internal_session() as s:
                return _equipment_main.create_block(equipment_id=equipment_id, req=breq, s=s)  # type: ignore[attr-defined]
        r = httpx.post(_equipment_url(f"/availability/{equipment_id}"), json=body, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.delete("/equipment/availability/{block_id}")
def equipment_delete_block(block_id: str, request: Request):
    _require_operator(request, "equipment")
    try:
        if _use_equipment_internal():
            if not _EQUIPMENT_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="equipment internal not available")
            with _equipment_internal_session() as s:
                return _equipment_main.delete_block(block_id=block_id, s=s)  # type: ignore[attr-defined]
        r = httpx.delete(_equipment_url(f"/availability/{block_id}"), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


# ---- Taxi proxies ----
def _taxi_url(path: str) -> str:
    if not TAXI_BASE:
        raise HTTPException(status_code=500, detail="TAXI_BASE_URL not configured")
    return TAXI_BASE.rstrip("/") + path

INTERNAL_API_SECRET = os.getenv("INTERNAL_API_SECRET", "")
def _taxi_headers() -> dict:
    return ({"X-Internal-Secret": INTERNAL_API_SECRET} if INTERNAL_API_SECRET else {})

TAXI_QR_TOPUP_PEPPER = os.getenv("TAXI_QR_TOPUP_PEPPER", "")

def _taxi_topup_sig(driver_id: str, amount_cents: int) -> str:
    import hashlib, hmac
    key = (TAXI_QR_TOPUP_PEPPER or INTERNAL_API_SECRET or "taxi-topup").encode()
    msg = f"{driver_id}|{int(amount_cents)}".encode()
    return hmac.new(key, msg, hashlib.sha256).hexdigest()


# --- Taxi internal service (monolith mode) ---
_TAXI_INTERNAL_AVAILABLE = False
try:  # Optional: only available when Taxi app and SQLAlchemy are installed
    from sqlalchemy.orm import Session as _TaxiSession  # type: ignore[import]
    from apps.taxi.app import main as _taxi_main  # type: ignore[import]
    from apps.taxi.app.main import (  # type: ignore[import]
        engine as _taxi_engine,
        DriverRegisterReq as _TaxiDriverRegisterReq,
        LocationReq as _TaxiLocationReq,
        SetWalletReq as _TaxiSetWalletReq,
        RideRequest as _TaxiRideRequest,
        BalanceSetReq as _TaxiBalanceSetReq,
        BalanceIdentityReq as _TaxiBalanceIdentityReq,
        TaxiSettingsUpdate as _TaxiSettingsUpdate,
        RideRatingReq as _TaxiRideRatingReq,
        TaxiTopupQrLogOut as _TaxiTopupQrLogOut,
        TaxiTopupQrRedeemIn as _TaxiTopupQrRedeemIn,
        PreQuoteReq as _TaxiPreQuoteReq,
        register_driver as _taxi_register_driver,
        driver_online as _taxi_driver_online,
        driver_offline as _taxi_driver_offline,
        driver_location as _taxi_driver_location,
        driver_set_wallet as _taxi_driver_set_wallet,
        driver_push_token as _taxi_driver_push_token,
        get_driver as _taxi_get_driver,
        driver_rides as _taxi_driver_rides,
        driver_delete as _taxi_driver_delete,
        driver_block as _taxi_driver_block,
        driver_unblock as _taxi_driver_unblock,
        driver_balance as _taxi_driver_balance,
        driver_balance_by_identity as _taxi_driver_balance_by_identity,
        driver_lookup as _taxi_driver_lookup,
        request_ride as _taxi_request_ride,
        list_drivers as _taxi_list_drivers,
        list_rides as _taxi_list_rides,
        create_topup_qr_log as _taxi_create_topup_qr_log,
        mark_topup_qr_redeemed as _taxi_mark_topup_qr_redeemed,
        list_topup_qr_logs as _taxi_list_topup_qr_logs,
        get_settings as _taxi_get_settings,
        update_settings as _taxi_update_settings,
        rate_ride as _taxi_rate_ride,
        taxi_admin_summary as _taxi_admin_summary,
        driver_stats as _taxi_driver_stats,
        pre_quote as _taxi_pre_quote,
        book_and_pay as _taxi_book_and_pay,
        get_ride as _taxi_get_ride,
        accept_ride as _taxi_accept_ride,
        assign_ride as _taxi_assign_ride,
        start_ride as _taxi_start_ride,
        complete_ride as _taxi_complete_ride,
        cancel_ride as _taxi_cancel_ride,
    )
    _TAXI_INTERNAL_AVAILABLE = True
except Exception:
    _TaxiSession = None  # type: ignore[assignment]
    _taxi_main = None  # type: ignore[assignment]
    _taxi_engine = None  # type: ignore[assignment]
    _TAXI_INTERNAL_AVAILABLE = False


class _TaxiInternalRequestShim:
    """
    Minimal shim to satisfy Taxi service endpoint signatures when calling
    them directly in-process. It only exposes the attributes actually used:
    - headers: mapping with X-Internal-Secret
    - json(): async method returning a pre-parsed body (for driver_push_token)
    """

    __slots__ = ("headers", "_body")

    def __init__(self, headers: dict[str, str], body: Any | None = None):
        self.headers = headers
        self._body = body

    async def json(self) -> Any:
        return self._body


def _use_taxi_internal() -> bool:
    """
    Decide whether to use in-process Taxi calls instead of HTTP.

    Modes (env: TAXI_INTERNAL_MODE):
      - "on"   -> always use internal when available
      - "off"  -> always use HTTP
      - "auto" -> default; use internal if Taxi is importable and TAXI_BASE_URL is empty
    """
    if _force_internal(_TAXI_INTERNAL_AVAILABLE):
        return True
    mode = os.getenv("TAXI_INTERNAL_MODE", "auto").lower()
    if mode == "off":
        return False
    if not _TAXI_INTERNAL_AVAILABLE:
        return False
    if mode == "on":
        return True
    # auto: prefer internal wiring when no explicit upstream base is configured
    return not bool(TAXI_BASE)


def _taxi_internal_session():
    if not _TAXI_INTERNAL_AVAILABLE or _TaxiSession is None or _taxi_engine is None:  # type: ignore[truthy-function]
        raise RuntimeError("Taxi internal service not available")
    return _TaxiSession(_taxi_engine)  # type: ignore[call-arg]


def _call_taxi(fn, *, need_session: bool, request_body: Any | None = None,
               inject_internal: bool = False, **kwargs):
    """
    Call a synchronous Taxi endpoint function directly in-process.
    """
    if not _use_taxi_internal():
        raise RuntimeError("Taxi internal not enabled")
    req_obj: _TaxiInternalRequestShim | None = None
    if inject_internal:
        req_obj = _TaxiInternalRequestShim(_taxi_headers(), request_body)
    try:
        if need_session:
            with _taxi_internal_session() as s:
                if req_obj is not None:
                    kwargs.setdefault("request", req_obj)
                kwargs.setdefault("s", s)
                return fn(**kwargs)
        else:
            if req_obj is not None:
                kwargs.setdefault("request", req_obj)
            return fn(**kwargs)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


async def _call_taxi_async(fn, *, need_session: bool, request_body: Any | None = None,
                           inject_internal: bool = False, **kwargs):
    """
    Call an async Taxi endpoint function (currently driver_push_token) in-process.
    """
    if not _use_taxi_internal():
        raise RuntimeError("Taxi internal not enabled")
    req_obj: _TaxiInternalRequestShim | None = None
    if inject_internal:
        req_obj = _TaxiInternalRequestShim(_taxi_headers(), request_body)
    try:
        if need_session:
            with _taxi_internal_session() as s:
                if req_obj is not None:
                    kwargs.setdefault("request", req_obj)
                kwargs.setdefault("s", s)
                return await fn(**kwargs)
        else:
            if req_obj is not None:
                kwargs.setdefault("request", req_obj)
            return await fn(**kwargs)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


# --- Payments internal service (monolith mode) ---
_PAY_INTERNAL_AVAILABLE = False
try:
    from sqlalchemy.orm import Session as _PaySession  # type: ignore[import]
    from apps.payments.app import main as _pay_main  # type: ignore[import]
    from apps.payments.app.main import (  # type: ignore[import]
        engine as _pay_engine,
        CreateUserReq as _PayCreateUserReq,
        TransferReq as _PayTransferReq,
        BillPayReq as _PayBillPayReq,
        PaymentRequestCreate as _PayRequestCreate,
        _accept_request_core as _pay_accept_request_core,
        TopupReq as _PayTopupReq,
        FavoriteCreate as _PayFavoriteCreate,
        CashCreateReq as _PayCashCreateReq,
        CashRedeemReq as _PayCashRedeemReq,
        CashCancelReq as _PayCashCancelReq,
        SonicIssueReq as _PaySonicIssueReq,
        SonicRedeemReq as _PaySonicRedeemReq,
        RedPacketIssueReq as _PayRedPacketIssueReq,
        RedPacketClaimReq as _PayRedPacketClaimReq,
        SavingsDepositReq as _PaySavingsDepositReq,
        SavingsWithdrawReq as _PaySavingsWithdrawReq,
        AliasRequest as _PayAliasRequest,
        AliasVerifyReq as _PayAliasVerifyReq,
        RoleUpsert as _PayRoleUpsert,
        RiskDenyReq as _PayRiskDenyReq,
        TopupBatchCreateReq as _PayTopupBatchCreateReq,
        TopupRedeemReq as _PayTopupRedeemReq,
        create_user as _pay_create_user,
        get_wallet as _pay_get_wallet,
        list_txns as _pay_list_txns,
        transfer as _pay_transfer,
        create_favorite as _pay_create_favorite,
        list_favorites as _pay_list_favorites,
        delete_favorite as _pay_delete_favorite,
        create_request as _pay_create_request,
        list_requests as _pay_list_requests,
        cancel_request as _pay_cancel_request,
        accept_request as _pay_accept_request,
        resolve_phone as _pay_resolve_phone,
        cash_create as _pay_cash_create,
        cash_redeem as _pay_cash_redeem,
        cash_cancel as _pay_cash_cancel,
        cash_status as _pay_cash_status,
        sonic_issue as _pay_sonic_issue,
        sonic_redeem as _pay_sonic_redeem,
        redpacket_issue as _pay_redpacket_issue,
        redpacket_claim as _pay_redpacket_claim,
        redpacket_status as _pay_redpacket_status,
        savings_deposit as _pay_savings_deposit,
        savings_withdraw as _pay_savings_withdraw,
        savings_overview as _pay_savings_overview,
        bills_pay as _pay_bills_pay,
        idempotency_status as _pay_idempotency_status,
        alias_request as _pay_alias_request,
        alias_verify as _pay_alias_verify,
        alias_resolve as _pay_alias_resolve,
        roles_list as _pay_roles_list,
        roles_add as _pay_roles_add,
        roles_remove as _pay_roles_remove,
        roles_check as _pay_roles_check,
        admin_risk_deny_add as _pay_admin_risk_deny_add,
        admin_risk_deny_remove as _pay_admin_risk_deny_remove,
        admin_risk_deny_list as _pay_admin_risk_deny_list,
        admin_risk_events as _pay_admin_risk_events,
        admin_risk_metrics as _pay_admin_risk_metrics,
        topup as _pay_wallet_topup,
        topup_batch_create as _pay_topup_batch_create,
        topup_batches as _pay_topup_batches,
        topup_batch_detail as _pay_topup_batch_detail,
        topup_voucher_void as _pay_topup_voucher_void,
        topup_redeem as _pay_topup_redeem,
        fees_summary as _pay_fees_summary,
        admin_txns_count as _pay_admin_txns_count,
    )
    _PAY_INTERNAL_AVAILABLE = True
except Exception:
    _PaySession = None  # type: ignore[assignment]
    _pay_main = None  # type: ignore[assignment]
    _pay_engine = None  # type: ignore[assignment]
    _PAY_INTERNAL_AVAILABLE = False


def _use_pay_internal() -> bool:
    """
    PAYMENTS_INTERNAL_MODE / PAY_INTERNAL_MODE:
      - on   -> immer intern
      - off  -> immer HTTP
      - auto -> intern, wenn importierbar und PAYMENTS_BASE_URL leer
    """
    if _force_internal(_PAY_INTERNAL_AVAILABLE):
        return True
    mode = (os.getenv("PAYMENTS_INTERNAL_MODE") or os.getenv("PAY_INTERNAL_MODE") or "auto").lower()
    if mode == "off":
        return False
    if not _PAY_INTERNAL_AVAILABLE:
        return False
    if mode == "on":
        return True
    return not bool(PAYMENTS_BASE)


def _pay_internal_session():
    if not _PAY_INTERNAL_AVAILABLE or _PaySession is None or _pay_engine is None:  # type: ignore[truthy-function]
        raise RuntimeError("Payments internal service not available")
    return _PaySession(_pay_engine)  # type: ignore[call-arg]


async def _send_driver_push(phone: str, title: str, body: str, data: dict | None = None) -> None:
    endpoints = list(_PUSH_ENDPOINTS.get(phone) or [])
    if not endpoints:
        return
    try:
        async with httpx.AsyncClient(timeout=6) as client:
            for ep in endpoints:
                etype = (ep.get("type") or "").lower()
                if etype == "gotify" and GOTIFY_BASE and GOTIFY_APP_TOKEN:
                    try:
                        await client.post(
                            GOTIFY_BASE.rstrip("/") + "/message",
                            params={"token": GOTIFY_APP_TOKEN},
                            json={
                                "title": title,
                                "message": body,
                                "priority": 5,
                                "extras": {"custom": data or {}},
                            },
                        )
                    except Exception:
                        continue
                elif etype == "unifiedpush":
                    url = (ep.get("endpoint") or "").strip()
                    if not url:
                        continue
                    try:
                        await client.post(url, json=data or {})
                    except Exception:
                        continue
    except Exception:
        return


async def _maybe_send_driver_push_for_ride(ride: dict) -> None:
    try:
        driver_id = (ride.get("driver_id") or "").strip()
        ride_id = (ride.get("id") or "").strip()
        if not driver_id or not ride_id:
            return
        pickup_lat = ride.get("pickup_lat")
        pickup_lon = ride.get("pickup_lon")
        rider_phone = (ride.get("rider_phone") or "").strip()
        driver_phone = ""
        try:
            if _use_taxi_internal():
                try:
                    d = _call_taxi(_taxi_get_driver, need_session=True, driver_id=driver_id)
                    driver_phone = (getattr(d, "phone", "") or "").strip()
                except HTTPException:
                    driver_phone = ""
            else:
                r = httpx.get(_taxi_url(f"/drivers/{driver_id}"), headers=_taxi_headers(), timeout=10)
                if r.headers.get("content-type", "").startswith("application/json"):
                    dj = r.json()
                    if isinstance(dj, dict):
                        driver_phone = (dj.get("phone") or "").strip()
        except Exception:
            driver_phone = ""
        if not driver_phone:
            return
        parts = []
        try:
            if isinstance(pickup_lat, (int, float)) and isinstance(pickup_lon, (int, float)):
                parts.append(f"Pickup: {pickup_lat:.4f},{pickup_lon:.4f}")
        except Exception:
            pass
        if rider_phone:
            parts.append(f"Rider: {rider_phone}")
        body = " · ".join(parts) if parts else f"Ride {ride_id}"
        await _send_driver_push(
            driver_phone,
            "New taxi ride request",
            body,
            {
                "ride_id": ride_id,
                "pickup_lat": str(pickup_lat or ""),
                "pickup_lon": str(pickup_lon or ""),
                "rider_phone": rider_phone,
            },
        )
    except Exception:
        return

@app.post("/taxi/drivers")
async def taxi_driver_register(req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None

    # Extract phone early so we can create a payments user/wallet idempotently.
    phone = ""
    try:
        if isinstance(body, dict):
            phone = (body.get("phone") or "").strip()
    except Exception:
        phone = ""

    # First: register driver in Taxi service.
    try:
        if _use_taxi_internal():
            try:
                data = body or {}
                if not isinstance(data, dict):
                    data = {}
                req_model = _TaxiDriverRegisterReq(**data)
                driver = _call_taxi(_taxi_register_driver, need_session=True, req=req_model)
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(status_code=502, detail=str(e))
        else:
            r = httpx.post(_taxi_url("/drivers"), json=body, headers=_taxi_headers(), timeout=10)
            try:
                driver = r.json() if r.headers.get("content-type", "").startswith("application/json") else {}
            except Exception:
                driver = {}
            if r.status_code >= 400:
                # Surface taxi error to caller; do not attempt wallet creation.
                raise HTTPException(status_code=r.status_code, detail=r.text)
    except HTTPException:
        raise
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))

    # Second: ensure Payments user + wallet for this driver's phone (best-effort, idempotent).
    try:
        if phone:
            payload = {"phone": phone}
            if _use_pay_internal():
                if _PAY_INTERNAL_AVAILABLE:
                    req_model = _PayCreateUserReq(**payload)
                    with _pay_internal_session() as s:
                        _pay_create_user(req_model, s=s)
            elif PAYMENTS_BASE:
                httpx.post(
                    _payments_url("/users"),
                    json=payload,
                    headers=_payments_headers(),
                    timeout=8,
                )
    except Exception:
        # Wallet creation is best-effort; driver registration must still succeed.
        pass

    return driver


@app.post("/taxi/drivers/{driver_id}/online")
def taxi_driver_online(driver_id: str):
    if _use_taxi_internal():
        try:
            return _call_taxi(_taxi_driver_online, need_session=True, inject_internal=True, driver_id=driver_id)
        except HTTPException:
            raise
        except Exception as e:
            raise HTTPException(status_code=502, detail=str(e))
    try:
        r = httpx.post(_taxi_url(f"/drivers/{driver_id}/online"), headers=_taxi_headers(), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/taxi/drivers/{driver_id}/offline")
def taxi_driver_offline(driver_id: str):
    if _use_taxi_internal():
        try:
            return _call_taxi(_taxi_driver_offline, need_session=True, inject_internal=True, driver_id=driver_id)
        except HTTPException:
            raise
        except Exception as e:
            raise HTTPException(status_code=502, detail=str(e))
    try:
        r = httpx.post(_taxi_url(f"/drivers/{driver_id}/offline"), headers=_taxi_headers(), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/taxi/drivers/{driver_id}/location")
async def taxi_driver_location(driver_id: str, req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    if _use_taxi_internal():
        try:
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            req_model = _TaxiLocationReq(**data)
            return _call_taxi(
                _taxi_driver_location,
                need_session=True,
                request_body=data,
                inject_internal=True,
                driver_id=driver_id,
                req=req_model,
            )
        except HTTPException:
            raise
        except Exception as e:
            raise HTTPException(status_code=502, detail=str(e))
    try:
        r = httpx.post(_taxi_url(f"/drivers/{driver_id}/location"), json=body, headers=_taxi_headers(), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/taxi/drivers/{driver_id}/wallet")
async def taxi_driver_set_wallet(driver_id: str, req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    if _use_taxi_internal():
        try:
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            req_model = _TaxiSetWalletReq(**data)
            return _call_taxi(
                _taxi_driver_set_wallet,
                need_session=True,
                request_body=data,
                inject_internal=True,
                driver_id=driver_id,
                req=req_model,
            )
        except HTTPException:
            raise
        except Exception as e:
            raise HTTPException(status_code=502, detail=str(e))
    try:
        r = httpx.post(_taxi_url(f"/drivers/{driver_id}/wallet"), json=body, headers=_taxi_headers(), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/taxi/drivers/{driver_id}/push_token")
async def taxi_driver_push_token(driver_id: str, req: Request):
    try:
        try:
            body = await req.json()
        except Exception:
            body = None
        if _use_taxi_internal():
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            return await _call_taxi_async(
                _taxi_driver_push_token,
                need_session=True,
                request_body=data,
                inject_internal=True,
                driver_id=driver_id,
            )
        r = httpx.post(_taxi_url(f"/drivers/{driver_id}/push_token"), json=body, headers=_taxi_headers(), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/taxi/drivers/{driver_id}")
def taxi_get_driver(driver_id: str):
    if _use_taxi_internal():
        try:
            return _call_taxi(_taxi_get_driver, need_session=True, driver_id=driver_id)
        except HTTPException:
            raise
        except Exception as e:
            raise HTTPException(status_code=502, detail=str(e))
    try:
        r = httpx.get(_taxi_url(f"/drivers/{driver_id}"), headers=_taxi_headers(), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/taxi/drivers/{driver_id}/rides")
def taxi_driver_rides(driver_id: str, status: str = "", limit: int = 10):
    params = {"status": status, "limit": max(1, min(limit, 50))}
    if _use_taxi_internal():
        try:
            return _call_taxi(
                _taxi_driver_rides,
                need_session=True,
                driver_id=driver_id,
                status=status,
                limit=max(1, min(limit, 50)),
            )
        except HTTPException:
            raise
        except Exception as e:
            raise HTTPException(status_code=502, detail=str(e))
    try:
        r = httpx.get(_taxi_url(f"/drivers/{driver_id}/rides"), params=params, headers=_taxi_headers(), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/fleet/nearest_driver")
def fleet_nearest_driver(lat: float, lon: float, status: str = "online", limit: int = 200):
    """
    Returns the nearest taxi driver to a given location (approximate, by distance).

    Uses Taxi drivers list (status filter) and a simple Haversine distance.
    """
    # Load candidate drivers
    params = {"status": status, "limit": max(1, min(limit, 500))}
    drivers: list[Any] = []
    try:
        if _use_taxi_internal():
            if not _TAXI_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="taxi internal not available")
            drivers = _call_taxi(
                _taxi_list_drivers,
                need_session=True,
                status=status,
                limit=max(1, min(limit, 500)),
            )
        else:
            if not TAXI_BASE:
                raise HTTPException(status_code=500, detail="TAXI_BASE_URL not configured")
            r = httpx.get(_taxi_url("/drivers"), params=params, headers=_taxi_headers(), timeout=10)
            if not r.headers.get("content-type", "").startswith("application/json"):
                raise HTTPException(status_code=502, detail="unexpected taxi drivers payload")
            arr = r.json()
            if isinstance(arr, list):
                drivers = arr
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))

    best: dict[str, Any] | None = None
    best_km = float("inf")
    total = 0

    for d in drivers or []:
        try:
            if hasattr(d, "__dict__"):
                # Internal Taxi driver object
                did = str(getattr(d, "id", "") or "")
                plat = getattr(d, "lat", None)
                plon = getattr(d, "lon", None)
                phone = str(getattr(d, "phone", "") or "")
            else:
                m = d if isinstance(d, dict) else {}
                did = str(m.get("id") or "")
                plat = m.get("lat")
                plon = m.get("lon")
                phone = str(m.get("phone") or "")
            if not did:
                continue
            if plat is None or plon is None:
                continue
            plat_f = float(plat)
            plon_f = float(plon)
            total += 1
            dist_km = _haversine_km(lat, lon, plat_f, plon_f)
            if dist_km < best_km:
                best_km = dist_km
                best = {
                    "driver_id": did,
                    "phone": phone,
                    "lat": plat_f,
                    "lon": plon_f,
                    "distance_km": dist_km,
                }
        except Exception:
            continue

    if not best:
        return {"ok": True, "found": False, "drivers_checked": total}
    return {"ok": True, "found": True, "drivers_checked": total, "nearest": best}


@app.delete("/taxi/drivers/{driver_id}")
def taxi_delete_driver(driver_id: str):
    if _use_taxi_internal():
        try:
            result = _call_taxi(_taxi_driver_delete, need_session=True, inject_internal=True, driver_id=driver_id)
            return result
        except HTTPException:
            raise
        except Exception as e:
            raise HTTPException(status_code=502, detail=str(e))
    try:
        r = httpx.delete(_taxi_url(f"/drivers/{driver_id}"), headers=_taxi_headers(), timeout=10)
        if r.headers.get("content-type","" ).startswith("application/json"):
            return r.json()
        return {"status_code": r.status_code, "raw": r.text}
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/taxi/drivers/{driver_id}/block")
def taxi_block_driver(driver_id: str):
    if _use_taxi_internal():
        try:
            return _call_taxi(_taxi_driver_block, need_session=True, inject_internal=True, driver_id=driver_id)
        except HTTPException:
            raise
        except Exception as e:
            raise HTTPException(status_code=502, detail=str(e))
    try:
        r = httpx.post(_taxi_url(f"/drivers/{driver_id}/block"), headers=_taxi_headers(), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/taxi/drivers/{driver_id}/unblock")
def taxi_unblock_driver(driver_id: str):
    if _use_taxi_internal():
        try:
            return _call_taxi(_taxi_driver_unblock, need_session=True, inject_internal=True, driver_id=driver_id)
        except HTTPException:
            raise
        except Exception as e:
            raise HTTPException(status_code=502, detail=str(e))
    try:
        r = httpx.post(_taxi_url(f"/drivers/{driver_id}/unblock"), headers=_taxi_headers(), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/taxi/drivers/{driver_id}/balance")
async def taxi_set_balance(driver_id: str, req: Request):
    try:
        try:
            body = await req.json()
        except Exception:
            body = None
        if _use_taxi_internal():
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                req_model = _TaxiBalanceSetReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            return _call_taxi(
                _taxi_driver_balance,
                need_session=True,
                request_body=data,
                inject_internal=True,
                driver_id=driver_id,
                req=req_model,
            )
        r = httpx.post(_taxi_url(f"/drivers/{driver_id}/balance"), json=body, headers=_taxi_headers(), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/taxi/rides/request")
async def taxi_request_ride(req: Request):
    # Backend-side enrichment: rider phone from session; rider wallet via Payments
    try:
        body = await req.json()
    except Exception:
        body = {}
    if not isinstance(body, dict):
        body = {}
    # Fill rider phone from session if absent
    try:
        rider_phone = (body.get('rider_phone') or '').strip()
    except Exception:
        rider_phone = ''
    if not rider_phone:
        sess_phone = _auth_phone(req)
        if sess_phone:
            body['rider_phone'] = sess_phone
            rider_phone = sess_phone
    # Fill rider wallet id via Payments if absent
    try:
        rider_wallet = (body.get('rider_wallet_id') or '').strip()
    except Exception:
        rider_wallet = ''
    if not rider_wallet and rider_phone and PAYMENTS_BASE:
        try:
            url = PAYMENTS_BASE.rstrip('/') + '/users'
            async with httpx.AsyncClient(timeout=10) as client:
                rr = await client.post(url, json={"phone": rider_phone}, headers=_payments_headers())
                if rr.headers.get('content-type','').startswith('application/json'):
                    j = rr.json()
                    wid = j.get('wallet_id') or j.get('id')
                    if wid:
                        body['rider_wallet_id'] = wid
        except Exception:
            pass
    try:
        if _use_taxi_internal():
            try:
                req_model = _TaxiRideRequest(**body)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            ride_obj = _call_taxi(
                _taxi_request_ride,
                need_session=True,
                request_body=body,
                inject_internal=True,
                req=req_model,
                idempotency_key=None,
            )
            # Fire-and-forget push notification using a serializable view of the ride
            try:
                if hasattr(ride_obj, "dict"):
                    ride_dict = ride_obj.dict()  # type: ignore[call-arg]
                else:
                    ride_dict = ride_obj
                if isinstance(ride_dict, dict):
                    await _maybe_send_driver_push_for_ride(ride_dict)
            except Exception:
                pass
            return ride_obj
        r = httpx.post(_taxi_url("/rides/request"), json=body, headers=_taxi_headers(), timeout=10)
        j = r.json()
        try:
            if isinstance(j, dict):
                await _maybe_send_driver_push_for_ride(j)
        except Exception:
            pass
        return j
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))

# NOTE: Place book_pay BEFORE the dynamic /taxi/rides/{ride_id} to avoid 405
## moved earlier to avoid conflict with /taxi/rides/{ride_id}


@app.get("/taxi/drivers")
def taxi_list_drivers(status: str = "", limit: int = 50):
    params = {"status": status, "limit": max(1, min(limit, 200))}
    if _use_taxi_internal():
        try:
            return _call_taxi(
                _taxi_list_drivers,
                need_session=True,
                status=status,
                limit=max(1, min(limit, 200)),
            )
        except HTTPException:
            raise
        except Exception as e:
            raise HTTPException(status_code=502, detail=str(e))
    try:
        r = httpx.get(_taxi_url("/drivers"), params=params, headers=_taxi_headers(), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/taxi/drivers")
async def taxi_register_driver(request: Request):
    """
    Admin / SuperAdmin endpoint to register a new taxi driver.

    Expected JSON body (forwarded to Taxi service):
      - name: string (optional but recommended)
      - phone: string (E.164, required)
      - vehicle_make / vehicle_plate / vehicle_class / vehicle_color: optional

    The Taxi service will:
      - create the Driver record
      - auto-create a unique payments wallet for the driver (wallet_id) based on phone
    """
    _require_operator(request, "taxi")
    try:
        try:
            body = await request.json()
        except Exception:
            body = {}
        if not isinstance(body, dict):
            body = {}
        # Minimal validation: phone required
        phone = (body.get("phone") or "").strip()
        if not phone:
            raise HTTPException(status_code=400, detail="phone required")

        # Prefer in-process Taxi integration in monolith mode
        if _use_taxi_internal():
            if not _TAXI_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="taxi internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                req_model = _TaxiDriverRegisterReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            try:
                result = _call_taxi(
                    _taxi_register_driver,
                    need_session=True,
                    request_body=data,
                    inject_internal=True,
                    req=req_model,
                )
                _audit_from_request(request, "taxi_register_driver", driver_phone=phone)
                return result
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(status_code=502, detail=str(e))

        # Fallback: HTTP call to external Taxi API
        r = httpx.post(_taxi_url("/drivers"), json=body, headers=_taxi_headers(), timeout=10)
        if r.headers.get("content-type", "").startswith("application/json"):
            result = r.json()
        else:
            # Propagate non-JSON error bodies instead of causing JSON decode errors
            raise HTTPException(status_code=r.status_code, detail=r.text)
        _audit_from_request(request, "taxi_register_driver", driver_phone=phone)
        return result
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/taxi/rides")
def taxi_list_rides(status: str = "", limit: int = 50):
    params = {"status": status, "limit": max(1, min(limit, 200))}
    if _use_taxi_internal():
        try:
            return _call_taxi(
                _taxi_list_rides,
                need_session=True,
                status=status,
                limit=max(1, min(limit, 200)),
            )
        except HTTPException:
            raise
        except Exception as e:
            raise HTTPException(status_code=502, detail=str(e))
    try:
        r = httpx.get(_taxi_url("/rides"), params=params, headers=_taxi_headers(), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/me/taxi_history")
def me_taxi_history(request: Request, status: str = "", limit: int = 50, response: Response = None):  # type: ignore[assignment]
    """
    Aggregated Taxi ride history for the logged-in user.

    Filters Taxi rides by rider_phone == own phone number,
    optionally restricted by status. Uses the existing Taxi list
    and encapsulates filtering logic in the BFF.
    """
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    limit = max(1, min(limit, 200))
    try:
        # Fetch a slightly larger set and filter per client afterwards.
        raw = taxi_list_rides(status=status, limit=limit * 2)
        items: list[Any] = []
        if isinstance(raw, list):
            for it in raw:
                try:
                    rider_phone = ""
                    if isinstance(it, dict):
                        rider_phone = (str(it.get("rider_phone") or "")).strip()
                    else:
                        rider_phone = (str(getattr(it, "rider_phone", "") or "")).strip()
                except Exception:
                    continue
                if rider_phone != phone:
                    continue
                items.append(it)
        out = items[:limit]
        try:
            if response is not None:
                response.headers.setdefault("Cache-Control", "no-store")
        except Exception:
            pass
        return out
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/me/bus_history")
def me_bus_history(request: Request, status: str = "", limit: int = 50, response: Response = None):  # type: ignore[assignment]
    """
    Aggregated bus booking history for the logged-in user.

    Uses the existing bus booking search and then filters for
    customer_phone == own phone number. Status filter is optional.
    """
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    limit = max(1, min(limit, 200))
    status = (status or "").strip()
    try:
        raw = bus_booking_search(wallet_id=None, phone=phone, limit=limit * 2)
        items: list[Any] = []
        if isinstance(raw, list):
            for it in raw:
                try:
                    customer_phone = ""
                    current_status = ""
                    if isinstance(it, dict):
                        customer_phone = (str(it.get("customer_phone") or "")).strip()
                        current_status = (str(it.get("status") or "")).strip()
                    else:
                        customer_phone = (str(getattr(it, "customer_phone", "") or "")).strip()
                        current_status = (str(getattr(it, "status", "") or "")).strip()
                except Exception:
                    continue
                if customer_phone != phone:
                    continue
                if status and current_status != status:
                    continue
                items.append(it)
        out = items[:limit]
        try:
            if response is not None:
                response.headers.setdefault("Cache-Control", "no-store")
        except Exception:
            pass
        return out
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/me/mobility_history")
async def me_mobility_history(
    request: Request,
    status: str = "",
    taxi_limit: int = 50,
    bus_limit: int = 50,
    response: Response = None,  # type: ignore[assignment]
):
    """
    Combined mobility history (Taxi + Bus) for the logged-in user.

    Wraps the existing aggregate endpoints /me/taxi_history and
    /me/bus_history into a single response so clients can query both
    domains with one request.
    """
    # Auth is re-checked in the underlying handlers; here we only
    # ensure that a session exists.
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")

    taxi_limit = max(1, min(taxi_limit, 200))
    bus_limit = max(1, min(bus_limit, 200))

    taxi_items: list[dict[str, Any]] = []
    bus_items: list[dict[str, Any]] = []
    try:
        try:
            taxi_items = me_taxi_history(request, status=status, limit=taxi_limit)  # type: ignore[assignment]
        except HTTPException:
            raise
        except Exception as e:
            taxi_items = [{"error": str(e)}]
        try:
            bus_items = me_bus_history(request, status=status, limit=bus_limit)  # type: ignore[assignment]
        except HTTPException:
            raise
        except Exception as e:
            bus_items = [{"error": str(e)}]
        out = {"taxi": taxi_items, "bus": bus_items}
        # Personalisierte Mobility-Historie sollte nicht gecacht werden.
        try:
            if response is not None:
                response.headers.setdefault("Cache-Control", "no-store")
        except Exception:
            pass
        return out
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/taxi/topup_qr/create")
async def taxi_topup_qr_create(request: Request):
    """
    Admin/SuperAdmin: create a QR payload for taxi-driver topup.

    Body:
      - driver_phone: string (E.164)
      - amount_cents: int (>0)

    Returns:
      - payload: string to encode as QR (TAXI_TOPUP|...)
      - driver_id, amount_cents
    """
    _require_operator(request, "taxi")
    try:
        try:
            body = await request.json()
        except Exception:
            body = {}
        if not isinstance(body, dict):
            body = {}
        # Accept driver_phone or phone
        phone = (body.get("driver_phone") or body.get("phone") or "").strip()
        if not phone:
            raise HTTPException(status_code=400, detail="driver_phone required")
        # Normalize amount: allow amount_syp/amount (SYP) or amount_cents
        body = _normalize_amount(body) or {}
        amount_cents = int(body.get("amount_cents") or 0)
        if amount_cents <= 0:
            raise HTTPException(status_code=400, detail="amount must be > 0")
        # Resolve driver by phone via Taxi service
        if _use_taxi_internal():
            try:
                driver = _call_taxi(
                    _taxi_driver_lookup,
                    need_session=True,
                    request_body=None,
                    inject_internal=True,
                    phone=phone,
                )
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(status_code=502, detail=str(e))
            driver_id = str(getattr(driver, "id", "") or "").strip()
            if not driver_id:
                raise HTTPException(status_code=502, detail="driver id missing")
        else:
            try:
                r = httpx.get(_taxi_url("/drivers/lookup"), params={"phone": phone}, headers=_taxi_headers(), timeout=10)
                r.raise_for_status()
                driver = r.json() if r.headers.get("content-type", "").startswith("application/json") else {}
            except httpx.HTTPStatusError as e:
                if e.response.status_code == 404:
                    raise HTTPException(status_code=404, detail="driver not found for phone")
                raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
            except Exception as e:
                raise HTTPException(status_code=502, detail=str(e))
            driver_id = str(driver.get("id") or "").strip()
            if not driver_id:
                raise HTTPException(status_code=502, detail="driver id missing")
        sig = _taxi_topup_sig(driver_id, amount_cents)
        payload = f"TAXI_TOPUP|driver_id={driver_id}|amount={amount_cents}|sig={sig}"
        # Log for Superadmin audit inside Taxi service (persistent)
        admin_phone = ""
        try:
            admin_phone = _auth_phone(request)
        except Exception:
            admin_phone = ""
        try:
            if _use_taxi_internal():
                log_req = _TaxiTopupQrLogOut(
                    id=str(_uuid.uuid4()),
                    driver_id=driver_id,
                    driver_phone=phone,
                    amount_cents=amount_cents,
                    created_by=admin_phone,
                    payload=payload,
                    created_at=None,
                    redeemed=False,
                    redeemed_at=None,
                    redeemed_by=None,
                )
                _call_taxi(
                    _taxi_create_topup_qr_log,
                    need_session=True,
                    request_body=None,
                    inject_internal=True,
                    req=log_req,
                )
            else:
                rlog = httpx.post(
                    _taxi_url("/topup_qr_log"),
                    json={
                        "id": str(_uuid.uuid4()),
                        "driver_id": driver_id,
                        "driver_phone": phone,
                        "amount_cents": amount_cents,
                        "created_by": admin_phone,
                        "payload": payload,
                        "created_at": None,
                        "redeemed": False,
                        "redeemed_at": None,
                        "redeemed_by": None,
                    },
                    headers=_taxi_headers(),
                    timeout=6,
                )
                rlog.raise_for_status()
        except HTTPException:
            raise
        except httpx.HTTPStatusError as e:
            raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
        except Exception as e:
            raise HTTPException(status_code=502, detail=str(e))
        _audit_from_request(request, "taxi_topup_qr_create", driver_id=driver_id, driver_phone=phone, amount_cents=amount_cents)
        return {"payload": payload, "driver_id": driver_id, "amount_cents": amount_cents, "driver_phone": phone}
    except HTTPException:
        raise
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/taxi/topup_qr/redeem")
async def taxi_topup_qr_redeem(request: Request):
    """
    Driver: redeem a taxi topup QR payload to increase driver balance.

    Body:
      - payload: string scanned from QR (TAXI_TOPUP|...)
    """
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    try:
        try:
            body = await request.json()
        except Exception:
            body = {}
        if not isinstance(body, dict):
            body = {}
        payload = (body.get("payload") or "").strip()
        if not payload or not payload.startswith("TAXI_TOPUP|"):
            raise HTTPException(status_code=400, detail="invalid payload")
        parts = payload.split("|")
        kv = {}
        for p in parts[1:]:
            if "=" in p:
                k, v = p.split("=", 1)
                kv[k] = v
        driver_id = (kv.get("driver_id") or "").strip()
        amount_raw = (kv.get("amount") or "").strip()
        sig = (kv.get("sig") or "").strip()
        if not driver_id or not amount_raw or not sig:
            raise HTTPException(status_code=400, detail="missing fields in payload")
        try:
            amount_cents = int(amount_raw)
        except Exception:
            raise HTTPException(status_code=400, detail="invalid amount")
        expected = _taxi_topup_sig(driver_id, amount_cents)
        if sig.lower() != expected.lower():
            raise HTTPException(status_code=403, detail="invalid signature")
        # Redeem and deposit in Taxi service (single-use enforced there).
        redeem_balance = None
        redeem_driver_id = driver_id
        if _use_taxi_internal():
            try:
                redeem_req = _TaxiTopupQrRedeemIn(payload=payload, driver_phone=phone, driver_id=driver_id)
                log = _call_taxi(
                    _taxi_mark_topup_qr_redeemed,
                    need_session=True,
                    request_body={"payload": payload, "driver_phone": phone, "driver_id": driver_id},
                    inject_internal=True,
                    req=redeem_req,
                )
                try:
                    redeem_balance = getattr(log, "driver_balance_cents", None)
                    redeem_driver_id = str(getattr(log, "driver_id", driver_id) or driver_id)
                except Exception:
                    redeem_driver_id = driver_id
            except HTTPException as e:
                if e.status_code == 404:
                    raise HTTPException(status_code=410, detail="QR already redeemed or invalid")
                raise
            except Exception as e:
                raise HTTPException(status_code=502, detail=str(e))
        else:
            rb = httpx.post(
                _taxi_url("/topup_qr_log/redeem"),
                json={"payload": payload, "driver_phone": phone, "driver_id": driver_id},
                headers=_taxi_headers(),
                timeout=10,
            )
            if rb.status_code == 404:
                raise HTTPException(status_code=410, detail="QR already redeemed or invalid")
            if rb.status_code >= 400:
                raise HTTPException(status_code=rb.status_code, detail=rb.text)
            try:
                bal = rb.json() if rb.headers.get("content-type", "").startswith("application/json") else {}
            except Exception:
                bal = {}
            redeem_balance = bal.get("driver_balance_cents")
            redeem_driver_id = bal.get("driver_id") or driver_id
        return {
            "ok": True,
            "amount_cents": amount_cents,
            "balance_cents": redeem_balance,
            "driver_id": redeem_driver_id,
        }
    except HTTPException:
        raise
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/taxi/topup_qr/logs")
def taxi_topup_qr_logs(limit: int = 200, request: Request = None):
    """
    Superadmin/Admin audit view of all taxi topup QRs created via the BFF.
    """
    _require_admin(request)
    try:
        if _use_taxi_internal():
            logs = _call_taxi(
                _taxi_list_topup_qr_logs,
                need_session=True,
                request_body=None,
                inject_internal=True,
                limit=max(1, min(limit, 1000)),
            )
            return {"items": logs}
        r = httpx.get(_taxi_url("/topup_qr_logs"), params={"limit": max(1, min(limit, 1000))}, headers=_taxi_headers(), timeout=10)
        arr = r.json() if r.headers.get("content-type","").startswith("application/json") else []
        if not isinstance(arr, list):
            return {"items": []}
        return {"items": arr}
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/taxi/settings")
def taxi_get_settings():
    if _use_taxi_internal():
        try:
            return _call_taxi(_taxi_get_settings, need_session=True)
        except HTTPException:
            raise
        except Exception as e:
            raise HTTPException(status_code=502, detail=str(e))
    try:
        r = httpx.get(_taxi_url("/settings"), headers=_taxi_headers(), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/taxi/settings")
async def taxi_update_settings(req: Request):
    try:
        try:
            body = await req.json()
        except Exception:
            body = None
        if _use_taxi_internal():
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                req_model = _TaxiSettingsUpdate(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            return _call_taxi(
                _taxi_update_settings,
                need_session=True,
                request_body=data,
                inject_internal=True,
                req=req_model,
            )
        r = httpx.post(_taxi_url("/settings"), json=body, headers=_taxi_headers(), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/taxi/rides/{ride_id}/rating")
async def taxi_rate_ride(ride_id: str, req: Request):
    try:
        try:
            body = await req.json()
        except Exception:
            body = None
        if _use_taxi_internal():
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                req_model = _TaxiRideRatingReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            return _call_taxi(
                _taxi_rate_ride,
                need_session=True,
                request_body=data,
                inject_internal=True,
                ride_id=ride_id,
                req=req_model,
            )
        r = httpx.post(_taxi_url(f"/rides/{ride_id}/rating"), json=body, headers=_taxi_headers(), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/taxi/drivers/{driver_id}/stats")
def taxi_driver_stats(driver_id: str, period: str = "today"):
    if _use_taxi_internal():
        try:
            return _call_taxi(
                _taxi_driver_stats,
                need_session=True,
                driver_id=driver_id,
                period=period,
            )
        except HTTPException:
            raise
        except Exception as e:
            raise HTTPException(status_code=502, detail=str(e))
    try:
        r = httpx.get(_taxi_url(f"/drivers/{driver_id}/stats"), params={"period": period}, headers=_taxi_headers(), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/taxi/admin/summary")
def taxi_admin_summary(request: Request):
    _require_operator(request, "taxi")
    if _use_taxi_internal():
        try:
            return _call_taxi(_taxi_admin_summary, need_session=True)
        except HTTPException:
            raise
        except Exception as e:
            raise HTTPException(status_code=502, detail=str(e))
    try:
        r = httpx.get(_taxi_url("/admin/summary"), headers=_taxi_headers(), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/taxi/admin/summary_cached")
def taxi_admin_summary_cached(request: Request):
    """
    Small cached variant for the Taxi admin summary.
    Reduces dashboard load when polled frequently.
    """
    global _TAXI_ADMIN_SUMMARY_CACHE
    try:
        ts = float(_TAXI_ADMIN_SUMMARY_CACHE.get("ts") or 0.0)
    except Exception:
        ts = 0.0
    # 10s TTL: reasonably fresh but reduces burst load
    if _TAXI_ADMIN_SUMMARY_CACHE.get("data") is not None and (time.time() - ts) < 10.0:
        return _TAXI_ADMIN_SUMMARY_CACHE.get("data")
    data = taxi_admin_summary(request)
    _TAXI_ADMIN_SUMMARY_CACHE = {"ts": time.time(), "data": data}
    return data


@app.post("/taxi/drivers/balance_by_identity")
async def taxi_balance_by_identity(req: Request):
    # Only admins/superadmins may adjust driver balances.
    _require_admin_v2(req)
    try:
        try:
            body = await req.json()
        except Exception:
            body = None
        if _use_taxi_internal():
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                req_model = _TaxiBalanceIdentityReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            bal = _call_taxi(
                _taxi_driver_balance_by_identity,
                need_session=True,
                request_body=data,
                inject_internal=True,
                req=req_model,
            )
        else:
            r = httpx.post(_taxi_url("/drivers/balance_by_identity"), json=body, headers=_taxi_headers(), timeout=10)
            bal = r.json()
        phone = ""
        delta = None
        try:
            if isinstance(body, dict):
                phone = (body.get("phone") or "").strip()
                delta = body.get("set_cents") or body.get("delta_cents")
        except Exception:
            pass
        _audit_from_request(req, "taxi_balance_by_identity", target_phone=phone, delta_cents=delta)
        return bal
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/taxi/drivers/{driver_id}/block")
def taxi_block_driver(driver_id: str, request: Request):
    """
    Temporarily block a taxi driver (Taxi service flag only).
    Admin/SuperAdmin only.
    """
    _require_admin(request)
    try:
        r = httpx.post(_taxi_url(f"/drivers/{driver_id}/block"), headers=_taxi_headers(), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/taxi/drivers/{driver_id}/unblock")
def taxi_unblock_driver(driver_id: str, request: Request):
    """
    Unblock a taxi driver (Taxi service flag only).
    Admin/SuperAdmin only.
    """
    _require_admin(request)
    try:
        r = httpx.post(_taxi_url(f"/drivers/{driver_id}/unblock"), headers=_taxi_headers(), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.delete("/taxi/drivers/{driver_id}")
def taxi_delete_driver(driver_id: str, request: Request):
    """
    Permanently delete a taxi driver record.
    Admin/SuperAdmin only.
    """
    _require_admin(request)
    try:
        r = httpx.delete(_taxi_url(f"/drivers/{driver_id}"), headers=_taxi_headers(), timeout=10)
        # Taxi service returns {"ok": True} on success; forward JSON or basic status.
        return r.json() if r.headers.get("content-type","").startswith("application/json") else {"status_code": r.status_code, "raw": r.text}
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/taxi/rides/{ride_id}/assign")
def taxi_assign_ride(ride_id: str, driver_id: str):
    if _use_taxi_internal():
        try:
            return _call_taxi(
                _taxi_assign_ride,
                need_session=True,
                request_body=None,
                inject_internal=True,
                ride_id=ride_id,
                driver_id=driver_id,
            )
        except HTTPException:
            raise
        except Exception as e:
            raise HTTPException(status_code=502, detail=str(e))
    try:
        r = httpx.post(_taxi_url(f"/rides/{ride_id}/assign"), params={"driver_id": driver_id}, headers=_taxi_headers(), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/taxi/rides/{ride_id}")
def taxi_get_ride(ride_id: str):
    if _use_taxi_internal():
        try:
            return _call_taxi(_taxi_get_ride, need_session=True, ride_id=ride_id)
        except HTTPException:
            raise
        except Exception as e:
            raise HTTPException(status_code=502, detail=str(e))
    try:
        r = httpx.get(_taxi_url(f"/rides/{ride_id}"), headers=_taxi_headers(), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/taxi/rides/{ride_id}/accept")
def taxi_accept_ride(ride_id: str, driver_id: str):
    if _use_taxi_internal():
        try:
            return _call_taxi(
                _taxi_accept_ride,
                need_session=True,
                request_body=None,
                inject_internal=True,
                ride_id=ride_id,
                driver_id=driver_id,
            )
        except HTTPException:
            raise
        except Exception as e:
            raise HTTPException(status_code=502, detail=str(e))
    try:
        r = httpx.post(_taxi_url(f"/rides/{ride_id}/accept"), params={"driver_id": driver_id}, headers=_taxi_headers(), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/taxi/rides/{ride_id}/start")
def taxi_start_ride(ride_id: str, driver_id: str):
    if _use_taxi_internal():
        try:
            return _call_taxi(
                _taxi_start_ride,
                need_session=True,
                request_body=None,
                inject_internal=True,
                ride_id=ride_id,
                driver_id=driver_id,
            )
        except HTTPException:
            raise
        except Exception as e:
            raise HTTPException(status_code=502, detail=str(e))
    try:
        r = httpx.post(_taxi_url(f"/rides/{ride_id}/start"), params={"driver_id": driver_id}, headers=_taxi_headers(), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/taxi/rides/{ride_id}/complete")
def taxi_complete_ride(ride_id: str, driver_id: str):
    try:
        if _use_taxi_internal():
            result_obj = _call_taxi(
                _taxi_complete_ride,
                need_session=True,
                request_body=None,
                inject_internal=True,
                ride_id=ride_id,
                driver_id=driver_id,
            )
            result = result_obj
            try:
                rd = result_obj.dict() if hasattr(result_obj, "dict") else result_obj  # type: ignore[call-arg]
            except Exception:
                rd = {}
        else:
            r = httpx.post(_taxi_url(f"/rides/{ride_id}/complete"), params={"driver_id": driver_id}, headers=_taxi_headers(), timeout=10)
            result = r.json() if r.headers.get('content-type','').startswith('application/json') else {"raw": r.text, "status_code": r.status_code}
            # Fetch ride details to determine amount and rider wallet
            rd = httpx.get(_taxi_url(f"/rides/{ride_id}"), headers=_taxi_headers(), timeout=10).json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))

    # Best-effort escrow settlement (rider -> escrow -> driver) with guardrail.
    try:
        price_cents = None
        rider_wallet = None
        driver_wallet = None
        driver_id = driver_id  # for guardrail closure
        try:
            price_cents = int(rd.get("price_cents")) if rd and isinstance(rd, dict) else None
        except Exception:
            price_cents = getattr(result_obj, "price_cents", None) if "result_obj" in locals() else None  # type: ignore[arg-type]
        try:
            rider_wallet = (rd.get("rider_wallet_id") if isinstance(rd, dict) else None) or getattr(result_obj, "rider_wallet_id", None)  # type: ignore[arg-type]
            driver_wallet = (rd.get("driver_wallet_id") if isinstance(rd, dict) else None) or getattr(result_obj, "driver_wallet_id", None)  # type: ignore[arg-type]
        except Exception:
            rider_wallet = getattr(result_obj, "rider_wallet_id", None) if "result_obj" in locals() else None  # type: ignore[arg-type]
            driver_wallet = getattr(result_obj, "driver_wallet_id", None) if "result_obj" in locals() else None  # type: ignore[arg-type]
        if ESCROW_WALLET_ID and PAYMENTS_BASE and price_cents and rider_wallet and driver_wallet and price_cents > 0:
            now = int(time.time())
            lst = _TAXI_PAYOUT_EVENTS.get(driver_id, [])
            lst = [ts for ts in lst if ts >= now - 86400]
            if len(lst) < TAXI_PAYOUT_MAX_PER_DRIVER_DAY:
                lst.append(now)
                _TAXI_PAYOUT_EVENTS[driver_id] = lst
                url = _payments_url("/transfer")
                headers = {"Content-Type": "application/json"}
                leg1 = {"from_wallet_id": rider_wallet, "to_wallet_id": ESCROW_WALLET_ID, "amount_cents": price_cents}
                leg2 = {"from_wallet_id": ESCROW_WALLET_ID, "to_wallet_id": driver_wallet, "amount_cents": price_cents}
                headers1 = headers | {"Idempotency-Key": f"tx-escrow-r-{ride_id}-{price_cents}"}
                headers2 = headers | {"Idempotency-Key": f"tx-escrow-d-{ride_id}-{price_cents}"}
                httpx.post(url, json=leg1, headers=headers1, timeout=10)
                httpx.post(url, json=leg2, headers=headers2, timeout=10)
            else:
                _TAXI_PAYOUT_EVENTS[driver_id] = lst
    except Exception:
        # Settlement is best-effort; ride completion result still returned.
        pass

    return result


@app.post("/taxi/rides/{ride_id}/cancel")
def taxi_cancel_ride(ride_id: str):
    try:
        if _use_taxi_internal():
            result_obj = _call_taxi(
                _taxi_cancel_ride,
                need_session=True,
                request_body=None,
                inject_internal=True,
                ride_id=ride_id,
            )
            result = result_obj
        else:
            r = httpx.post(_taxi_url(f"/rides/{ride_id}/cancel"), headers=_taxi_headers(), timeout=10)
            # Base response from Taxi service (ride object or raw payload)
            result = r.json() if r.headers.get("content-type",""
                     ).startswith("application/json") else {"raw": r.text, "status_code": r.status_code}
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))

    # Best-effort cancellation fee charge (4000 SYP by default).
    # Guardrail: basic per-driver daily limit; never breaks cancellation.
    try:
        fee_syp = max(0, TAXI_CANCEL_FEE_SYP)
        if not PAYMENTS_BASE or fee_syp <= 0:
            return result
        # Fetch latest ride details to resolve wallets/phone/driver
        if _use_taxi_internal():
            ride_obj = _call_taxi(_taxi_get_ride, need_session=True, ride_id=ride_id)
            try:
                ride = ride_obj.dict() if hasattr(ride_obj, "dict") else ride_obj  # type: ignore[call-arg]
            except Exception:
                ride = {}
        else:
            rd = httpx.get(_taxi_url(f"/rides/{ride_id}"), headers=_taxi_headers(), timeout=10)
            ride = rd.json() if rd.headers.get("content-type",""
                         ).startswith("application/json") else {}
        if not isinstance(ride, dict):
            return result
        driver_id = (ride.get("driver_id") or "").strip()
        if not driver_id:
            # No assigned driver -> no cancellation fee
            return result
        amount_cents = int(fee_syp * 100)
        if amount_cents <= 0:
            return result
        # Resolve driver wallet (prefer field from ride, then driver lookup)
        driver_wallet = (ride.get("driver_wallet_id") or "").strip()
        if not driver_wallet and driver_id:
            try:
                dj = httpx.get(_taxi_url(f"/drivers/{driver_id}"), headers=_taxi_headers(), timeout=10)
                if dj.headers.get("content-type",""
                         ).startswith("application/json"):
                    d = dj.json()
                    if isinstance(d, dict):
                        driver_wallet = (d.get("wallet_id") or "").strip()
            except Exception:
                driver_wallet = ""
        if not driver_wallet:
            return result
        # Resolve rider wallet (prefer wallet_id, then resolve by phone)
        rider_wallet = (ride.get("rider_wallet_id") or "").strip()
        if not rider_wallet:
            phone = (ride.get("rider_phone") or "").strip()
            if phone:
                try:
                    rr = httpx.get(
                        _payments_url(f"/resolve/phone/{phone}"),
                        headers=_payments_headers(),
                        timeout=10,
                    )
                    if rr.headers.get("content-type",""
                             ).startswith("application/json"):
                        j = rr.json()
                        if isinstance(j, dict):
                            rider_wallet = (j.get("wallet_id") or "").strip()
                except Exception:
                    rider_wallet = ""
        if not rider_wallet:
            return result
        # Per-driver guardrail for cancellation fee transfers
        try:
            now = _now()
            events = _TAXI_CANCEL_EVENTS.get(driver_id) or []
            events = [ts for ts in events if ts >= now - 86400]
            if len(events) >= max(1, TAXI_CANCEL_MAX_PER_DRIVER_DAY):
                _TAXI_CANCEL_EVENTS[driver_id] = events
                _audit("taxi_cancel_guardrail", driver_id=driver_id, ride_id=ride_id, amount_cents=amount_cents)
                return result
            events.append(now)
            _TAXI_CANCEL_EVENTS[driver_id] = events
        except Exception:
            pass
        ikey = f"tx-taxi-cancel-{ride_id}-{amount_cents}"
        headers = {"content-type": "application/json", "Idempotency-Key": ikey}
        body = {
            "from_wallet_id": rider_wallet,
            "to_wallet_id": driver_wallet,
            "amount_cents": amount_cents,
            "reference": f"taxi {ride_id} cancel fee",
        }
        httpx.post(
            _payments_url("/transfer"),
            json=body,
            headers=_payments_headers(headers),
            timeout=10,
        )
    except Exception:
        # Best-effort: never break cancellation result on fee issues
        return result

    return result


@app.post("/taxi/rides/{ride_id}/deny")
def taxi_deny_ride(ride_id: str):
    """Driver denies current ride request: cancel and re-request to allow next nearest driver to receive it.
    This assumes upstream Taxi service matches to nearest available driver on request.
    """
    try:
        # Fetch original ride to extract pickup/dropoff
        if _use_taxi_internal():
            try:
                orig_obj = _call_taxi(_taxi_get_ride, need_session=True, ride_id=ride_id)
                orig = orig_obj.dict() if hasattr(orig_obj, "dict") else orig_obj  # type: ignore[call-arg]
            except Exception:
                orig = {}
            try:
                _call_taxi(
                    _taxi_cancel_ride,
                    need_session=True,
                    request_body=None,
                    inject_internal=True,
                    ride_id=ride_id,
                )
            except Exception:
                pass
        else:
            r0 = httpx.get(_taxi_url(f"/rides/{ride_id}"), headers=_taxi_headers(), timeout=10)
            orig = r0.json() if r0.headers.get("content-type",""
                     ).startswith("application/json") else {}
            # Cancel existing ride (ignore errors)
            try:
                httpx.post(_taxi_url(f"/rides/{ride_id}/cancel"), headers=_taxi_headers(), timeout=10)
            except Exception:
                pass
    except Exception:
        orig = {}
    # Build new request from original coordinates if available
    body = {}
    def _to_f(v):
        try:
            if v is None:
                return None
            if isinstance(v, (int, float)):
                return float(v)
            return float(str(v))
        except Exception:
            return None
    pickup = orig.get('pickup') if isinstance(orig, dict) else None
    dropoff = orig.get('dropoff') if isinstance(orig, dict) else None
    body['pickup_lat'] = _to_f(orig.get('pickup_lat') or (pickup or {}).get('lat')) or 0.0
    body['pickup_lon'] = _to_f(orig.get('pickup_lon') or (pickup or {}).get('lon') or (pickup or {}).get('lng')) or 0.0
    dl = _to_f(orig.get('dropoff_lat') or (dropoff or {}).get('lat'))
    dlo = _to_f(orig.get('dropoff_lon') or (dropoff or {}).get('lon') or (dropoff or {}).get('lng'))
    if dl is not None and dlo is not None:
        body['dropoff_lat'] = dl
        body['dropoff_lon'] = dlo
    try:
        if _use_taxi_internal():
            try:
                req_model = _TaxiRideRequest(**body)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            result = _call_taxi(
                _taxi_request_ride,
                need_session=True,
                request_body=body,
                inject_internal=True,
                req=req_model,
                idempotency_key=None,
            )
            return result
        r = httpx.post(_taxi_url("/rides/request"), json=body, headers=_taxi_headers(), timeout=10)
        return r.json() if r.headers.get("content-type",""
                 ).startswith("application/json") else {"raw": r.text, "status_code": r.status_code}
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


# ---- Payments proxy helpers ----
def _payments_url(path: str) -> str:
    if not PAYMENTS_BASE:
        raise HTTPException(status_code=500, detail="PAYMENTS_BASE_URL not configured")
    return PAYMENTS_BASE.rstrip("/") + path

# ---- Bus proxy helpers ----
def _bus_url(path: str) -> str:
    if not BUS_BASE:
        raise HTTPException(status_code=500, detail="BUS_BASE_URL not configured")
    return BUS_BASE.rstrip("/") + path


# --- Bus internal service (monolith mode) ---
_BUS_INTERNAL_AVAILABLE = False
try:
    from sqlalchemy.orm import Session as _BusSession  # type: ignore[import]
    from apps.bus.app import main as _bus_main  # type: ignore[import]
    from apps.bus.app.main import (  # type: ignore[import]
        engine as _bus_engine,
        get_session as _bus_get_session,
        BookReq as _BusBookReq,
        BoardReq as _BusBoardReq,
        CityIn as _BusCityIn,
        OperatorIn as _BusOperatorIn,
        RouteIn as _BusRouteIn,
        TripIn as _BusTripIn,
        operator_online as _bus_operator_online,
        operator_offline as _bus_operator_offline,
        list_cities as _bus_list_cities,
        create_city as _bus_create_city,
        list_operators as _bus_list_operators,
        create_operator as _bus_create_operator,
        create_route as _bus_create_route,
        list_routes as _bus_list_routes,
        create_trip as _bus_create_trip,
        search_trips as _bus_search_trips,
        trip_detail as _bus_trip_detail,
        publish_trip as _bus_publish_trip,
        unpublish_trip as _bus_unpublish_trip,
        cancel_trip as _bus_cancel_trip,
        quote as _bus_quote,
        book_trip as _bus_book_trip,
        booking_status as _bus_booking_status,
        booking_tickets as _bus_booking_tickets,
        booking_search as _bus_booking_search,
        cancel_booking as _bus_cancel_booking,
        ticket_board as _bus_ticket_board,
        operator_trips as _bus_operator_trips,
        operator_stats as _bus_operator_stats,
        admin_summary as _bus_admin_summary,
    )
    _BUS_INTERNAL_AVAILABLE = True
except Exception:
    _BusSession = None  # type: ignore[assignment]
    _bus_main = None  # type: ignore[assignment]
    _bus_engine = None  # type: ignore[assignment]
    _BUS_INTERNAL_AVAILABLE = False


def _use_bus_internal() -> bool:
    if _force_internal(_BUS_INTERNAL_AVAILABLE):
        return True
    mode = os.getenv("BUS_INTERNAL_MODE", "auto").lower()
    if mode == "off":
        return False
    if not _BUS_INTERNAL_AVAILABLE:
        return False
    if mode == "on":
        return True
    return not bool(BUS_BASE)


def _bus_internal_session():
    if not _BUS_INTERNAL_AVAILABLE or _BusSession is None or _bus_engine is None:  # type: ignore[truthy-function]
        raise RuntimeError("Bus internal service not available")
    return _BusSession(_bus_engine)  # type: ignore[call-arg]


def _resolve_wallet_id_for_phone(phone: str) -> str | None:
    """
    Resolve a wallet_id for the given phone via Payments (internal or HTTP).
    Best-effort: returns None when unavailable or not found.
    """
    phone = (phone or "").strip()
    if not phone:
        return None
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                return None
            with _pay_internal_session() as s:  # type: ignore[name-defined]
                res = _pay_resolve_phone(phone=phone, s=s)  # type: ignore[name-defined]
                try:
                    wid = getattr(res, "wallet_id", None) or getattr(res, "id", None)
                except Exception:
                    wid = None
                return (wid or "").strip() or None
        if PAYMENTS_BASE:
            r = httpx.get(
                _payments_url(f"/resolve/phone/{phone}"),
                headers=_payments_headers(),
                timeout=6,
            )
            if r.status_code == 200 and r.headers.get("content-type", "").startswith("application/json"):
                try:
                    j = r.json()
                    if isinstance(j, dict):
                        wid = (j.get("wallet_id") or j.get("id") or "").strip()
                        return wid or None
                except Exception:
                    return None
    except HTTPException:
        raise
    except Exception:
        return None
    return None


def _require_caller_wallet(request: Request) -> tuple[str, str]:
    """
    Require an authenticated caller and resolve the caller-owned wallet id.
    """
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    wallet_id = _resolve_wallet_id_for_phone(phone)
    if not wallet_id:
        raise HTTPException(status_code=403, detail="wallet not found for caller")
    return phone, wallet_id


def _bus_operator_ids_for_phone(phone: str) -> list[str]:
    """
    Return all bus operator IDs that belong to the caller's wallet.
    """
    wid = _resolve_wallet_id_for_phone(phone)
    if not wid:
        return []
    try:
        if _use_bus_internal():
            if not _BUS_INTERNAL_AVAILABLE:
                return []
            with _bus_internal_session() as s:  # type: ignore[name-defined]
                ops = _bus_list_operators(limit=200, s=s)  # type: ignore[name-defined]
                out: list[str] = []
                for op in ops or []:
                    try:
                        if str(getattr(op, "wallet_id", "") or "").strip() != wid:
                            continue
                        oid = str(getattr(op, "id", "") or "").strip()
                        if oid:
                            out.append(oid)
                    except Exception:
                        continue
                return out
        if BUS_BASE:
            r = httpx.get(_bus_url("/operators"), timeout=10)
            if r.headers.get("content-type", "").startswith("application/json"):
                arr = r.json()
                if isinstance(arr, list):
                    out = []
                    for op in arr:
                        try:
                            if str((op.get("wallet_id") or "")).strip() != wid:
                                continue
                            oid = str((op.get("id") or "")).strip()
                            if oid:
                                out.append(oid)
                        except Exception:
                            continue
                    return out
    except HTTPException:
        raise
    except Exception:
        return []
    return []


def _bus_all_operator_ids() -> list[str]:
    """
    Helper to list all bus operators (used in dev/test to relax ownership checks).
    """
    try:
        if _use_bus_internal():
            if not _BUS_INTERNAL_AVAILABLE:
                return []
            with _bus_internal_session() as s:  # type: ignore[name-defined]
                ops = _bus_list_operators(limit=200, s=s)  # type: ignore[name-defined]
                return [str(getattr(op, "id", "") or "").strip() for op in ops or [] if getattr(op, "id", None)]
        if BUS_BASE:
            r = httpx.get(_bus_url("/operators"), timeout=10)
            if r.headers.get("content-type", "").startswith("application/json"):
                arr = r.json()
                if isinstance(arr, list):
                    return [str((op.get("id") or "")).strip() for op in arr if (op.get("id") or "").strip()]
    except Exception:
        return []
    return []


def _bus_route_owner(route_id: str) -> str | None:
    """
    Resolve the operator_id owning a given route.
    """
    rid = (route_id or "").strip()
    if not rid:
        return None
    try:
        if _use_bus_internal():
            if not _BUS_INTERNAL_AVAILABLE:
                return None
            with _bus_internal_session() as s:  # type: ignore[name-defined]
                routes = _bus_list_routes(origin_city_id=None, dest_city_id=None, s=s)  # type: ignore[name-defined]
                for rt in routes or []:
                    try:
                        if str(getattr(rt, "id", "") or "").strip() != rid:
                            continue
                        return str(getattr(rt, "operator_id", "") or "").strip() or None
                    except Exception:
                        continue
        elif BUS_BASE:
            r = httpx.get(_bus_url("/routes"), timeout=10)
            if r.headers.get("content-type", "").startswith("application/json"):
                arr = r.json()
                if isinstance(arr, list):
                    for rt in arr:
                        try:
                            if str((rt.get("id") or "")).strip() != rid:
                                continue
                            return str((rt.get("operator_id") or "")).strip() or None
                        except Exception:
                            continue
    except HTTPException:
        raise
    except Exception:
        return None
    return None


def _bus_trip_route_id(trip_id: str) -> str | None:
    """
    Resolve the route_id for a given trip.
    """
    tid = (trip_id or "").strip()
    if not tid:
        return None
    try:
        if _use_bus_internal():
            if not _BUS_INTERNAL_AVAILABLE:
                return None
            with _bus_internal_session() as s:  # type: ignore[name-defined]
                trip = _bus_trip_detail(trip_id=tid, s=s)  # type: ignore[name-defined]
                try:
                    return str(getattr(trip, "route_id", "") or "").strip() or None
                except Exception:
                    return None
        if BUS_BASE:
            r = httpx.get(_bus_url(f"/trips/{tid}"), timeout=10)
            if r.status_code == 404:
                return None
            if r.headers.get("content-type", "").startswith("application/json"):
                try:
                    j = r.json()
                    if isinstance(j, dict):
                        return str((j.get("route_id") or "")).strip() or None
                except Exception:
                    return None
    except HTTPException:
        raise
    except Exception:
        return None
    return None


@app.get("/qr.png")
def qr_png(data: str, box_size: int = 6, border: int = 2):
    if not data:
        raise HTTPException(status_code=400, detail="missing data")
    if _qr is None:
        raise HTTPException(status_code=500, detail="QR library not available")
    try:
        qr = _qr.QRCode(error_correction=_qr.constants.ERROR_CORRECT_M, box_size=max(1, min(int(box_size), 20)), border=max(1, min(int(border), 8)))
        qr.add_data(data)
        qr.make(fit=True)
        img = qr.make_image(fill_color="black", back_color="white")
        buf = BytesIO(); img.save(buf, format='PNG'); buf.seek(0)
        return StreamingResponse(buf, media_type='image/png')
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/bus/health")
def bus_health():
    """
    Bus health: prefer the internal Bus service when running in monolith
    mode; otherwise proxy to an external BUS_BASE_URL if configured.
    """
    # Internal Bus (monolith mode)
    if _use_bus_internal():
        if not _BUS_INTERNAL_AVAILABLE:
            raise HTTPException(status_code=500, detail="bus internal not available")
        # For now we keep the check simple: if the internal bus service is
        # importable we report a light-weight OK marker. Detailed DB/route
        # checks are handled via /bus/admin/summary.
        return {"status": "ok", "mode": "internal"}
    # External bus-api
    try:
        r = httpx.get(_bus_url("/health"), timeout=10)
        return r.json() if r.headers.get('content-type','').startswith('application/json') else {"raw": r.text, "status_code": r.status_code}
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


# ---- Topup Kiosk proxies ----
@app.post("/topup/batch_create")
async def topup_batch_create(req: Request):
    if not PAYMENTS_BASE and not _use_pay_internal():
        raise HTTPException(status_code=500, detail="PAYMENTS_BASE_URL not configured")
    # Require authenticated seller (allowlist if configured)
    seller_phone = _require_seller(req)
    try:
        body = await req.json()
    except Exception:
        body = None
    # Accept amount_syp/amount and convert
    body = _normalize_amount(body)
    if isinstance(body, dict) and 'seller_id' not in body:
        body['seller_id'] = seller_phone
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                req_model = _PayTopupBatchCreateReq(**data)  # type: ignore[name-defined]
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _pay_internal_session() as s:
                return _pay_topup_batch_create(req_model, s=s, admin_ok=True)
        r = httpx.post(
            _payments_url("/topup/batch_create"),
            json=body,
            headers=_payments_headers(),
            timeout=20,
        )
        return r.json() if r.headers.get('content-type','').startswith('application/json') else {"raw": r.text, "status_code": r.status_code}
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/topup/batches")
def topup_batches(request: Request, seller_id: str = "", limit: int = 50):
    # Default to current seller unless allow_all or explicit seller_id provided
    if not seller_id:
        try:
            seller_id = _require_seller(request)
        except HTTPException:
            seller_id = ""
    try:
        params = {}
        if seller_id:
            params["seller_id"] = seller_id
        params["limit"] = max(1, min(limit, 2000))
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            with _pay_internal_session() as s:
                return _pay_topup_batches(seller_id=seller_id or None, limit=max(1, min(limit, 2000)), s=s, admin_ok=True)
        r = httpx.get(
            _payments_url("/topup/batches"),
            params=params,
            headers=_payments_headers(),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/topup/batches/{batch_id}")
def topup_batch_detail(request: Request, batch_id: str):
    # Ensure seller is authenticated; payments returns full list, BFF only exposes via auth
    _require_seller(request)
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            with _pay_internal_session() as s:
                return _pay_topup_batch_detail(batch_id=batch_id, s=s, admin_ok=True)
        r = httpx.get(
            _payments_url(f"/topup/batches/{batch_id}"),
            headers=_payments_headers(),
            timeout=15,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/topup/vouchers/{code}/void")
async def topup_voucher_void(request: Request, code: str):
    # Nur Superadmin darf Vouchers invalidieren.
    _require_superadmin(request)
    if not PAYMENTS_INTERNAL_SECRET:
        raise HTTPException(status_code=403, detail="Server not configured for voucher admin")
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            with _pay_internal_session() as s:
                result = _pay_topup_voucher_void(code=code, s=s, admin_ok=True)
        else:
            r = httpx.post(
                _payments_url(f"/topup/vouchers/{code}/void"),
                headers=_payments_headers(),
                timeout=10,
            )
            result = r.json()
        _audit_from_request(request, "topup_voucher_void", code=code)
        return result
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/topup/redeem")
async def topup_redeem(req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    headers = {}
    try:
        ikey = req.headers.get("Idempotency-Key") if hasattr(req, 'headers') else None
    except Exception:
        ikey = None
    if ikey:
        headers["Idempotency-Key"] = ikey
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                treq = _PayTopupRedeemReq(**data)  # type: ignore[name-defined]
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _pay_internal_session() as s:
                return _pay_topup_redeem(treq, s=s)
        r = httpx.post(
            _payments_url("/topup/redeem"),
            json=body,
            headers=_payments_headers(headers),
            timeout=12,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/topup/print/{batch_id}", response_class=HTMLResponse)
def topup_print(batch_id: str):
    """
    Printable QR sheet for a topup batch.

    In monolith/internal mode this uses the Payments domain directly;
    otherwise it falls back to the external PAYMENTS_BASE_URL.
    """
    # Fetch vouchers and render printable QR grid
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            with _pay_internal_session() as s:  # type: ignore[name-defined]
                rows = _pay_topup_batch_detail(batch_id=batch_id, s=s, admin_ok=True)  # type: ignore[name-defined]
                # rows is a list of Pydantic models; normalise to dicts
                arr = []
                for it in rows:
                    try:
                        arr.append(it.dict())  # type: ignore[call-arg]
                    except Exception:
                        arr.append({
                            "code": getattr(it, "code", ""),
                            "amount_cents": getattr(it, "amount_cents", 0),
                            "payload": getattr(it, "payload", ""),
                        })
        else:
            r = httpx.get(
                _payments_url(f"/topup/batches/{batch_id}"),
                headers=_payments_headers(),
                timeout=15,
            )
            arr = r.json() if r.headers.get('content-type','').startswith('application/json') else []
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=f"fetch batch failed: {e}")
    title = f"Topup Batch {batch_id}"
    rows = []
    for v in arr:
        payload = v.get('payload','')
        code = v.get('code','')
        amt = int(v.get('amount_cents',0))
        rows.append(f"<div class=\"card\"><img src=\"/qr.png?data={_json.dumps(payload)[1:-1]}\" /><div class=\"meta\"><b>{code}</b><br/><small>{amt} SYP</small></div></div>")
    html = f"""
<!doctype html>
<html><head><meta charset=utf-8 /><meta name=viewport content='width=device-width, initial-scale=1' />
<title>{title}</title>
<style>
  body{{font-family:sans-serif;margin:16px}}
  .grid{{display:grid;grid-template-columns:repeat(auto-fill,minmax(180px,1fr));gap:12px}}
  .card{{border:1px solid #ddd;border-radius:8px;padding:8px;text-align:center}}
  img{{width:160px;height:160px;}}
  .meta{{margin-top:6px;color:#333}}
  @media print{{ .no-print{{display:none}} body{{margin:0}} }}
  .toolbar{{position:sticky;top:0;background:#fff;padding:8px 0;margin-bottom:8px;border-bottom:1px solid #eee}}
  button{{padding:8px 12px;border-radius:6px;border:1px solid #999;background:#f7f7f7;cursor:pointer}}
  button:hover{{background:#eee}}
  small{{color:#666}}
  h1{{font-size:18px;margin:6px 0}}
  .sub{{color:#666;font-size:12px}}
  .wrap{{max-width:1024px;margin:0 auto}}
</style></head>
<body>
<div class=\"wrap\">
  <div class=\"toolbar no-print\"><button onclick=\"window.print()\">Print</button></div>
  <h1>{title}</h1>
  <div class=\"sub\">Printable QR vouchers</div>
  <div class=\"grid\">{''.join(rows)}</div>
</div>
</body></html>
"""
    return HTMLResponse(content=html)


# ---- Admin: Roles management (proxies to Payments) ----
@app.get("/admin/roles")
def bff_roles_list(request: Request, phone: str = "", role: str = "", limit: int = 200):
    _require_admin_v2(request)
    params = {"limit": max(1, min(limit, 1000))}
    if phone:
        params["phone"] = phone
    if role:
        params["role"] = role
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            try:
                with _pay_internal_session() as s:
                    return _pay_roles_list(phone=phone or None, role=role or None, limit=max(1, min(limit, 1000)), s=s, admin_ok=True)
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(status_code=502, detail=str(e))
        r = httpx.get(
            _payments_url("/admin/roles"),
            params=params,
            headers=_payments_headers(),
            timeout=10,
        )
        return r.json()
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/admin/ids_for_phone")
def admin_ids_for_phone(request: Request, phone: str):
    """
    Superadmin helper: returns core IDs associated with a phone number.

    - payments user_id / wallet_id
    - taxi driver_id(s)
    - bus operator_id(s) (matched by wallet_id)
    - stays operator_id(s) (matched by phone)
    - effective roles + admin/superadmin flags
    """
    _require_superadmin(request)
    phone = (phone or "").strip()
    if not phone:
        raise HTTPException(status_code=400, detail="phone required")

    user_id: str | None = None
    wallet_id: str | None = None
    roles: list[str] = []
    driver_ids: list[str] = []
    bus_operator_ids: list[str] = []
    stays_operator_ids: list[str] = []

    # Effective roles (from Payments or local allowlists)
    try:
        roles = _get_effective_roles(phone)
    except Exception:
        roles = []

    # Payments: resolve phone -> (user_id, wallet_id)
    try:
        if _use_pay_internal():
            if _PAY_INTERNAL_AVAILABLE:
                with _pay_internal_session() as s:  # type: ignore[name-defined]
                    try:
                        res = _pay_resolve_phone(phone=phone, s=s)  # type: ignore[name-defined]
                        user_id = getattr(res, "user_id", None)
                        wallet_id = getattr(res, "wallet_id", None)
                    except HTTPException:
                        # phone/wallet not found is allowed
                        user_id = None
                        wallet_id = None
        elif PAYMENTS_BASE:
            r = httpx.get(
                _payments_url(f"/resolve/phone/{phone}"),
                headers=_payments_headers(),
                timeout=6,
            )
            if r.status_code == 200 and r.headers.get("content-type", "").startswith("application/json"):
                try:
                    j = r.json()
                    if isinstance(j, dict):
                        uid = (j.get("user_id") or "").strip()
                        wid = (j.get("wallet_id") or "").strip()
                        user_id = uid or None
                        wallet_id = wid or None
                except Exception:
                    pass
    except Exception:
        user_id = user_id or None
        wallet_id = wallet_id or None

    # Taxi: find drivers by phone
    try:
        if _use_taxi_internal():
            if not _TAXI_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="taxi internal not available")
            drivers = _call_taxi(  # type: ignore[arg-type]
                _taxi_list_drivers,  # type: ignore[name-defined]
                need_session=True,
                status="",
                limit=500,
            )
            for d in drivers or []:
                try:
                    ph = str(getattr(d, "phone", "") or "").strip()
                    if ph != phone:
                        continue
                    did = str(getattr(d, "id", "") or "").strip()
                    if did and did not in driver_ids:
                        driver_ids.append(did)
                except Exception:
                    continue
        elif TAXI_BASE:
            params = {"status": "", "limit": 500}
            r = httpx.get(_taxi_url("/drivers"), params=params, headers=_taxi_headers(), timeout=10)
            if r.headers.get("content-type", "").startswith("application/json"):
                arr = r.json()
                if isinstance(arr, list):
                    for d in arr:
                        try:
                            ph = str((d.get("phone") or "")).strip()
                            if ph != phone:
                                continue
                            did = str(d.get("id") or "").strip()
                            if did and did not in driver_ids:
                                driver_ids.append(did)
                        except Exception:
                            continue
    except HTTPException:
        raise
    except Exception:
        driver_ids = driver_ids or []

    # Bus operators: match by wallet_id (if available)
    try:
        if wallet_id:
            if _use_bus_internal():
                if not _BUS_INTERNAL_AVAILABLE:
                    raise HTTPException(status_code=500, detail="bus internal not available")
                with _bus_internal_session() as s:  # type: ignore[name-defined]
                    ops = _bus_list_operators(limit=200, s=s)  # type: ignore[name-defined]
                    for op in ops or []:
                        try:
                            wid = str(getattr(op, "wallet_id", "") or "").strip()
                            if wid != wallet_id:
                                continue
                            oid = str(getattr(op, "id", "") or "").strip()
                            if oid and oid not in bus_operator_ids:
                                bus_operator_ids.append(oid)
                        except Exception:
                            continue
            elif BUS_BASE:
                r = httpx.get(_bus_url("/operators"), timeout=10)
                if r.headers.get("content-type", "").startswith("application/json"):
                    arr = r.json()
                    if isinstance(arr, list):
                        for op in arr:
                            try:
                                wid = str((op.get("wallet_id") or "")).strip()
                                if wid != wallet_id:
                                    continue
                                oid = str(op.get("id") or "").strip()
                                if oid and oid not in bus_operator_ids:
                                    bus_operator_ids.append(oid)
                            except Exception:
                                continue
    except HTTPException:
        raise
    except Exception:
        bus_operator_ids = bus_operator_ids or []

    # Stays operators: match by phone (internal only for now)
    try:
        if _use_stays_internal():
            if not _STAYS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="stays internal not available")
            from apps.stays.app.main import Operator as _StaysOperator  # type: ignore[import]
            with _stays_internal_session() as s:  # type: ignore[name-defined]
                try:
                    rows = s.execute(
                        select(_StaysOperator).where(_StaysOperator.phone == phone)
                    ).scalars().all()
                except Exception:
                    rows = []
                for op in rows or []:
                    try:
                        oid = str(getattr(op, "id", "") or "").strip()
                        if oid and oid not in stays_operator_ids:
                            stays_operator_ids.append(oid)
                    except Exception:
                        continue
    except HTTPException:
        raise
    except Exception:
        stays_operator_ids = stays_operator_ids or []

    # Admin / Superadmin IDs: reuse payments user_id when role is present
    is_admin = _hasAdminRole(roles) if roles else False
    is_superadmin = _hasSuperadminRole(roles) if roles else False
    admin_id = user_id if is_admin else None
    superadmin_id = user_id if is_superadmin else None

    return {
        "phone": phone,
        "user_id": user_id,
        "wallet_id": wallet_id,
        "roles": roles,
        "driver_ids": driver_ids,
        "bus_operator_ids": bus_operator_ids,
        "stays_operator_ids": stays_operator_ids,
        "admin_id": admin_id,
        "superadmin_id": superadmin_id,
        "is_admin": is_admin,
        "is_superadmin": is_superadmin,
    }
@app.post("/admin/roles")
async def bff_roles_add(request: Request):
    _require_superadmin(request)
    try:
        body = await request.json()
    except Exception:
        body = None
    try:
        target_phone = ""
        target_role = ""
        try:
            if isinstance(body, dict):
                target_phone = (body.get("phone") or "").strip()
                target_role = (body.get("role") or "").strip()
        except Exception:
            target_phone = ""
            target_role = ""
        # Best-effort: ensure a user/wallet exists for this phone before
        # assigning roles. This makes the Superadmin "Grant role" button
        # robust even if the operator phone was never used in Payments before.
        try:
            if target_phone:
                dummy_req = Request({"type": "http", "headers": []})  # minimal ASGI scope
                # Monkey-patch json() to return our payload for internal call.
                async def _json_phone():
                    return {"phone": target_phone}
                setattr(dummy_req, "json", _json_phone)
                await payments_create_user(dummy_req)  # ignore result; idempotent
        except Exception:
            # Ignore failures here; /admin/roles will still return proper error details.
            pass
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                ru = _PayRoleUpsert(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            try:
                with _pay_internal_session() as s:
                    return _pay_roles_add(body=ru, s=s, admin_ok=True)
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(status_code=502, detail=str(e))
        r = httpx.post(
            _payments_url("/admin/roles"),
            json=body,
            headers=_payments_headers(),
            timeout=10,
        )
        resp = r.json()
        _audit_from_request(request, "admin_role_add", target_phone=target_phone, target_role=target_role)
        return resp
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


class BusOperatorCreateReq(BaseModel):
    phone: str
    company_name: str


@app.post("/admin/bus/operator")
async def admin_bus_operator_create(request: Request):
    """
    Create or link a Bus operator for a given phone number.

    - Ensures a Payments user/wallet exists for the phone.
    - Creates a Bus operator (if none exists for that wallet yet) and
      links it to the wallet_id.
    - Grants the \"operator_bus\" role to the phone.

    This endpoint is intended for Admin/Superadmin use from the
    Superadmin dashboard and simplifies onboarding of bus operators.
    """
    _require_admin_or_superadmin(request)
    try:
      body = await request.json()
    except Exception:
      body = None
    if not isinstance(body, dict):
      body = {}
    try:
        req = BusOperatorCreateReq(**body)
    except Exception as e:
        raise HTTPException(status_code=400, detail=str(e))
    phone = req.phone.strip()
    company_name = req.company_name.strip()
    if not phone or not company_name:
        raise HTTPException(status_code=400, detail="phone and company_name are required")

    # 1) Ensure payments user/wallet exists for this phone and resolve wallet_id.
    wallet_id: str | None = None
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            with _pay_internal_session() as s:  # type: ignore[name-defined]
                try:
                    # Resolve existing mapping first.
                    res = _pay_resolve_phone(phone=phone, s=s)  # type: ignore[name-defined]
                except Exception:
                    # If resolve fails, create user and try again using the
                    # same internal helper/Req model that the rest of the
                    # BFF uses for Payments.
                    _ = _pay_create_user(_PayCreateUserReq(phone=phone), s=s)  # type: ignore[name-defined]  # noqa: E501
                    res = _pay_resolve_phone(phone=phone, s=s)  # type: ignore[name-defined]
                try:
                    wallet_id = getattr(res, "wallet_id", None)
                except Exception:
                    wallet_id = None
        elif PAYMENTS_BASE:
            # Fallback: HTTP call to standalone Payments API.
            r = httpx.get(
                _payments_url(f"/resolve/phone/{phone}"),
                headers=_payments_headers(),
                timeout=10,
            )
            if r.status_code == 404:
                # Create user then resolve again.
                r_create = httpx.post(
                    _payments_url("/users"),
                    json={"phone": phone},
                    headers=_payments_headers(),
                    timeout=10,
                )
                if r_create.status_code >= 400:
                    raise HTTPException(status_code=r_create.status_code, detail=r_create.text)
                r = httpx.get(
                    _payments_url(f"/resolve/phone/{phone}"),
                    headers=_payments_headers(),
                    timeout=10,
                )
            if r.headers.get("content-type", "").startswith("application/json"):
                j = r.json()
                if isinstance(j, dict):
                    wid = (j.get("wallet_id") or j.get("id") or "").strip()
                    wallet_id = wid or None
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=f"payments resolve failed: {e}")

    if not wallet_id:
        raise HTTPException(status_code=500, detail="could not resolve wallet for phone")

    # 2) Ensure a Bus operator exists for this wallet_id.
    operator_id: str | None = None
    try:
        if _use_bus_internal():
            if not _BUS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="bus internal not available")
            with _bus_internal_session() as s:  # type: ignore[name-defined]
                ops = _bus_list_operators(limit=200, s=s)  # type: ignore[name-defined]
                # Try to find by wallet_id first.
                for op in ops or []:
                    try:
                        wid = str(getattr(op, "wallet_id", "") or "").strip()
                        if wid != wallet_id:
                            continue
                        oid = str(getattr(op, "id", "") or "").strip()
                        if oid:
                            operator_id = oid
                            break
                    except Exception:
                        continue
                # Fallback: match by company_name if no wallet match.
                if operator_id is None:
                    for op in ops or []:
                        try:
                            name = str(getattr(op, "name", "") or "").strip()
                            if name.lower() != company_name.lower():
                                continue
                            oid = str(getattr(op, "id", "") or "").strip()
                            if oid:
                                operator_id = oid
                                break
                        except Exception:
                            continue
                if operator_id is None:
                    # Create a new operator bound to this wallet.
                    op_in = _BusOperatorIn(name=company_name, wallet_id=wallet_id)  # type: ignore[name-defined]  # noqa: E501
                    op = _bus_create_operator(body=op_in, s=s)  # type: ignore[name-defined]
                    try:
                        operator_id = getattr(op, "id", None)
                    except Exception:
                        operator_id = None
        else:
            # External BUS_BASE_URL: use HTTP API.
            client = _httpx_client()
            r = client.get(_bus_url("/operators"), timeout=10)
            if r.headers.get("content-type", "").startswith("application/json"):
                arr = r.json()
                if isinstance(arr, list):
                    for op in arr:
                        try:
                            wid = str((op.get("wallet_id") or "")).strip()
                            if wid != wallet_id:
                                continue
                            oid = str((op.get("id") or "")).strip()
                            if oid:
                                operator_id = oid
                                break
                        except Exception:
                            continue
                    if operator_id is None:
                        for op in arr:
                            try:
                                name = str((op.get("name") or "")).strip()
                                if name.lower() != company_name.lower():
                                    continue
                                oid = str((op.get("id") or "")).strip()
                                if oid:
                                    operator_id = oid
                                    break
                            except Exception:
                                continue
            if operator_id is None:
                r = client.post(
                    _bus_url("/operators"),
                    json={"name": company_name, "wallet_id": wallet_id},
                    timeout=10,
                )
                if r.headers.get("content-type", "").startswith("application/json"):
                    j = r.json()
                    if isinstance(j, dict):
                        operator_id = (j.get("id") or "").strip() or None
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=f"bus operator provisioning failed: {e}")

    if not operator_id:
        raise HTTPException(status_code=500, detail="could not create or resolve bus operator")

    # 3) Grant operator_bus role via Payments.
    try:
        # We reuse the underlying role mechanism from /admin/roles.
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            data = {"phone": phone, "role": "operator_bus"}
            try:
                ru = _PayRoleUpsert(**data)  # type: ignore[name-defined]
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _pay_internal_session() as s:  # type: ignore[name-defined]
                _pay_roles_add(body=ru, s=s, admin_ok=True)  # type: ignore[name-defined]
        elif PAYMENTS_BASE:
            client = _httpx_client()
            r = client.post(
                _payments_url("/admin/roles"),
                json={"phone": phone, "role": "operator_bus"},
                headers=_payments_headers(),
                timeout=10,
            )
            if r.status_code >= 400:
                raise HTTPException(status_code=r.status_code, detail=r.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=f"granting operator_bus role failed: {e}")

    return {
        "phone": phone,
        "company_name": company_name,
        "wallet_id": wallet_id,
        "bus_operator_id": operator_id,
        "role": "operator_bus",
    }

@app.delete("/admin/roles")
async def bff_roles_remove(request: Request):
    _require_superadmin(request)
    try:
        body = await request.json()
    except Exception:
        body = None
    try:
        target_phone = ""
        target_role = ""
        try:
            if isinstance(body, dict):
                target_phone = (body.get("phone") or "").strip()
                target_role = (body.get("role") or "").strip()
        except Exception:
            target_phone = ""
            target_role = ""
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                ru = _PayRoleUpsert(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            try:
                with _pay_internal_session() as s:
                    return _pay_roles_remove(body=ru, s=s, admin_ok=True)
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(status_code=502, detail=str(e))
        r = httpx.delete(
            _payments_url("/admin/roles"),
            json=body,
            headers=_payments_headers(),
            timeout=10,
        )
        resp = r.json()
        _audit_from_request(request, "admin_role_remove", target_phone=target_phone, target_role=target_role)
        return resp
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/dev/ping")
def dev_ping() -> dict[str, str]:
    """
    Lightweight health endpoint to verify that the current BFF build
    (including admin role routes) is deployed correctly.
    """
    return {"status": "ok", "component": "bff", "kind": "dev-ping"}


@app.post("/dev/seed_demo")
async def dev_seed_demo(request: Request):
    """
    Create a small set of demo users and roles for local/dev environments.

    - Only available when ENV is dev or test.
    - Requires a valid Superadmin session.
    - Idempotent: re-running will not duplicate users or roles.
    """
    env = _env_or("ENV", "dev").lower()
    if env not in ("dev", "test"):
        # Do not expose this endpoint outside dev/test.
        raise HTTPException(status_code=404, detail="not found")

    phone = _auth_phone(request)
    if not phone or not _is_superadmin(phone):
        raise HTTPException(status_code=403, detail="superadmin required")

    # Static demo accounts covering the main domains.
    demo_accounts: list[dict[str, Any]] = [
        {
            "phone": "+963000000001",
            "label": "Enduser demo (wallet only)",
            "roles": [],
        },
        {
            "phone": "+963000000002",
            "label": "Taxi operator demo",
            "roles": ["operator_taxi"],
        },
        {
            "phone": "+963000000003",
            "label": "Bus operator demo",
            "roles": ["operator_bus"],
        },
        {
            "phone": "+963000000004",
            "label": "Food operator demo",
            "roles": ["operator_food"],
        },
        {
            "phone": "+963000000005",
            "label": "Hotels & Stays operator demo",
            "roles": ["operator_stays"],
        },
        {
            "phone": "+963000000006",
            "label": "Realestate operator demo",
            "roles": ["operator_realestate"],
        },
        {
            "phone": "+963000000007",
            "label": "Building Materials / Commerce operator demo",
            "roles": ["operator_commerce"],
        },
        {
            "phone": "+963000000008",
            "label": "Courier & Transport operator demo",
            "roles": ["operator_freight"],
        },
        {
            "phone": "+963000000009",
            "label": "Carrental & Carmarket operator demo",
            "roles": ["operator_carrental"],
        },
        {
            "phone": "+963000000010",
            "label": "Admin demo",
            "roles": ["admin"],
        },
    ]

    created: list[dict[str, Any]] = []
    errors: list[dict[str, Any]] = []

    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            # Use internal Payments SQLAlchemy session for fast, idempotent seeding.
            with _pay_internal_session() as s:  # type: ignore[name-defined]
                for acc in demo_accounts:
                    ph = str(acc.get("phone") or "").strip()
                    if not ph:
                        continue
                    # Ensure user + wallet.
                    wallet_id: str | None = None
                    try:
                        data = {"phone": ph}
                        req_model = _PayCreateUserReq(**data)  # type: ignore[name-defined]
                        user = _pay_create_user(req_model, s=s)  # type: ignore[name-defined]
                        try:
                            wallet_id = getattr(user, "wallet_id", None) or getattr(user, "id", None)  # type: ignore[attr-defined]
                        except Exception:
                            wallet_id = None
                    except Exception as e:
                        errors.append({"phone": ph, "stage": "create_user", "error": str(e)})
                    # Ensure roles.
                    roles = [str(r) for r in (acc.get("roles") or [])]
                    for role in roles:
                        try:
                            ru = _PayRoleUpsert(phone=ph, role=role)  # type: ignore[name-defined]
                            _pay_roles_add(body=ru, s=s, admin_ok=True)  # type: ignore[name-defined]
                        except Exception as e:
                            errors.append({"phone": ph, "stage": f"role_add:{role}", "error": str(e)})
                    created.append(
                        {
                            "phone": ph,
                            "label": acc.get("label") or "",
                            "wallet_id": wallet_id,
                            "roles": roles,
                        }
                    )
        else:
            # Fallback: talk to external Payments API over HTTP, if configured.
            if not PAYMENTS_BASE:
                raise HTTPException(status_code=500, detail="PAYMENTS_BASE_URL not configured for seeding")
            for acc in demo_accounts:
                ph = str(acc.get("phone") or "").strip()
                if not ph:
                    continue
                wallet_id: str | None = None
                # Ensure user + wallet.
                try:
                    r = httpx.post(
                        _payments_url("/users"),
                        json={"phone": ph},
                        headers=_payments_headers(),
                        timeout=10,
                    )
                    if r.headers.get("content-type", "").startswith("application/json"):
                        j = r.json()
                        if isinstance(j, dict):
                            wallet_id = (j.get("wallet_id") or j.get("id"))  # type: ignore[assignment]
                except Exception as e:
                    errors.append({"phone": ph, "stage": "create_user_http", "error": str(e)})
                # Ensure roles via /admin/roles.
                roles = [str(r) for r in (acc.get("roles") or [])]
                for role in roles:
                    try:
                        body = {"phone": ph, "role": role}
                        httpx.post(
                            _payments_url("/admin/roles"),
                            json=body,
                            headers=_payments_headers(),
                            timeout=10,
                        )
                    except Exception as e:
                        errors.append({"phone": ph, "stage": f"role_add_http:{role}", "error": str(e)})
                created.append(
                    {
                        "phone": ph,
                        "label": acc.get("label") or "",
                        "wallet_id": wallet_id,
                        "roles": roles,
                    }
                )
    except HTTPException:
        raise
    except Exception as e:
        errors.append({"error": str(e), "stage": "seed_demo_global"})

    # Light audit entry so we can see in logs when demo data was seeded.
    _audit_from_request(request, "dev_seed_demo", env=env, accounts=len(demo_accounts), errors=len(errors))

    return {
        "ok": True,
        "env": env,
        "accounts": created,
        "errors": errors,
    }

@app.get("/admin/topup-sellers", response_class=HTMLResponse)
def bff_roles_admin_page(request: Request):
    _require_admin_v2(request)
    # Legacy HTML-Seite entfernt – bitte Shamell verwenden.
    return _legacy_console_removed_page("Shamell · Topup sellers")
    html = """
<!doctype html>
<html><head><meta name=viewport content='width=device-width, initial-scale=1' />
<title>Topup Sellers</title>
<style>body{font-family:sans-serif;margin:20px;max-width:760px}</style>
</head><body>
<h1>Topup Sellers</h1>
<p>Manage seller roles (phone E.164). Requires server internal secret.</p>
<div>
  <input id=phone placeholder='+963...' />
  <button onclick='add()'>Add Seller</button>
  <button onclick='del()'>Remove Seller</button>
</div>
<p><button onclick='load()'>Reload</button></p>
<pre id=out></pre>
<script>
async function add(){ const p=document.getElementById('phone').value.trim(); const r=await fetch('/admin/roles',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({phone:p,role:'seller'})}); out.textContent=await r.text(); }
async function del(){ const p=document.getElementById('phone').value.trim(); const r=await fetch('/admin/roles',{method:'DELETE',headers:{'content-type':'application/json'},body:JSON.stringify({phone:p,role:'seller'})}); out.textContent=await r.text(); }
async function load(){ const r=await fetch('/admin/roles?role=seller&limit=500'); out.textContent=await r.text(); }
load();
</script>
</body></html>
"""
    return HTMLResponse(content=html)


@app.get("/me/roles")
def me_roles(request: Request):
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    roles = _get_effective_roles(phone)
    return {"phone": phone, "roles": roles}


@app.post("/auth/devices/register", response_class=JSONResponse)
async def auth_devices_register(request: Request) -> dict[str, Any]:
    """
    Registriert oder aktualisiert einen Geräte-Eintrag für den aktuellen Benutzer.

    Wird vom Client nach erfolgreichem Login aufgerufen und bildet die
    Basis für eine Geräte-Liste im Me-Tab (Multi-Device à la WeChat).
    """
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    try:
        body = await request.json()
    except Exception:
        body = {}
    if not isinstance(body, dict):
        body = {}
    device_id = (body.get("device_id") or "").strip()
    if not device_id:
        raise HTTPException(status_code=400, detail="device_id required")
    device_type = (body.get("device_type") or "").strip() or None
    device_name = (body.get("device_name") or "").strip() or None
    platform = (body.get("platform") or "").strip() or None
    app_version = (body.get("app_version") or "").strip() or None
    ip = _auth_client_ip(request)
    ua = request.headers.get("user-agent") or request.headers.get("User-Agent")
    with _officials_session() as s:
        row = (
            s.execute(
                _sa_select(DeviceSessionDB).where(
                    DeviceSessionDB.phone == phone,
                    DeviceSessionDB.device_id == device_id,
                )
            )
            .scalars()
            .first()
        )
        now = datetime.now(timezone.utc)
        if row:
            row.device_type = device_type or row.device_type
            row.device_name = device_name or row.device_name
            row.platform = platform or row.platform
            row.app_version = app_version or row.app_version
            row.last_ip = ip or row.last_ip
            row.user_agent = ua or row.user_agent
            row.last_seen_at = now
            s.add(row)
            s.commit()
            s.refresh(row)
        else:
            row = DeviceSessionDB(
                phone=phone,
                device_id=device_id,
                device_type=device_type,
                device_name=device_name,
                platform=platform,
                app_version=app_version,
                last_ip=ip,
                user_agent=ua,
                last_seen_at=now,
            )
            s.add(row)
            s.commit()
            s.refresh(row)
        return {
            "id": row.id,
            "phone": row.phone,
            "device_id": row.device_id,
            "device_type": row.device_type,
            "device_name": row.device_name,
            "platform": row.platform,
            "app_version": row.app_version,
            "last_ip": row.last_ip,
            "user_agent": row.user_agent,
            "created_at": getattr(row, "created_at", None),
            "last_seen_at": getattr(row, "last_seen_at", None),
        }


@app.post("/auth/device_login/start", response_class=JSONResponse)
async def auth_device_login_start(request: Request) -> dict[str, Any]:
    """
    Startet einen QR‑Login‑Flow für ein neues Gerät (z.B. Web/Desktop).

    Unauthenticated endpoint: erstellt ein kurzlebiges Token, das als QR‑Code
    dargestellt werden kann (z.B. shamell://device_login?token=...).
    Das eigentliche Binden an einen Account passiert erst, wenn der Nutzer
    den Login auf dem Telefon bestätigt.
    """
    try:
      body = await request.json()
    except Exception:
      body = {}
    if not isinstance(body, dict):
        body = {}
    label = (body.get("label") or "").strip()
    token = _uuid.uuid4().hex
    now = _now()
    _DEVICE_LOGIN_CHALLENGES[token] = {
        "created_at": now,
        "status": "pending",
        "label": label,
        "phone": None,
        "session": None,
    }
    return {"ok": True, "token": token, "label": label}


@app.post("/auth/device_login/approve", response_class=JSONResponse)
async def auth_device_login_approve(request: Request) -> dict[str, Any]:
    """
    Wird vom authentifizierten Telefon aufgerufen, nachdem ein QR‑Code
    für den Geräte‑Login gescannt wurde. Markiert das Token als genehmigt
    und erzeugt eine Session, die später vom neuen Gerät eingelöst wird.
    """
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    try:
        body = await request.json()
    except Exception:
        raise HTTPException(status_code=400, detail="invalid body")
    if not isinstance(body, dict):
        raise HTTPException(status_code=400, detail="invalid body")
    token = (body.get("token") or "").strip()
    if not token:
        raise HTTPException(status_code=400, detail="token required")
    _cleanup_auth_state()
    rec = _DEVICE_LOGIN_CHALLENGES.get(token)
    if not rec:
        raise HTTPException(status_code=404, detail="challenge not found")
    try:
        created = int(rec.get("created_at") or 0)
    except Exception:
        created = 0
    if created <= 0 or created + DEVICE_LOGIN_TTL_SECS < _now():
        try:
            _DEVICE_LOGIN_CHALLENGES.pop(token, None)
        except Exception:
            pass
        raise HTTPException(status_code=400, detail="challenge expired")
    # Create a fresh session for the new device and mark as approved.
    sid = _create_session(phone)
    rec["status"] = "approved"
    rec["phone"] = phone
    rec["session"] = sid
    rec["approved_at"] = _now()
    _DEVICE_LOGIN_CHALLENGES[token] = rec
    return {"ok": True, "token": token}


@app.post("/auth/device_login/redeem", response_class=JSONResponse)
async def auth_device_login_redeem(request: Request):
    """
    Wird vom neuen Gerät (z.B. Web/Desktop) aufgerufen, nachdem der Nutzer
    den QR‑Login auf dem Telefon bestätigt hat. Liefert eine Session‑ID und
    setzt optional das sa_session‑Cookie.
    """
    try:
        body = await request.json()
    except Exception:
        raise HTTPException(status_code=400, detail="invalid body")
    if not isinstance(body, dict):
        raise HTTPException(status_code=400, detail="invalid body")
    token = (body.get("token") or "").strip()
    if not token:
        raise HTTPException(status_code=400, detail="token required")
    _cleanup_auth_state()
    rec = _DEVICE_LOGIN_CHALLENGES.get(token)
    if not rec:
        raise HTTPException(status_code=404, detail="challenge not found")
    try:
        created = int(rec.get("created_at") or 0)
    except Exception:
        created = 0
    if created <= 0 or created + DEVICE_LOGIN_TTL_SECS < _now():
        try:
            _DEVICE_LOGIN_CHALLENGES.pop(token, None)
        except Exception:
            pass
        raise HTTPException(status_code=400, detail="challenge expired")
    status = (rec.get("status") or "").strip().lower()
    if status != "approved":
        raise HTTPException(status_code=400, detail="challenge not approved")
    phone = (rec.get("phone") or "").strip()
    if not phone:
        raise HTTPException(status_code=400, detail="challenge not bound to user")
    sid = rec.get("session")
    if not isinstance(sid, str) or not sid:
        sid = _create_session(phone)
    try:
        _DEVICE_LOGIN_CHALLENGES.pop(token, None)
    except Exception:
        pass
    resp = JSONResponse({"ok": True, "phone": phone, "session": sid})
    resp.set_cookie(
        "sa_session",
        sid,
        max_age=AUTH_SESSION_TTL_SECS,
        httponly=True,
        secure=True,
        samesite="lax",
        path="/",
    )
    return resp

@app.get("/auth/devices", response_class=JSONResponse)
def auth_devices_list(request: Request) -> dict[str, Any]:
    """
    Listet registrierte Geräte des aktuellen Benutzers auf.
    """
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    with _officials_session() as s:
        rows = (
            s.execute(
                _sa_select(DeviceSessionDB)
                .where(DeviceSessionDB.phone == phone)
                .order_by(DeviceSessionDB.last_seen_at.desc(), DeviceSessionDB.id.desc())
            )
            .scalars()
            .all()
        )
        items: list[dict[str, Any]] = []
        for row in rows:
            items.append(
                {
                    "id": row.id,
                    "phone": row.phone,
                    "device_id": row.device_id,
                    "device_type": row.device_type,
                    "device_name": row.device_name,
                    "platform": row.platform,
                    "app_version": row.app_version,
                    "last_ip": row.last_ip,
                    "user_agent": row.user_agent,
                    "created_at": getattr(row, "created_at", None),
                    "last_seen_at": getattr(row, "last_seen_at", None),
                }
            )
    return {"devices": items}


@app.delete("/auth/devices/{device_id}", response_class=JSONResponse)
def auth_devices_delete(device_id: str, request: Request) -> dict[str, Any]:
    """
    Entfernt einen Geräte-Eintrag für den aktuellen Benutzer.

    Dies ist ein reines Verwaltungsfeature; bestehende Sessions werden
    dadurch nicht hart invalidiert, da OTP-Sessions in-memory laufen.
    """
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    clean = (device_id or "").strip()
    if not clean:
        raise HTTPException(status_code=400, detail="device_id required")
    with _officials_session() as s:
        row = (
            s.execute(
                _sa_select(DeviceSessionDB).where(
                    DeviceSessionDB.phone == phone,
                    DeviceSessionDB.device_id == clean,
                )
            )
            .scalars()
            .first()
        )
        if not row:
            return {"status": "ignored"}
        s.delete(row)
        s.commit()
    return {"status": "ok"}


@app.post("/me/dsr/export")
async def me_dsr_export(request: Request):
    """
    Lightweight endpoint for Data Subject export requests.
    It does not perform the export itself, but records the intent via audit log.
    """
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    try:
        body = await request.json()
    except Exception:
        body = {}
    reason = ""
    contact = ""
    if isinstance(body, dict):
        try:
            reason = str(body.get("reason") or "")
            contact = str(body.get("contact") or "")
        except Exception:
            reason = ""
            contact = ""
    _audit("dsr_export_request", phone=phone, reason=reason, contact=contact)
    return {"status": "accepted", "kind": "export"}


@app.post("/me/dsr/delete")
async def me_dsr_delete(request: Request):
    """
    Lightweight endpoint for Data Subject deletion requests.
    It records the request via audit log so that backoffice tools can act on it.
    """
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    try:
        body = await request.json()
    except Exception:
        body = {}
    reason = ""
    contact = ""
    if isinstance(body, dict):
        try:
            reason = str(body.get("reason") or "")
            contact = str(body.get("contact") or "")
        except Exception:
            reason = ""
            contact = ""
    _audit("dsr_delete_request", phone=phone, reason=reason, contact=contact)
    return {"status": "accepted", "kind": "delete"}


@app.get("/topup/print_pdf/{batch_id}")
def topup_print_pdf(batch_id: str):
    if _pdfcanvas is None or _qr is None:
        raise HTTPException(status_code=500, detail="PDF/QR library not available")
    # Fetch vouchers
    try:
        r = httpx.get(
            _payments_url(f"/topup/batches/{batch_id}"),
            headers=_payments_headers(),
            timeout=15,
        )
        arr = r.json() if r.headers.get('content-type','').startswith('application/json') else []
    except Exception as e:
        raise HTTPException(status_code=502, detail=f"fetch batch failed: {e}")
    # Prepare PDF
    buf = BytesIO()
    c = _pdfcanvas.Canvas(buf, pagesize=A4)
    width, height = A4
    cols, rows = 3, 4
    cell_w = width / cols
    cell_h = height / rows
    x_margin = 12
    y_margin = 18
    i = 0
    for v in arr:
        payload = v.get('payload','')
        code = v.get('code','')
        amt = int(v.get('amount_cents',0))
        # Make QR image
        try:
            q = _qr.QRCode(error_correction=_qr.constants.ERROR_CORRECT_M, box_size=6, border=2)
            q.add_data(payload)
            q.make(fit=True)
            img = q.make_image(fill_color="black", back_color="white")
            pil = img.convert('RGB') if hasattr(img, 'convert') else img
            img_reader = _RLImageReader(pil)
        except Exception:
            img_reader = None
        col = i % cols
        row = (i // cols) % rows
        if i > 0 and row == 0 and col == 0:
            c.showPage()
        # Compute coords (origin bottom-left)
        x = col * cell_w + x_margin
        y = height - ((row + 1) * cell_h) + y_margin
        # Draw QR centered in cell
        if img_reader:
            qr_size = min(cell_w - 2*x_margin, cell_h - 2*y_margin - 20)
            c.drawImage(img_reader, x + (cell_w - qr_size)/2, y + (cell_h - qr_size)/2, width=qr_size, height=qr_size, preserveAspectRatio=True, mask='auto')
        # Labels
        c.setFont("Helvetica", 9)
        c.drawCentredString(x + cell_w/2, y + 6, f"{code} • {amt} SYP")
        i += 1
    c.showPage()
    c.save()
    buf.seek(0)
    return StreamingResponse(buf, media_type='application/pdf')

@app.post("/payments/users")
async def payments_create_user(req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    if _use_pay_internal():
        if not _PAY_INTERNAL_AVAILABLE:
            raise HTTPException(status_code=500, detail="payments internal not available")
        data = body or {}
        if not isinstance(data, dict):
            data = {}
        try:
            req_model = _PayCreateUserReq(**data)
        except Exception as e:
            raise HTTPException(status_code=400, detail=str(e))
        try:
            with _pay_internal_session() as s:
                return _pay_create_user(req_model, s=s)
        except HTTPException:
            raise
        except Exception as e:
            raise HTTPException(status_code=502, detail=str(e))
    try:
        # Fallback: HTTP call to standalone Payments API if configured.
        r = httpx.post(
            _payments_url("/users"),
            json=body,
            headers=_payments_headers(),
            timeout=10,
        )
        return r.json()
    except HTTPException:
        # Already a structured HTTP error from upstream helper.
        raise
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/payments/wallets/{wallet_id}")
def payments_wallet(wallet_id: str, request: Request):
    phone, caller_wallet_id = _require_caller_wallet(request)
    if wallet_id != caller_wallet_id and not _is_admin(phone):
        raise HTTPException(status_code=403, detail="wallet does not belong to caller")
    if _use_pay_internal():
        if not _PAY_INTERNAL_AVAILABLE:
            raise HTTPException(status_code=500, detail="payments internal not available")
        try:
            with _pay_internal_session() as s:
                return _pay_get_wallet(wallet_id=wallet_id, s=s)
        except HTTPException:
            raise
        except Exception as e:
            raise HTTPException(status_code=502, detail=str(e))
    try:
        r = httpx.get(
            _payments_url(f"/wallets/{wallet_id}"),
            headers=_payments_headers(),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/payments/transfer")
async def payments_transfer(req: Request):
    # parse body (tolerate empty)
    try:
        body = await req.json()
    except Exception:
        body = None
    if not isinstance(body, dict):
        body = {}
    _phone, caller_wallet_id = _require_caller_wallet(req)
    from_wallet_id = str(body.get("from_wallet_id") or "").strip()
    if from_wallet_id and from_wallet_id != caller_wallet_id:
        _audit_from_request(
            req,
            "payments_transfer_wallet_mismatch",
            requested_wallet_id=from_wallet_id,
            caller_wallet_id=caller_wallet_id,
        )
        raise HTTPException(status_code=403, detail="from_wallet_id does not belong to caller")
    # Prevent wallet spoofing by forcing sender to caller-owned wallet.
    body["from_wallet_id"] = caller_wallet_id
    # forward idempotency and risk headers
    headers = {}
    try:
        ikey = req.headers.get("Idempotency-Key") if hasattr(req, 'headers') else None
        dev = req.headers.get("X-Device-ID") if hasattr(req, 'headers') else None
        ua = req.headers.get("User-Agent") if hasattr(req, 'headers') else None
    except Exception:
        ikey = None; dev = None; ua = None
    if ikey:
        headers["Idempotency-Key"] = ikey
    if dev:
        headers["X-Device-ID"] = dev
    if ua:
        headers["User-Agent"] = ua
    try:
        body = _normalize_amount(body)
        # Check guardrails before executing the payment (best-effort).
        if isinstance(body, dict):
            from_wallet_id = (body.get("from_wallet_id") or "") if body.get("from_wallet_id") is not None else ""
            amount_cents = body.get("amount_cents")
            _check_payment_guardrails(from_wallet_id, amount_cents, dev)

        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                req_model = _PayTransferReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            try:
                with _pay_internal_session() as s:
                    # Idempotency key is read from headers in the Payments API;
                    # simulating it via a request-like object is not needed here,
                    # because idempotency logic in the body (ikey) is not used.
                    result = _pay_transfer(req_model, request=req, s=s)
                try:
                    payload = {}
                    if isinstance(body, dict):
                        payload = {
                            "from_wallet_id": body.get("from_wallet_id"),
                            "to_wallet_id": body.get("to_wallet_id"),
                            "to_alias": body.get("to_alias"),
                            "amount_cents": body.get("amount_cents"),
                            "currency": body.get("currency"),
                            "device_id": dev,
                        }
                    emit_event("payments", "transfer", payload)
                except Exception:
                    pass
                return result
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(status_code=502, detail=str(e))
        r = httpx.post(
            _payments_url("/transfer"),
            json=body,
            headers=_payments_headers(headers),
            timeout=10,
        )
        out = r.json()
        try:
            payload = {}
            if isinstance(body, dict):
                payload = {
                    "from_wallet_id": body.get("from_wallet_id"),
                    "to_wallet_id": body.get("to_wallet_id"),
                    "to_alias": body.get("to_alias"),
                    "amount_cents": body.get("amount_cents"),
                    "currency": body.get("currency"),
                    "device_id": dev,
                }
            emit_event("payments", "transfer", payload)
        except Exception:
            pass
        return out
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        # Guardrail or validation errors should be passed through directly
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/payments/wallets/{wallet_id}/topup")
async def payments_topup(wallet_id: str, req: Request):
    _require_admin_v2(req)
    dev_allow = _env_or("BFF_DEV_ALLOW_TOPUP", "false").lower() == "true"
    if not PAYMENTS_INTERNAL_SECRET and not dev_allow:
        raise HTTPException(status_code=403, detail="Server not configured for admin topup")
    try:
        body = await req.json()
    except Exception:
        body = None
    # Normalize amount payload once so both internal + HTTP paths share logic
    body = _normalize_amount(body)
    try:
        # Prefer internal Payments integration in monolith mode to avoid
        # HTTP loops back into the same process.
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                req_model = _PayTopupReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            try:
                with _pay_internal_session() as s:
                    # Bypass require_admin dependency by passing admin_ok=True;
                    # BFF already enforced admin/secret above.
                    return _pay_wallet_topup(wallet_id=wallet_id, req=req_model, request=req, s=s, admin_ok=True)
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(status_code=502, detail=str(e))

        headers: dict[str, str] = {}
        if PAYMENTS_INTERNAL_SECRET:
            headers["X-Internal-Secret"] = PAYMENTS_INTERNAL_SECRET
        try:
            ikey = req.headers.get("Idempotency-Key") if hasattr(req, "headers") else None
        except Exception:
            ikey = None
        if ikey:
            headers["Idempotency-Key"] = ikey
        r = httpx.post(
            _payments_url(f"/wallets/{wallet_id}/topup"),
            json=body,
            headers=_payments_headers(headers),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


# ---- Cash Mandate proxies ----
@app.post("/payments/cash/create")
async def payments_cash_create(req: Request):
    _require_admin_v2(req)
    if not PAYMENTS_INTERNAL_SECRET:
        raise HTTPException(status_code=403, detail="Server not configured for cash create")
    try:
        body = await req.json()
    except Exception:
        body = None
    headers = {"X-Internal-Secret": PAYMENTS_INTERNAL_SECRET}
    try:
        ikey = req.headers.get("Idempotency-Key") if hasattr(req, 'headers') else None
    except Exception:
        ikey = None
    if ikey:
        headers["Idempotency-Key"] = ikey
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                req_model = _PayCashCreateReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            try:
                # admin_ok=True because the BFF already protects via PAYMENTS_INTERNAL_SECRET
                with _pay_internal_session() as s:
                    return _pay_cash_create(req_model, request=req, s=s, admin_ok=True)
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(status_code=502, detail=str(e))
        r = httpx.post(
            _payments_url("/cash/create"),
            json=body,
            headers=_payments_headers(headers),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


# ---- Favorites & Requests proxies ----
@app.post("/payments/favorites")
async def payments_fav_create(req: Request):
    phone, caller_wallet_id = _require_caller_wallet(req)
    can_admin = _is_admin(phone)
    _rate_limit_payments_edge(
        req,
        wallet_id=caller_wallet_id,
        scope="favorites_write",
        wallet_max=PAY_API_FAV_WRITE_MAX_PER_WALLET,
        ip_max=PAY_API_FAV_WRITE_MAX_PER_IP,
    )
    try:
        body = await req.json()
    except Exception:
        body = {}
    if not isinstance(body, dict):
        body = {}
    payload = dict(body)
    owner_wallet_id = str(payload.get("owner_wallet_id") or "").strip()
    if owner_wallet_id and owner_wallet_id != caller_wallet_id and not can_admin:
        _audit_from_request(
            req,
            "favorites_owner_wallet_mismatch",
            requested_wallet_id=owner_wallet_id,
            caller_wallet_id=caller_wallet_id,
        )
        raise HTTPException(status_code=403, detail="owner_wallet_id does not belong to caller")
    payload["owner_wallet_id"] = caller_wallet_id if not can_admin else (owner_wallet_id or caller_wallet_id)
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            data = payload or {}
            if not isinstance(data, dict):
                data = {}
            try:
                req_model = _PayFavoriteCreate(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            try:
                with _pay_internal_session() as s:
                    return _pay_create_favorite(req_model, s=s)
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(status_code=502, detail=str(e))
        r = httpx.post(
            _payments_url("/favorites"),
            json=payload,
            headers=_payments_headers(),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/payments/favorites")
def payments_fav_list(request: Request, owner_wallet_id: str = ""):
    phone, caller_wallet_id = _require_caller_wallet(request)
    can_admin = _is_admin(phone)
    _rate_limit_payments_edge(
        request,
        wallet_id=caller_wallet_id,
        scope="favorites_read",
        wallet_max=PAY_API_FAV_READ_MAX_PER_WALLET,
        ip_max=PAY_API_FAV_READ_MAX_PER_IP,
    )
    requested_wallet_id = (owner_wallet_id or "").strip()
    if requested_wallet_id and requested_wallet_id != caller_wallet_id and not can_admin:
        raise HTTPException(status_code=403, detail="owner_wallet_id does not belong to caller")
    target_wallet_id = requested_wallet_id if requested_wallet_id else caller_wallet_id
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            try:
                with _pay_internal_session() as s:
                    return _pay_list_favorites(owner_wallet_id=target_wallet_id, s=s)
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(status_code=502, detail=str(e))
        r = httpx.get(
            _payments_url("/favorites"),
            params={"owner_wallet_id": target_wallet_id},
            headers=_payments_headers(),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.delete("/payments/favorites/{fid}")
def payments_fav_delete(fid: str, request: Request):
    phone, caller_wallet_id = _require_caller_wallet(request)
    can_admin = _is_admin(phone)
    _rate_limit_payments_edge(
        request,
        wallet_id=caller_wallet_id,
        scope="favorites_write",
        wallet_max=PAY_API_FAV_WRITE_MAX_PER_WALLET,
        ip_max=PAY_API_FAV_WRITE_MAX_PER_IP,
    )
    fav_id = (fid or "").strip()
    if not fav_id:
        raise HTTPException(status_code=400, detail="favorite id required")
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            try:
                with _pay_internal_session() as s:
                    if not can_admin:
                        rows = _pay_list_favorites(owner_wallet_id=caller_wallet_id, s=s)
                        allowed = False
                        for row in rows or []:
                            try:
                                row_id = str(getattr(row, "id", "") or "")
                            except Exception:
                                row_id = ""
                            if row_id == fav_id:
                                allowed = True
                                break
                        if not allowed:
                            raise HTTPException(status_code=404, detail="favorite not found")
                    return _pay_delete_favorite(fid=fav_id, s=s)
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(status_code=502, detail=str(e))
        if not can_admin:
            chk = httpx.get(
                _payments_url("/favorites"),
                params={"owner_wallet_id": caller_wallet_id},
                headers=_payments_headers(),
                timeout=10,
            )
            rows = chk.json() if chk.headers.get("content-type", "").startswith("application/json") else []
            allowed = False
            if isinstance(rows, list):
                for row in rows:
                    try:
                        row_id = str((row or {}).get("id") or "").strip()
                    except Exception:
                        row_id = ""
                    if row_id == fav_id:
                        allowed = True
                        break
            if not allowed:
                raise HTTPException(status_code=404, detail="favorite not found")
        r = httpx.delete(
            _payments_url(f"/favorites/{fav_id}"),
            headers=_payments_headers(),
            timeout=10,
        )
        return r.json() if r.headers.get("content-type", "").startswith("application/json") else {"raw": r.text}
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


# ---- Bus proxies (search, book, status, cities) ----
@app.get("/bus/cities")
def bus_cities(q: str = "", limit: int = 50):
    if _use_bus_internal():
        if not _BUS_INTERNAL_AVAILABLE:
            raise HTTPException(status_code=500, detail="bus internal not available")
        try:
            with _bus_internal_session() as s:
                return _bus_list_cities(q=q, limit=limit, s=s)
        except HTTPException:
            raise
        except Exception as e:
            raise HTTPException(status_code=502, detail=str(e))
    try:
        r = httpx.get(_bus_url("/cities"), params={"q": q, "limit": limit}, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/bus/cities_cached")
def bus_cities_cached(limit: int = 50, response: Response = None):  # type: ignore[assignment]
    """
    Simplified cache for /bus/cities without search parameters.
    For q/filter please continue to use /bus/cities directly.
    """
    global _BUS_CITIES_CACHE
    # Do not enforce cache semantics for unusual limits
    if limit <= 0:
        limit = 50
    # Use cache only for standard case without filters
    if _BUS_CITIES_CACHE.get("data") is not None:
        try:
            ts = float(_BUS_CITIES_CACHE.get("ts") or 0.0)
        except Exception:
            ts = 0.0
        if time.time() - ts < 30.0:
            data = _BUS_CITIES_CACHE.get("data")
            try:
                if response is not None:
                    response.headers.setdefault("Cache-Control", "public, max-age=30")
            except Exception:
                pass
            return data
    data = bus_cities(q="", limit=limit)
    # Hide legacy test cities like "Origin City" / "Dest City" from
    # the cached list so that From/To dropdowns in the UI only show
    # real cities (e.g. Damascus, Aleppo, ...).
    try:
        if isinstance(data, list):
            def _name_for(x: Any) -> str:
                try:
                    if isinstance(x, dict):
                        return str(x.get("name", "") or "")
                    return str(getattr(x, "name", "") or "")
                except Exception:
                    return ""

            bad_prefixes = ("Origin City", "Dest City")
            data = [
                x for x in data
                if not _name_for(x).startswith(bad_prefixes)
            ]
    except Exception:
        # Never break the endpoint because of filtering issues.
        pass
    _BUS_CITIES_CACHE = {"ts": time.time(), "data": data}
    try:
        if response is not None:
            response.headers.setdefault("Cache-Control", "public, max-age=30")
    except Exception:
        pass
    return data


@app.get("/bus/trips/search")
def bus_trips_search(origin_city_id: str, dest_city_id: str, date: str):
    try:
        if _use_bus_internal():
            if not _BUS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="bus internal not available")
            with _bus_internal_session() as s:
                return _bus_search_trips(origin_city_id=origin_city_id, dest_city_id=dest_city_id, date=date, s=s)
        params = {"origin_city_id": origin_city_id, "dest_city_id": dest_city_id, "date": date}
        r = httpx.get(_bus_url("/trips/search"), params=params, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/bus/trips/{trip_id}")
def bus_trip_detail(trip_id: str):
    if _use_bus_internal():
        if not _BUS_INTERNAL_AVAILABLE:
            raise HTTPException(status_code=500, detail="bus internal not available")
        try:
            with _bus_internal_session() as s:
                return _bus_trip_detail(trip_id=trip_id, s=s)
        except HTTPException:
            raise
        except Exception as e:
            raise HTTPException(status_code=502, detail=str(e))
    try:
        r = httpx.get(_bus_url(f"/trips/{trip_id}"), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/bus/trips/{trip_id}/book")
async def bus_book(trip_id: str, req: Request):
    phone = _auth_phone(req)
    env_test = _ENV_LOWER == "test"
    if not phone and not env_test:
        raise HTTPException(status_code=401, detail="unauthorized")
    try:
        body = await req.json()
    except Exception:
        body = None
    if not isinstance(body, dict):
        body = {}
    wallet_from_body = (body.get("wallet_id") or "").strip()
    if phone:
        user_wallet = _resolve_wallet_id_for_phone(phone)
        if not user_wallet:
            raise HTTPException(status_code=400, detail="wallet not found for user")
        if wallet_from_body and wallet_from_body != user_wallet:
            raise HTTPException(status_code=403, detail="wallet does not belong to user")
        body["wallet_id"] = user_wallet
        if not (body.get("customer_phone") or "").strip():
            body["customer_phone"] = phone
    headers = {}
    try:
        ikey = req.headers.get("Idempotency-Key") if hasattr(req, 'headers') else None
    except Exception:
        ikey = None
    if ikey:
        headers["Idempotency-Key"] = ikey
    try:
        if _use_bus_internal():
            if not _BUS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="bus internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                req_model = _BusBookReq(**data)  # type: ignore[name-defined]
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            try:
                with _bus_internal_session() as s:
                    return _bus_book_trip(trip_id=trip_id, body=req_model, idempotency_key=ikey, s=s)
            except HTTPException:
                # Preserve domain HTTP errors (e.g. payment/validation issues)
                raise
            except Exception as e:
                raise HTTPException(status_code=502, detail=str(e))
        r = httpx.post(_bus_url(f"/trips/{trip_id}/book"), json=body, headers=headers, timeout=15)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        # Let FastAPI propagate existing HTTPException (status + detail)
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/bus/bookings/{booking_id}")
def bus_booking_status(booking_id: str):
    try:
        if _use_bus_internal():
            if not _BUS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="bus internal not available")
            with _bus_internal_session() as s:
                return _bus_booking_status(booking_id=booking_id, s=s)
        r = httpx.get(_bus_url(f"/bookings/{booking_id}"), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/bus/bookings/{booking_id}/tickets")
def bus_booking_tickets(booking_id: str):
    try:
        if _use_bus_internal():
            if not _BUS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="bus internal not available")
            with _bus_internal_session() as s:
                return _bus_booking_tickets(booking_id=booking_id, s=s)
        r = httpx.get(_bus_url(f"/bookings/{booking_id}/tickets"), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/bus/bookings/{booking_id}/cancel")
async def bus_booking_cancel(booking_id: str, req: Request):
    """
    Cancel a bus booking for the authenticated rider and apply the
    time-based voucher/refund policy from the Bus domain.
    """
    phone = _auth_phone(req)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    # Resolve wallet for caller (used only for ownership check)
    wallet_id = _resolve_wallet_id_for_phone(phone)
    if not wallet_id:
        raise HTTPException(status_code=400, detail="wallet not found for user")
    try:
        # Verify that the booking belongs to this wallet/phone before cancelling.
        if _use_bus_internal():
            if not _BUS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="bus internal not available")
            with _bus_internal_session() as s:
                b = _bus_booking_status(booking_id=booking_id, s=s)
                if getattr(b, "wallet_id", None) and b.wallet_id != wallet_id:  # type: ignore[union-attr]
                    raise HTTPException(status_code=403, detail="booking does not belong to caller wallet")
                # Perform cancellation
                return _bus_cancel_booking(booking_id=booking_id, s=s)
        # External bus-api mode: fetch booking via HTTP to check wallet ownership.
        r_status = httpx.get(_bus_url(f"/bookings/{booking_id}"), timeout=10)
        r_status.raise_for_status()
        booking = r_status.json()
        if isinstance(booking, dict):
            wid = (booking.get("wallet_id") or "").strip()
            if wid and wid != wallet_id:
                raise HTTPException(status_code=403, detail="booking does not belong to caller wallet")
        r = httpx.post(_bus_url(f"/bookings/{booking_id}/cancel"), timeout=15)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/bus/bookings/search")
def bus_booking_search(wallet_id: str | None = None, phone: str | None = None, limit: int = 20):
    params: dict[str, str | int] = {"limit": limit}
    if wallet_id:
        params["wallet_id"] = wallet_id
    if phone:
        params["phone"] = phone
    try:
        if _use_bus_internal():
            if not _BUS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="bus internal not available")
            with _bus_internal_session() as s:
                return _bus_booking_search(wallet_id=wallet_id, phone=phone, limit=limit, s=s)
        r = httpx.get(_bus_url("/bookings/search"), params=params, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/bus/tickets/board")
async def bus_ticket_board(req: Request):
    phone = _require_operator(req, "bus")
    is_admin = _is_admin(phone)
    try:
        body = await req.json()
    except Exception:
        body = None
    if not isinstance(body, dict):
        body = {}
    payload = str((body.get("payload") or "")).strip()
    if not payload:
        raise HTTPException(status_code=400, detail="payload required")

    def _parse_ticket_payload(raw: str) -> dict[str, str]:
        parts = raw.split("|")
        if not parts or parts[0] != "TICKET":
            raise ValueError("invalid payload")
        out: dict[str, str] = {}
        for kv in parts[1:]:
            if "=" not in kv:
                continue
            k, v = kv.split("=", 1)
            out[k] = v
        return out

    try:
        payload_data = _parse_ticket_payload(payload)
    except Exception:
        raise HTTPException(status_code=400, detail="invalid payload")
    trip_id = (payload_data.get("trip") or "").strip()
    ticket_id = (payload_data.get("id") or "").strip()
    booking_id = (payload_data.get("b") or "").strip()
    if not trip_id:
        raise HTTPException(status_code=400, detail="trip missing in payload")
    if not is_admin:
        route_id = _bus_trip_route_id(trip_id)
        if route_id is None:
            raise HTTPException(status_code=404, detail="trip not found")
        owner = _bus_route_owner(route_id)
        if owner and owner not in _bus_operator_ids_for_phone(phone):
            raise HTTPException(status_code=403, detail="trip not allowed for caller")
    try:
        if _use_bus_internal():
            if not _BUS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="bus internal not available")
            try:
                breq = _BusBoardReq(**body)  # type: ignore[name-defined]
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _bus_internal_session() as s:
                res = _bus_ticket_board(body=breq, s=s)
                if not isinstance(res, dict):
                    res = {"result": res}
                booking = None
                tickets = None
                trip = None
                try:
                    if booking_id:
                        booking = _bus_booking_status(booking_id=booking_id, s=s)
                        tickets = _bus_booking_tickets(booking_id=booking_id, s=s)
                    if trip_id:
                        trip = _bus_trip_detail(trip_id=trip_id, s=s)
                except Exception:
                    booking = None
                    tickets = None
                    trip = None
                ticket_obj = None
                if tickets is not None:
                    try:
                        for tk in tickets:
                            try:
                                tid = getattr(tk, "id", None)
                            except Exception:
                                tid = None
                            if not tid and isinstance(tk, dict):
                                tid = (tk.get("id") or "").strip()
                            if str(tid or "") == ticket_id:
                                ticket_obj = tk
                                break
                    except Exception:
                        ticket_obj = None
                res["booking"] = booking
                res["ticket"] = ticket_obj
                res["trip"] = trip
                return res
        r = httpx.post(_bus_url("/tickets/board"), json=body, timeout=10)
        data: Any
        if r.headers.get("content-type", "").startswith("application/json"):
            data = r.json()
            if not isinstance(data, dict):
                data = {"result": data}
        else:
            data = {"raw": r.text, "status_code": r.status_code}
        # Best-effort enrichment with booking/trip info for operator UI.
        booking = None
        tickets = None
        trip = None
        try:
            if booking_id:
                rb = httpx.get(_bus_url(f"/bookings/{booking_id}"), timeout=10)
                if rb.headers.get("content-type", "").startswith("application/json"):
                    booking = rb.json()
                rtks = httpx.get(_bus_url(f"/bookings/{booking_id}/tickets"), timeout=10)
                if rtks.headers.get("content-type", "").startswith("application/json"):
                    tickets = rtks.json()
            if trip_id:
                rt = httpx.get(_bus_url(f"/trips/{trip_id}"), timeout=10)
                if rt.headers.get("content-type", "").startswith("application/json"):
                    trip = rt.json()
        except Exception:
            booking = None
            tickets = None
            trip = None
        ticket_obj = None
        if isinstance(tickets, list):
            try:
                for tk in tickets:
                    if not isinstance(tk, dict):
                        continue
                    tid = (tk.get("id") or "").strip()
                    if tid == ticket_id:
                        ticket_obj = tk
                        break
            except Exception:
                ticket_obj = None
        if isinstance(data, dict):
            data["booking"] = booking
            data["ticket"] = ticket_obj
            data["trip"] = trip
        return data
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/bus/cities")
async def bus_create_city(req: Request):
    if _ENV_LOWER in ("dev", "test"):
        phone = _auth_phone(req)
        if not phone:
            raise HTTPException(status_code=401, detail="unauthorized")
    else:
        _require_operator(req, "bus")
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_bus_internal():
            if not _BUS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="bus internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                req_model = _BusCityIn(**data)  # type: ignore[name-defined]
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _bus_internal_session() as s:
                return _bus_create_city(body=req_model, s=s)
        r = httpx.post(_bus_url("/cities"), json=body, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/bus/operators")
async def bus_create_operator(req: Request):
    phone = _auth_phone(req)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    is_admin = _is_admin(phone)
    if not _is_operator(phone, "bus") and not is_admin:
        if _ENV_LOWER not in ("dev", "test"):
            raise HTTPException(status_code=403, detail="operator for bus required")
    try:
        body = await req.json()
    except Exception:
        body = None
    if not isinstance(body, dict):
        body = {}
    # Enforce that operators bind to caller wallet unless admin/dev override.
    wallet_id = (body.get("wallet_id") or "").strip()
    user_wallet = _resolve_wallet_id_for_phone(phone)
    if wallet_id and user_wallet and wallet_id != user_wallet and not is_admin and _ENV_LOWER not in ("dev", "test"):
        raise HTTPException(status_code=403, detail="wallet_id does not belong to caller")
    if not wallet_id:
        if user_wallet:
            wallet_id = user_wallet
        elif not is_admin and _ENV_LOWER not in ("dev", "test"):
            raise HTTPException(status_code=400, detail="wallet not found for operator phone")
    body["wallet_id"] = wallet_id or None
    # Basic validation
    name = (body.get("name") or "").strip()
    if not name:
        raise HTTPException(status_code=400, detail="name required")
    try:
        if _use_bus_internal():
            if not _BUS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="bus internal not available")
            try:
                req_model = _BusOperatorIn(**body)  # type: ignore[name-defined]
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _bus_internal_session() as s:
                return _bus_create_operator(body=req_model, s=s)
        r = httpx.post(_bus_url("/operators"), json=body, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/bus/routes")
async def bus_create_route(req: Request):
    if _ENV_LOWER in ("dev", "test"):
        phone = _auth_phone(req)
        if not phone:
            raise HTTPException(status_code=401, detail="unauthorized")
    else:
        phone = _require_operator(req, "bus")
    is_admin = _is_admin(phone)
    try:
        body = await req.json()
    except Exception:
        body = None
    if not isinstance(body, dict):
        body = {}
    allowed_ops = _bus_operator_ids_for_phone(phone)
    if not allowed_ops and _ENV_LOWER in ("dev", "test"):
        allowed_ops = _bus_all_operator_ids()
        is_admin = True
    if not allowed_ops and not is_admin:
        raise HTTPException(status_code=403, detail="no bus operator linked to caller wallet")
    op_id = (body.get("operator_id") or "").strip()
    if not op_id and allowed_ops:
        op_id = allowed_ops[0]
        body["operator_id"] = op_id
    if not op_id:
        raise HTTPException(status_code=400, detail="operator_id required")
    if allowed_ops and op_id not in allowed_ops and not is_admin:
        raise HTTPException(status_code=403, detail="operator not allowed for caller")
    try:
        if _use_bus_internal():
            if not _BUS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="bus internal not available")
            try:
                req_model = _BusRouteIn(**body)  # type: ignore[name-defined]
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _bus_internal_session() as s:
                return _bus_create_route(body=req_model, s=s)
        r = httpx.post(_bus_url("/routes"), json=body, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))

@app.get("/bus/routes")
def bus_list_routes(origin_city_id: str | None = None, dest_city_id: str | None = None):
    params: dict[str, str] = {}
    if origin_city_id:
        params["origin_city_id"] = origin_city_id
    if dest_city_id:
        params["dest_city_id"] = dest_city_id
    try:
        if _use_bus_internal():
            if not _BUS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="bus internal not available")
            with _bus_internal_session() as s:
                return _bus_list_routes(origin_city_id=origin_city_id, dest_city_id=dest_city_id, s=s)
        r = httpx.get(_bus_url("/routes"), params=params or None, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))

@app.get("/bus/operators")
def bus_list_operators(request: Request):
    """
    List bus operators.

    - Superadmin/Admin: see all operators
    - Bus operators: only see operators that belong to their own wallet
    - Other users: 403
    """
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    is_admin = _is_admin(phone) or _is_superadmin(phone)
    is_op = _is_operator(phone, "bus")
    if not is_admin and not is_op:
        raise HTTPException(status_code=403, detail="operator or admin required")
    try:
        if _use_bus_internal():
            if not _BUS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="bus internal not available")
            with _bus_internal_session() as s:
                ops = _bus_list_operators(limit=50, s=s)
                if is_admin:
                    return ops
                wid = _resolve_wallet_id_for_phone(phone)
                if not wid:
                    return []
                filtered = []
                for op in ops or []:
                    try:
                        if str(getattr(op, "wallet_id", "") or "").strip() == wid:
                            filtered.append(op)
                    except Exception:
                        continue
                return filtered
        r = httpx.get(_bus_url("/operators"), timeout=10)
        if not r.headers.get("content-type", "").startswith("application/json"):
            return []
        arr = r.json()
        if not isinstance(arr, list):
            return []
        if is_admin:
            return arr
        wid = _resolve_wallet_id_for_phone(phone)
        if not wid:
            return []
        out: list[dict] = []
        for op in arr:
            try:
                if not isinstance(op, dict):
                    continue
                if str((op.get("wallet_id") or "")).strip() == wid:
                    out.append(op)
            except Exception:
                continue
        return out
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/bus/operators/{operator_id}/online")
def bus_operator_online(operator_id: str):
    """
    Toggle a Bus operator online. In monolith/internal mode this hits the
    Bus domain in‑process; otherwise it proxies to BUS_BASE_URL.
    """
    try:
        if _use_bus_internal():
            if not _BUS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="bus internal not available")
            with _bus_internal_session() as s:  # type: ignore[name-defined]
                return _bus_operator_online(operator_id=operator_id, s=s)  # type: ignore[name-defined]  # noqa: E501
        r = httpx.post(_bus_url(f"/operators/{operator_id}/online"), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/bus/operators/{operator_id}/offline")
def bus_operator_offline(operator_id: str):
    """
    Toggle a Bus operator offline. In monolith/internal mode this hits the
    Bus domain in‑process; otherwise it proxies to BUS_BASE_URL.
    """
    try:
        if _use_bus_internal():
            if not _BUS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="bus internal not available")
            with _bus_internal_session() as s:  # type: ignore[name-defined]
                return _bus_operator_offline(operator_id=operator_id, s=s)  # type: ignore[name-defined]  # noqa: E501
        r = httpx.post(_bus_url(f"/operators/{operator_id}/offline"), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/bus/operators/{operator_id}/online")
def bus_operator_online(operator_id: str, request: Request):
    _require_admin_or_superadmin(request)
    try:
        if _use_bus_internal():
            if not _BUS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="bus internal not available")
            with _bus_internal_session() as s:
                return _bus_operator_online(operator_id=operator_id, s=s)
        r = httpx.post(_bus_url(f"/operators/{operator_id}/online"), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/bus/operators/{operator_id}/offline")
def bus_operator_offline(operator_id: str, request: Request):
    _require_admin_or_superadmin(request)
    try:
        if _use_bus_internal():
            if not _BUS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="bus internal not available")
            with _bus_internal_session() as s:
                return _bus_operator_offline(operator_id=operator_id, s=s)
        r = httpx.post(_bus_url(f"/operators/{operator_id}/offline"), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))

@app.get("/bus/operators/{operator_id}/stats")
def bus_operator_stats(operator_id: str, period: str = "today"):
    try:
        if _use_bus_internal():
            if not _BUS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="bus internal not available")
            with _bus_internal_session() as s:
                return _bus_operator_stats(operator_id=operator_id, period=period, s=s)
        r = httpx.get(_bus_url(f"/operators/{operator_id}/stats"), params={"period": period}, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/bus/operators/{operator_id}/trips")
def bus_operator_trips(
    operator_id: str,
    request: Request,
    status: str | None = None,
    from_date: str | None = None,
    to_date: str | None = None,
    limit: int = 100,
    order: str = "desc",
):
    """
    List trips for a Bus operator (includes drafts). Protected via BFF auth.
    """
    if _ENV_LOWER in ("dev", "test"):
        phone = _auth_phone(request)
        if not phone:
            raise HTTPException(status_code=401, detail="unauthorized")
    else:
        phone = _require_operator(request, "bus")
    allowed_ops = _bus_operator_ids_for_phone(phone)
    is_admin = _is_admin(phone)
    if not allowed_ops and _ENV_LOWER in ("dev", "test"):
        allowed_ops = _bus_all_operator_ids()
        is_admin = True
    if not allowed_ops and not is_admin:
        raise HTTPException(status_code=403, detail="no bus operator linked to caller wallet")
    if allowed_ops and operator_id not in allowed_ops and not is_admin:
        raise HTTPException(status_code=403, detail="operator not allowed for caller")
    params: dict[str, Any] = {"limit": limit, "order": order}
    if status:
        params["status"] = status
    if from_date:
        params["from_date"] = from_date
    if to_date:
        params["to_date"] = to_date
    try:
        if _use_bus_internal():
            if not _BUS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="bus internal not available")
            with _bus_internal_session() as s:
                return _bus_operator_trips(
                    operator_id=operator_id,
                    status=status,
                    from_date=from_date,
                    to_date=to_date,
                    limit=limit,
                    order=order,
                    s=s,
                )
        r = httpx.get(_bus_url(f"/operators/{operator_id}/trips"), params=params, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/bus/trips")
async def bus_create_trip(req: Request):
    if _ENV_LOWER in ("dev", "test"):
        phone = _auth_phone(req)
        if not phone:
            raise HTTPException(status_code=401, detail="unauthorized")
    else:
        phone = _require_operator(req, "bus")
    is_admin = _is_admin(phone)
    try:
        body = await req.json()
    except Exception:
        body = None
    if not isinstance(body, dict):
        body = {}
    route_id = (body.get("route_id") or "").strip()
    if not route_id:
        raise HTTPException(status_code=400, detail="route_id required")
    route_owner = _bus_route_owner(route_id)
    if route_owner is None:
        raise HTTPException(status_code=404, detail="route not found")
    allowed_ops = _bus_operator_ids_for_phone(phone)
    if not allowed_ops and _ENV_LOWER in ('dev','test'):
        allowed_ops = _bus_all_operator_ids()
        is_admin = True
    if not allowed_ops and not is_admin:
        raise HTTPException(status_code=403, detail="no bus operator linked to caller wallet")
    if allowed_ops and route_owner not in allowed_ops and not is_admin:
        raise HTTPException(status_code=403, detail="route not allowed for caller")
    try:
        if _use_bus_internal():
            if not _BUS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="bus internal not available")
            try:
                req_model = _BusTripIn(**body)  # type: ignore[name-defined]
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _bus_internal_session() as s:
                return _bus_create_trip(body=req_model, s=s)
        r = httpx.post(_bus_url("/trips"), json=body, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/bus/trips/{trip_id}/publish")
def bus_publish_trip(trip_id: str, request: Request):
    """
    Publish a bus trip so that it appears in passenger search.
    """
    if _ENV_LOWER in ("dev", "test"):
        phone = _auth_phone(request)
        if not phone:
            raise HTTPException(status_code=401, detail="unauthorized")
    else:
        phone = _require_operator(request, "bus")
    allowed_ops = _bus_operator_ids_for_phone(phone)
    is_admin = _is_admin(phone)
    if not allowed_ops and _ENV_LOWER in ('dev','test'):
        allowed_ops = _bus_all_operator_ids()
        is_admin = True
    if not allowed_ops and not is_admin:
        raise HTTPException(status_code=403, detail="no bus operator linked to caller wallet")
    # Validate trip ownership before publishing
    route_id: str | None = None
    route_id = _bus_trip_route_id(trip_id)
    if route_id is None:
        raise HTTPException(status_code=404, detail="trip not found")
    if not route_id:
        raise HTTPException(status_code=400, detail="trip route missing")
    owner = _bus_route_owner(route_id)
    if owner is None:
        raise HTTPException(status_code=404, detail="route not found for trip")
    if allowed_ops and owner not in allowed_ops and not is_admin:
        raise HTTPException(status_code=403, detail="route not allowed for caller")
    try:
        if _use_bus_internal():
            if not _BUS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="bus internal not available")
            with _bus_internal_session() as s:
                return _bus_publish_trip(trip_id=trip_id, s=s)
        r = httpx.post(_bus_url(f"/trips/{trip_id}/publish"), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/bus/trips/{trip_id}/unpublish")
def bus_unpublish_trip(trip_id: str, request: Request):
    """
    Unpublish a bus trip (set to draft) so it does not show up in passenger search.
    """
    if _ENV_LOWER in ("dev", "test"):
        phone = _auth_phone(request)
        if not phone:
            raise HTTPException(status_code=401, detail="unauthorized")
    else:
        phone = _require_operator(request, "bus")
    allowed_ops = _bus_operator_ids_for_phone(phone)
    is_admin = _is_admin(phone)
    if not allowed_ops and _ENV_LOWER in ("dev", "test"):
        allowed_ops = _bus_all_operator_ids()
        is_admin = True
    if not allowed_ops and not is_admin:
        raise HTTPException(status_code=403, detail="no bus operator linked to caller wallet")
    route_id: str | None = None
    route_id = _bus_trip_route_id(trip_id)
    if route_id is None:
        raise HTTPException(status_code=404, detail="trip not found")
    if not route_id:
        raise HTTPException(status_code=400, detail="trip route missing")
    owner = _bus_route_owner(route_id)
    if owner is None:
        raise HTTPException(status_code=404, detail="route not found for trip")
    if allowed_ops and owner not in allowed_ops and not is_admin:
        raise HTTPException(status_code=403, detail="route not allowed for caller")
    try:
        if _use_bus_internal():
            if not _BUS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="bus internal not available")
            with _bus_internal_session() as s:
                return _bus_unpublish_trip(trip_id=trip_id, s=s)
        r = httpx.post(_bus_url(f"/trips/{trip_id}/unpublish"), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/bus/trips/{trip_id}/cancel")
def bus_cancel_trip(trip_id: str, request: Request):
    """
    Cancel a bus trip.
    """
    if _ENV_LOWER in ("dev", "test"):
        phone = _auth_phone(request)
        if not phone:
            raise HTTPException(status_code=401, detail="unauthorized")
    else:
        phone = _require_operator(request, "bus")
    allowed_ops = _bus_operator_ids_for_phone(phone)
    is_admin = _is_admin(phone)
    if not allowed_ops and _ENV_LOWER in ("dev", "test"):
        allowed_ops = _bus_all_operator_ids()
        is_admin = True
    if not allowed_ops and not is_admin:
        raise HTTPException(status_code=403, detail="no bus operator linked to caller wallet")
    route_id: str | None = None
    route_id = _bus_trip_route_id(trip_id)
    if route_id is None:
        raise HTTPException(status_code=404, detail="trip not found")
    if not route_id:
        raise HTTPException(status_code=400, detail="trip route missing")
    owner = _bus_route_owner(route_id)
    if owner is None:
        raise HTTPException(status_code=404, detail="route not found for trip")
    if allowed_ops and owner not in allowed_ops and not is_admin:
        raise HTTPException(status_code=403, detail="route not allowed for caller")
    try:
        if _use_bus_internal():
            if not _BUS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="bus internal not available")
            with _bus_internal_session() as s:
                return _bus_cancel_trip(trip_id=trip_id, s=s)
        r = httpx.post(_bus_url(f"/trips/{trip_id}/cancel"), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))

@app.get("/bus/admin/summary")
def bus_admin_summary(request: Request):
    _require_operator(request, "bus")
    try:
        if _use_bus_internal():
            if not _BUS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="bus internal not available")
            with _bus_internal_session() as s:
                return _bus_admin_summary(s=s)
        r = httpx.get(_bus_url("/admin/summary"), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/payments/requests")
async def payments_req_create(req: Request):
    phone, caller_wallet_id = _require_caller_wallet(req)
    can_admin = _is_admin(phone)
    _rate_limit_payments_edge(
        req,
        wallet_id=caller_wallet_id,
        scope="requests_write",
        wallet_max=PAY_API_REQ_WRITE_MAX_PER_WALLET,
        ip_max=PAY_API_REQ_WRITE_MAX_PER_IP,
    )
    try:
        body = await req.json()
    except Exception:
        body = {}
    if not isinstance(body, dict):
        body = {}
    payload = dict(body)
    from_wallet_id = str(payload.get("from_wallet_id") or "").strip()
    if from_wallet_id and from_wallet_id != caller_wallet_id and not can_admin:
        _audit_from_request(
            req,
            "payments_request_from_wallet_mismatch",
            requested_wallet_id=from_wallet_id,
            caller_wallet_id=caller_wallet_id,
        )
        raise HTTPException(status_code=403, detail="from_wallet_id does not belong to caller")
    if not can_admin:
        payload["from_wallet_id"] = caller_wallet_id
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            data = payload or {}
            if not isinstance(data, dict):
                data = {}
            try:
                req_model = _PayRequestCreate(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            try:
                with _pay_internal_session() as s:
                    return _pay_create_request(req_model, s=s)
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(status_code=502, detail=str(e))
        r = httpx.post(
            _payments_url("/requests"),
            json=payload,
            headers=_payments_headers(),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/payments/requests")
def payments_req_list(request: Request, wallet_id: str = "", kind: str = "", limit: int = 100):
    phone, caller_wallet_id = _require_caller_wallet(request)
    can_admin = _is_admin(phone)
    _rate_limit_payments_edge(
        request,
        wallet_id=caller_wallet_id,
        scope="requests_read",
        wallet_max=PAY_API_REQ_READ_MAX_PER_WALLET,
        ip_max=PAY_API_REQ_READ_MAX_PER_IP,
    )
    requested_wallet_id = (wallet_id or "").strip()
    if requested_wallet_id and requested_wallet_id != caller_wallet_id and not can_admin:
        raise HTTPException(status_code=403, detail="wallet_id does not belong to caller")
    target_wallet_id = requested_wallet_id if requested_wallet_id else caller_wallet_id
    params = {"wallet_id": target_wallet_id}
    if kind: params["kind"] = kind
    params["limit"] = max(1, min(limit, 500))
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            try:
                with _pay_internal_session() as s:
                    return _pay_list_requests(wallet_id=target_wallet_id, kind=kind, limit=max(1, min(limit, 500)), s=s)
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(status_code=502, detail=str(e))
        r = httpx.get(
            _payments_url("/requests"),
            params=params,
            headers=_payments_headers(),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/payments/resolve/phone/{phone}")
def payments_resolve_phone(phone: str, request: Request):
    caller_phone, caller_wallet_id = _require_caller_wallet(request)
    _rate_limit_payments_edge(
        request,
        wallet_id=caller_wallet_id,
        scope="resolve_phone",
        wallet_max=PAY_API_RESOLVE_MAX_PER_WALLET,
        ip_max=PAY_API_RESOLVE_MAX_PER_IP,
    )
    target_phone = (phone or "").strip()
    if not re.fullmatch(r"\+[1-9][0-9]{7,14}", target_phone):
        raise HTTPException(status_code=400, detail="invalid phone format")
    can_admin = _is_admin(caller_phone)
    result: Any
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            try:
                with _pay_internal_session() as s:
                    result = _pay_resolve_phone(phone=target_phone, s=s)
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(status_code=502, detail=str(e))
        else:
            r = httpx.get(
                _payments_url(f"/resolve/phone/{target_phone}"),
                headers=_payments_headers(),
                timeout=10,
            )
            result = r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))
    if can_admin or target_phone == caller_phone:
        return result
    wallet_id = ""
    if isinstance(result, dict):
        wallet_id = str(result.get("wallet_id") or "").strip()
    else:
        try:
            wallet_id = str(getattr(result, "wallet_id", "") or "").strip()
        except Exception:
            wallet_id = ""
    if not wallet_id:
        raise HTTPException(status_code=404, detail="phone not found")
    _audit_from_request(request, "payments_resolve_phone_privacy_redact", target_phone=target_phone)
    return {"wallet_id": wallet_id}


@app.post("/payments/requests/by_phone")
async def payments_req_by_phone(req: Request):
    phone, caller_wallet_id = _require_caller_wallet(req)
    can_admin = _is_admin(phone)
    _rate_limit_payments_edge(
        req,
        wallet_id=caller_wallet_id,
        scope="requests_write",
        wallet_max=PAY_API_REQ_WRITE_MAX_PER_WALLET,
        ip_max=PAY_API_REQ_WRITE_MAX_PER_IP,
    )
    # body: {from_wallet_id, to_phone, amount_cents, message?, expires_in_secs?}
    try:
        body = await req.json()
    except Exception:
        body = {}
    if not isinstance(body, dict):
        body = {}
    payload = dict(body)
    requested_from_wallet_id = str(payload.get("from_wallet_id") or "").strip()
    if requested_from_wallet_id and requested_from_wallet_id != caller_wallet_id and not can_admin:
        raise HTTPException(status_code=403, detail="from_wallet_id does not belong to caller")
    if not can_admin:
        payload["from_wallet_id"] = caller_wallet_id
    to_phone = payload.get("to_phone")
    if not to_phone:
        raise HTTPException(status_code=400, detail="to_phone required")
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            with _pay_internal_session() as s:
                # resolve phone -> wallet
                try:
                    res = _pay_resolve_phone(phone=to_phone, s=s)
                    to_wallet = res.wallet_id
                except HTTPException:
                    raise
                except Exception as e:
                    raise HTTPException(status_code=502, detail=str(e))
                req_payload = {k: v for k, v in payload.items() if k != "to_phone"}
                req_payload["to_wallet_id"] = to_wallet
                try:
                    req_model = _PayRequestCreate(**req_payload)
                except Exception as e:
                    raise HTTPException(status_code=400, detail=str(e))
                pr = _pay_create_request(req_model, s=s)
            # SMS Notify bleibt wie bisher
            try:
                amt = payload.get("amount_cents")
                msg = payload.get("message") or ""
                if os.getenv("SMS_NOTIFY_URL"):
                    httpx.post(os.getenv("SMS_NOTIFY_URL"), json={"to": to_phone, "text": f"Payment request: {amt}. {msg}"}, timeout=5)
            except Exception:
                pass
            return pr
        # HTTP-Fallback
        rr = httpx.get(
            _payments_url(f"/resolve/phone/{to_phone}"),
            headers=_payments_headers(),
            timeout=10,
        )
        to_wallet = rr.json().get("wallet_id") if rr.status_code == 200 else None
        if not to_wallet:
            raise HTTPException(status_code=404, detail="phone not found")
        req_payload = {k: v for k, v in payload.items() if k != "to_phone"}
        req_payload["to_wallet_id"] = to_wallet
        r = httpx.post(
            _payments_url("/requests"),
            json=req_payload,
            headers=_payments_headers(),
            timeout=10,
        )
        try:
            j = r.json()
        except Exception:
            j = {"status_code": r.status_code, "raw": r.text}
        if r.status_code == 200:
            try:
                amt = payload.get("amount_cents")
                msg = payload.get("message") or ""
                if os.getenv('SMS_NOTIFY_URL'):
                    httpx.post(os.getenv('SMS_NOTIFY_URL'), json={"to": to_phone, "text": f"Payment request: {amt}. {msg}"}, timeout=5)
            except Exception:
                pass
        return j
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/payments/requests/{rid}/accept")
async def payments_req_accept(rid: str, req: Request):
    phone, caller_wallet_id = _require_caller_wallet(req)
    can_admin = _is_admin(phone)
    _rate_limit_payments_edge(
        req,
        wallet_id=caller_wallet_id,
        scope="requests_write",
        wallet_max=PAY_API_REQ_WRITE_MAX_PER_WALLET,
        ip_max=PAY_API_REQ_WRITE_MAX_PER_IP,
    )
    try:
        try:
            body = await req.json() if hasattr(req, "json") else {}
        except Exception:
            body = {}
        if not isinstance(body, dict):
            body = {}
        to_wallet_id = str(body.get("to_wallet_id") or "").strip()
        if to_wallet_id and to_wallet_id != caller_wallet_id and not can_admin:
            raise HTTPException(status_code=403, detail="to_wallet_id does not belong to caller")
        if not can_admin:
            to_wallet_id = caller_wallet_id
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            ikey = req.headers.get("Idempotency-Key") if hasattr(req, "headers") else None
            with _pay_internal_session() as s:
                if _pay_accept_request_core:  # type: ignore[truthy-function]
                    return _pay_accept_request_core(rid=rid, ikey=ikey, s=s, to_wallet_id=to_wallet_id)  # type: ignore[arg-type]
                return _pay_accept_request(rid=rid, s=s)
        r = httpx.post(
            _payments_url(f"/requests/{rid}/accept"),
            json={"to_wallet_id": to_wallet_id},
            headers=_payments_headers(),
            timeout=10,
        )
        return r.json()
    except HTTPException:
        raise
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/payments/requests/{rid}/cancel")
def payments_req_cancel(rid: str, request: Request):
    phone, caller_wallet_id = _require_caller_wallet(request)
    can_admin = _is_admin(phone)
    _rate_limit_payments_edge(
        request,
        wallet_id=caller_wallet_id,
        scope="requests_write",
        wallet_max=PAY_API_REQ_WRITE_MAX_PER_WALLET,
        ip_max=PAY_API_REQ_WRITE_MAX_PER_IP,
    )
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            try:
                with _pay_internal_session() as s:
                    if not can_admin:
                        incoming = _pay_list_requests(wallet_id=caller_wallet_id, kind="incoming", limit=500, s=s)
                        outgoing = _pay_list_requests(wallet_id=caller_wallet_id, kind="outgoing", limit=500, s=s)
                        owned = False
                        for row in list(incoming or []) + list(outgoing or []):
                            try:
                                row_id = str(getattr(row, "id", "") or "")
                            except Exception:
                                row_id = ""
                            if row_id == rid:
                                owned = True
                                break
                        if not owned:
                            raise HTTPException(status_code=404, detail="payment request not found")
                    return _pay_cancel_request(rid=rid, s=s)
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(status_code=502, detail=str(e))
        if not can_admin:
            owned = False
            for kind in ("incoming", "outgoing"):
                chk = httpx.get(
                    _payments_url("/requests"),
                    params={"wallet_id": caller_wallet_id, "kind": kind, "limit": 500},
                    headers=_payments_headers(),
                    timeout=10,
                )
                rows = chk.json() if chk.headers.get("content-type", "").startswith("application/json") else []
                if isinstance(rows, list):
                    for row in rows:
                        try:
                            row_id = str((row or {}).get("id") or "").strip()
                        except Exception:
                            row_id = ""
                        if row_id == rid:
                            owned = True
                            break
                if owned:
                    break
            if not owned:
                raise HTTPException(status_code=404, detail="payment request not found")
        r = httpx.post(
            _payments_url(f"/requests/{rid}/cancel"),
            headers=_payments_headers(),
            timeout=10,
        )
        return r.json() if r.headers.get("content-type", "").startswith("application/json") else {"raw": r.text}
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/payments/cash/redeem")
async def payments_cash_redeem(req: Request):
    _require_admin_v2(req)
    if not PAYMENTS_INTERNAL_SECRET:
        raise HTTPException(status_code=403, detail="Server not configured for cash redeem")
    try:
        body = await req.json()
    except Exception:
        body = None
    headers = {"X-Internal-Secret": PAYMENTS_INTERNAL_SECRET}
    try:
        ikey = req.headers.get("Idempotency-Key") if hasattr(req, 'headers') else None
    except Exception:
        ikey = None
    if ikey:
        headers["Idempotency-Key"] = ikey
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                req_model = _PayCashRedeemReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            try:
                with _pay_internal_session() as s:
                    return _pay_cash_redeem(req_model, s=s, admin_ok=True)
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(status_code=502, detail=str(e))
        r = httpx.post(
            _payments_url("/cash/redeem"),
            json=body,
            headers=_payments_headers(headers),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/payments/cash/cancel")
async def payments_cash_cancel(req: Request):
    _require_admin_v2(req)
    if not PAYMENTS_INTERNAL_SECRET:
        raise HTTPException(status_code=403, detail="Server not configured for cash cancel")
    try:
        body = await req.json()
    except Exception:
        body = None
    headers = {"X-Internal-Secret": PAYMENTS_INTERNAL_SECRET}
    try:
        ikey = req.headers.get("Idempotency-Key") if hasattr(req, 'headers') else None
    except Exception:
        ikey = None
    if ikey:
        headers["Idempotency-Key"] = ikey
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                req_model = _PayCashCancelReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            try:
                with _pay_internal_session() as s:
                    return _pay_cash_cancel(req_model, s=s, admin_ok=True)
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(status_code=502, detail=str(e))
        r = httpx.post(
            _payments_url("/cash/cancel"),
            json=body,
            headers=_payments_headers(headers),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/payments/cash/status/{code}")
def payments_cash_status(code: str):
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            try:
                with _pay_internal_session() as s:
                    return _pay_cash_status(code=code, s=s)
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(status_code=502, detail=str(e))
        r = httpx.get(
            _payments_url(f"/cash/status/{code}"),
            headers=_payments_headers(),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


# ---- Sonic Pay proxies ----
@app.post("/payments/sonic/issue")
async def payments_sonic_issue(req: Request):
    _require_admin_v2(req)
    if not PAYMENTS_INTERNAL_SECRET:
        raise HTTPException(status_code=403, detail="Server not configured for sonic issue")
    try:
        body = await req.json()
    except Exception:
        body = None
    headers = {"X-Internal-Secret": PAYMENTS_INTERNAL_SECRET}
    try:
        ikey = req.headers.get("Idempotency-Key") if hasattr(req, 'headers') else None
    except Exception:
        ikey = None
    if ikey:
        headers["Idempotency-Key"] = ikey
    try:
        body = _normalize_amount(body)
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                req_model = _PaySonicIssueReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            try:
                with _pay_internal_session() as s:
                    return _pay_sonic_issue(req_model, s=s, admin_ok=True)
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(status_code=502, detail=str(e))
        r = httpx.post(
            _payments_url("/sonic/issue"),
            json=body,
            headers=_payments_headers(headers),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/payments/sonic/redeem")
async def payments_sonic_redeem(req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    if not isinstance(body, dict):
        body = {}
    # Auto-fill to_wallet_id from the authenticated user when missing.
    phone = _auth_phone(req)
    to_wallet = (body.get("to_wallet_id") or "").strip()
    if not to_wallet and phone:
        try:
            to_wallet = _resolve_wallet_id_for_phone(phone) or ""
        except Exception:
            to_wallet = ""
        if to_wallet:
            body["to_wallet_id"] = to_wallet
    headers = {}
    try:
        ikey = req.headers.get("Idempotency-Key") if hasattr(req, 'headers') else None
    except Exception:
        ikey = None
    if ikey:
        headers["Idempotency-Key"] = ikey
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                req_model = _PaySonicRedeemReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            try:
                with _pay_internal_session() as s:
                    return _pay_sonic_redeem(req_model, request=req, s=s)
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(status_code=502, detail=str(e))
        r = httpx.post(
            _payments_url("/sonic/redeem"),
            json=body,
            headers=_payments_headers(headers),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


# ---- Red Packet (WeChat-style hongbao) proxies ----
@app.post("/payments/redpacket/issue")
async def payments_redpacket_issue(req: Request):
    # User-initiated pooled payment; mirrors /payments/transfer semantics.
    try:
        body = await req.json()
    except Exception:
        body = None
    headers: dict[str, str] = {}
    try:
        ikey = req.headers.get("Idempotency-Key") if hasattr(req, "headers") else None
        dev = req.headers.get("X-Device-ID") if hasattr(req, "headers") else None
        ua = req.headers.get("User-Agent") if hasattr(req, "headers") else None
    except Exception:
        ikey = None
        dev = None
        ua = None
    if ikey:
        headers["Idempotency-Key"] = ikey
    if dev:
        headers["X-Device-ID"] = dev
    if ua:
        headers["User-Agent"] = ua
    try:
        body = _normalize_amount(body)
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                req_model = _PayRedPacketIssueReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            try:
                with _pay_internal_session() as s:
                    result = _pay_redpacket_issue(req_model, s=s)
                try:
                    payload = {}
                    if isinstance(body, dict):
                        payload = {
                            "redpacket_id": getattr(result, "id", None),
                            "creator_wallet_id": body.get("creator_wallet_id"),
                            "amount_cents": body.get("amount_cents"),
                            "count": body.get("count"),
                            "mode": body.get("mode"),
                            "group_id": body.get("group_id"),
                        }
                    emit_event("payments", "redpacket_issue", payload)
                except Exception:
                    pass
                return result
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(status_code=502, detail=str(e))
        r = httpx.post(
            _payments_url("/redpacket/issue"),
            json=body,
            headers=_payments_headers(headers),
            timeout=10,
        )
        out = r.json()
        try:
            payload = {}
            if isinstance(body, dict):
                payload = {
                    "redpacket_id": out.get("id"),
                    "creator_wallet_id": body.get("creator_wallet_id"),
                    "amount_cents": body.get("amount_cents"),
                    "count": body.get("count"),
                    "mode": body.get("mode"),
                    "group_id": body.get("group_id"),
                }
            emit_event("payments", "redpacket_issue", payload)
        except Exception:
            pass
        return out
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/payments/redpacket/claim")
async def payments_redpacket_claim(req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    if not isinstance(body, dict):
        body = {}
    # Auto-fill wallet_id for authenticated user when missing.
    phone = _auth_phone(req)
    wallet_id = (body.get("wallet_id") or "").strip()
    if not wallet_id and phone:
        try:
            wallet_id = _resolve_wallet_id_for_phone(phone) or ""
        except Exception:
            wallet_id = ""
        if wallet_id:
            body["wallet_id"] = wallet_id
    headers: dict[str, str] = {}
    try:
        ikey = req.headers.get("Idempotency-Key") if hasattr(req, "headers") else None
    except Exception:
        ikey = None
    if ikey:
        headers["Idempotency-Key"] = ikey
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                req_model = _PayRedPacketClaimReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            try:
                with _pay_internal_session() as s:
                    result = _pay_redpacket_claim(req_model, s=s)
                try:
                    payload = {}
                    if isinstance(body, dict):
                        payload = {
                            "redpacket_id": body.get("redpacket_id"),
                            "wallet_id": body.get("wallet_id"),
                        }
                    emit_event("payments", "redpacket_claim", payload)
                except Exception:
                    pass
                return result
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(status_code=502, detail=str(e))
        r = httpx.post(
            _payments_url("/redpacket/claim"),
            json=body,
            headers=_payments_headers(headers),
            timeout=10,
        )
        out = r.json()
        try:
            payload = {}
            if isinstance(body, dict):
                payload = {
                    "redpacket_id": body.get("redpacket_id"),
                    "wallet_id": body.get("wallet_id"),
                    "amount_cents": out.get("amount_cents"),
                }
            emit_event("payments", "redpacket_claim", payload)
        except Exception:
            pass
        return out
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/payments/redpacket/status/{rid}")
def payments_redpacket_status(rid: str):
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            try:
                with _pay_internal_session() as s:
                    return _pay_redpacket_status(rid=rid, s=s)
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(status_code=502, detail=str(e))
        r = httpx.get(
            _payments_url(f"/redpacket/status/{rid}"),
            headers=_payments_headers(),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/payments/idempotency/{ikey}")
def payments_idempotency(ikey: str, request: Request):
    _require_caller_wallet(request)
    try:
        r = httpx.get(
            _payments_url(f"/idempotency/{ikey}"),
            headers=_payments_headers(),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


# ---- Savings proxies ----
@app.post("/payments/savings/deposit")
async def payments_savings_deposit(req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    if not isinstance(body, dict):
        body = {}
    # Auto-fill wallet_id from authenticated user.
    phone = _auth_phone(req)
    wid = (body.get("wallet_id") or "").strip()
    if not wid and phone:
        try:
            wid = _resolve_wallet_id_for_phone(phone) or ""
        except Exception:
            wid = ""
        if wid:
            body["wallet_id"] = wid
    body = _normalize_amount(body)
    headers: dict[str, str] = {}
    try:
        ikey = req.headers.get("Idempotency-Key") if hasattr(req, "headers") else None
    except Exception:
        ikey = None
    if ikey:
        headers["Idempotency-Key"] = ikey
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                req_model = _PaySavingsDepositReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            try:
                with _pay_internal_session() as s:
                    result = _pay_savings_deposit(req_model, s=s)
                try:
                    payload = {}
                    if isinstance(body, dict):
                        payload = {
                            "wallet_id": body.get("wallet_id"),
                            "amount_cents": body.get("amount_cents"),
                        }
                    emit_event("payments", "savings_deposit", payload)
                except Exception:
                    pass
                return result
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(status_code=502, detail=str(e))
        r = httpx.post(
            _payments_url("/savings/deposit"),
            json=body,
            headers=_payments_headers(headers),
            timeout=10,
        )
        out = r.json()
        try:
            payload = {}
            if isinstance(body, dict):
                payload = {
                    "wallet_id": body.get("wallet_id"),
                    "amount_cents": body.get("amount_cents"),
                }
            emit_event("payments", "savings_deposit", payload)
        except Exception:
            pass
        return out
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/payments/savings/withdraw")
async def payments_savings_withdraw(req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    if not isinstance(body, dict):
        body = {}
    phone = _auth_phone(req)
    wid = (body.get("wallet_id") or "").strip()
    if not wid and phone:
        try:
            wid = _resolve_wallet_id_for_phone(phone) or ""
        except Exception:
            wid = ""
        if wid:
            body["wallet_id"] = wid
    body = _normalize_amount(body)
    headers: dict[str, str] = {}
    try:
        ikey = req.headers.get("Idempotency-Key") if hasattr(req, "headers") else None
    except Exception:
        ikey = None
    if ikey:
        headers["Idempotency-Key"] = ikey
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                req_model = _PaySavingsWithdrawReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            try:
                with _pay_internal_session() as s:
                    result = _pay_savings_withdraw(req_model, s=s)
                try:
                    payload = {}
                    if isinstance(body, dict):
                        payload = {
                            "wallet_id": body.get("wallet_id"),
                            "amount_cents": body.get("amount_cents"),
                        }
                    emit_event("payments", "savings_withdraw", payload)
                except Exception:
                    pass
                return result
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(status_code=502, detail=str(e))
        r = httpx.post(
            _payments_url("/savings/withdraw"),
            json=body,
            headers=_payments_headers(headers),
            timeout=10,
        )
        out = r.json()
        try:
            payload = {}
            if isinstance(body, dict):
                payload = {
                    "wallet_id": body.get("wallet_id"),
                    "amount_cents": body.get("amount_cents"),
                }
            emit_event("payments", "savings_withdraw", payload)
        except Exception:
            pass
        return out
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/payments/savings/overview")
def payments_savings_overview(wallet_id: str):
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            try:
                with _pay_internal_session() as s:
                    return _pay_savings_overview(wallet_id=wallet_id, s=s)
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(status_code=502, detail=str(e))
        r = httpx.get(
            _payments_url(f"/savings/overview?wallet_id={wallet_id}"),
            headers=_payments_headers(),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/payments/bills/pay")
async def payments_bills_pay(req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    if not isinstance(body, dict):
        body = {}
    # Normalize amount payload so both internal + HTTP share the same format.
    body = _normalize_amount(body)
    headers: dict[str, str] = {}
    try:
        ikey = req.headers.get("Idempotency-Key") if hasattr(req, "headers") else None
        dev = req.headers.get("X-Device-ID") if hasattr(req, "headers") else None
        ua = req.headers.get("User-Agent") if hasattr(req, "headers") else None
    except Exception:
        ikey = None
        dev = None
        ua = None
    if ikey:
        headers["Idempotency-Key"] = ikey
    if dev:
        headers["X-Device-ID"] = dev
    if ua:
        headers["User-Agent"] = ua
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(
                    status_code=500, detail="payments internal not available"
                )
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                req_model = _PayBillPayReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            try:
                with _pay_internal_session() as s:
                    result = _pay_bills_pay(req_model, request=req, s=s)
                try:
                    payload = {}
                    if isinstance(body, dict):
                        payload = {
                            "from_wallet_id": body.get("from_wallet_id"),
                            "to_wallet_id": body.get("to_wallet_id"),
                            "biller_code": body.get("biller_code"),
                            "amount_cents": body.get("amount_cents"),
                            "device_id": dev,
                        }
                    emit_event("payments", "bill_pay", payload)
                except Exception:
                    pass
                return result
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(status_code=502, detail=str(e))
        r = httpx.post(
            _payments_url("/bills/pay"),
            json=body,
            headers=_payments_headers(headers),
            timeout=10,
        )
        out = r.json()
        try:
            payload = {}
            if isinstance(body, dict):
                payload = {
                    "from_wallet_id": body.get("from_wallet_id"),
                    "to_wallet_id": body.get("to_wallet_id"),
                    "biller_code": body.get("biller_code"),
                    "amount_cents": body.get("amount_cents"),
                    "device_id": dev,
                }
            emit_event("payments", "bill_pay", payload)
        except Exception:
            pass
        return out
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


def _payments_billers_config() -> list[dict[str, str]]:
    return [
        {
            "code": "electricity",
            "label_en": "Electricity",
            "label_ar": "الكهرباء",
            "wallet_id": os.getenv("BILLER_ELECTRICITY_WALLET_ID", ""),
        },
        {
            "code": "mobile",
            "label_en": "Mobile top‑up",
            "label_ar": "شحن الجوال",
            "wallet_id": os.getenv("BILLER_MOBILE_WALLET_ID", ""),
        },
        {
            "code": "internet",
            "label_en": "Internet",
            "label_ar": "الإنترنت",
            "wallet_id": os.getenv("BILLER_INTERNET_WALLET_ID", ""),
        },
        {
            "code": "water",
            "label_en": "Water",
            "label_ar": "المياه",
            "wallet_id": os.getenv("BILLER_WATER_WALLET_ID", ""),
        },
    ]


@app.get("/payments/billers")
def payments_billers():
    """
    Static biller directory for enduser clients.

    Wallet IDs can be configured via environment variables:
      - BILLER_ELECTRICITY_WALLET_ID
      - BILLER_MOBILE_WALLET_ID
      - BILLER_INTERNET_WALLET_ID
      - BILLER_WATER_WALLET_ID
    """
    return _payments_billers_config()


# ---- Alias proxies ----
@app.post("/payments/alias/request")
async def payments_alias_request(req: Request):
    _phone, caller_wallet_id = _require_caller_wallet(req)
    try:
        body = await req.json()
    except Exception:
        body = None
    if not isinstance(body, dict):
        body = {}
    payload = dict(body)
    requested_wallet_id = str(payload.get("wallet_id") or "").strip()
    requested_user_id = str(payload.get("user_id") or "").strip()
    if requested_wallet_id and requested_wallet_id != caller_wallet_id:
        _audit_from_request(
            req,
            "alias_request_wallet_mismatch",
            requested_wallet_id=requested_wallet_id,
            caller_wallet_id=caller_wallet_id,
        )
        raise HTTPException(status_code=403, detail="wallet_id does not belong to caller")
    if requested_user_id:
        _audit_from_request(
            req,
            "alias_request_user_override_blocked",
            requested_user_id=requested_user_id,
        )
        raise HTTPException(status_code=403, detail="user_id override not allowed")
    payload["wallet_id"] = caller_wallet_id
    payload.pop("user_id", None)
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            data = payload or {}
            if not isinstance(data, dict):
                data = {}
            try:
                req_model = _PayAliasRequest(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            try:
                with _pay_internal_session() as s:
                    return _pay_alias_request(req_model, s=s)
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(status_code=502, detail=str(e))
        r = httpx.post(
            _payments_url("/alias/request"),
            json=payload,
            headers=_payments_headers(),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


# ---- EV / Charging helpers (TomTom) ----


@app.get("/ev/stations")
def ev_stations(
    lat: float,
    lon: float,
    radius_m: int = 5000,
    connector: str | None = None,
    min_kw: float | None = None,
    provider: str | None = None,
    limit: int = 20,
):
    """
    Nearby EV charging stations with optional live availability (TomTom).

    Query params:
      - lat, lon: center point
      - radius_m: search radius (default 5000)
      - connector: optional connector type filter (e.g. 'ccs', 'type2')
      - min_kw: minimum connector power (kW)
      - provider: substring to match operator/brand
      - limit: max stations to return (<= 50)
    """
    if not TOMTOM_API_KEY:
        raise HTTPException(status_code=400, detail="TOMTOM_API_KEY not configured")
    base = TOMTOM_BASE.rstrip("/")
    radius_m = max(500, min(radius_m, 50000))
    limit = max(1, min(limit, 50))
    # TomTom categorySearch for EV charging locations
    from urllib.parse import quote

    category = "electric.vehicle.charging.location"
    path = f"/search/2/categorySearch/{quote(category)}.json"
    params: dict[str, object] = {
        "key": TOMTOM_API_KEY,
        "lat": float(lat),
        "lon": float(lon),
        "radius": radius_m,
        "limit": limit,
        # Request charging availability extension when enabled in account.
        "extensions": "chargingAvailability",
    }
    try:
        r = _httpx_client().get(base + path, params=params)
    except Exception as e:
        raise HTTPException(status_code=502, detail=f"ev upstream error: {e}")
    if r.status_code >= 400:
        raise HTTPException(status_code=502, detail=f"ev upstream error: {r.text[:200]}")
    try:
        j = r.json()
    except Exception as e:
        raise HTTPException(status_code=502, detail=f"invalid ev json: {e}")
    results = j.get("results") or []
    out: list[dict[str, Any]] = []
    connector_filter = (connector or "").strip().lower()
    provider_filter = (provider or "").strip().lower()
    for item in results:
        try:
            if not isinstance(item, dict):
                continue
            pos = item.get("position") or {}
            plat = float(pos.get("lat") or pos.get("latitude") or 0.0)
            plon = float(pos.get("lon") or pos.get("longitude") or 0.0)
            poi = item.get("poi") or {}
            name = ""
            brand = ""
            cats = []
            if isinstance(poi, dict):
                name = (poi.get("name") or "") or ""
                brand = (poi.get("brand") or poi.get("operator") or "") or ""
                cats = poi.get("categories") or []
            addr_str = ""
            address = item.get("address") or {}
            if isinstance(address, dict):
                addr_str = (address.get("freeformAddress") or "") or ""
            # Charging park / connectors
            park = item.get("chargingPark") or {}
            connectors_raw = []
            if isinstance(park, dict):
                connectors_raw = park.get("connectors") or park.get("connectorSet") or []
            connectors_out: list[dict[str, Any]] = []
            max_power_kw: float | None = None
            has_connector_match = False if connector_filter else True
            has_power_match = False if min_kw is not None else True
            for c in connectors_raw or []:
                if not isinstance(c, dict):
                    continue
                raw_type = c.get("type") or c.get("connectorType") or ""
                ctype = str(raw_type)
                try:
                    pkw = float(c.get("maxPowerKW") or c.get("powerKW") or 0.0)
                except Exception:
                    pkw = 0.0
                connectors_out.append({"type": ctype, "power_kw": pkw})
                if max_power_kw is None or pkw > max_power_kw:
                    max_power_kw = pkw
                if connector_filter and ctype.lower().find(connector_filter) >= 0:
                    has_connector_match = True
                if min_kw is not None and pkw >= float(min_kw):
                    has_power_match = True
            # Filters
            if connector_filter and not has_connector_match:
                continue
            if min_kw is not None and not has_power_match:
                continue
            if provider_filter:
                provider_text = f"{name} {brand}".lower()
                if provider_filter not in provider_text:
                    continue
            availability = item.get("chargingAvailability") or {}
            out.append(
                {
                    "lat": plat,
                    "lon": plon,
                    "name": name,
                    "address": addr_str,
                    "brand": brand,
                    "categories": cats,
                    "connectors": connectors_out,
                    "max_power_kw": max_power_kw,
                    "availability": availability,
                }
            )
        except Exception:
            continue
    return {"ok": True, "count": len(out), "stations": out}


# ---- Carmarket proxies ----
def _carmarket_url(path: str) -> str:
    if not CARMARKET_BASE:
        raise HTTPException(status_code=500, detail="CARMARKET_BASE_URL not configured")
    return CARMARKET_BASE.rstrip("/") + path


# --- Carmarket internal service (monolith mode) ---
_CARMARKET_INTERNAL_AVAILABLE = False
try:
    from sqlalchemy.orm import Session as _CarmarketSession  # type: ignore[import]
    from apps.carmarket.app import main as _carmarket_main  # type: ignore[import]
    from apps.carmarket.app.main import (  # type: ignore[import]
        engine as _carmarket_engine,
        get_session as _carmarket_get_session,
        ListingCreate as _CarmarketListingCreate,
        ListingUpdate as _CarmarketListingUpdate,
        ListingOut as _CarmarketListingOut,
        InquiryCreate as _CarmarketInquiryCreate,
        create_listing as _carmarket_create_listing,
        list_listings as _carmarket_list_listings,
        get_listing as _carmarket_get_listing,
        update_listing as _carmarket_update_listing,
        delete_listing as _carmarket_delete_listing,
        create_inquiry as _carmarket_create_inquiry,
    )
    _CARMARKET_INTERNAL_AVAILABLE = True
except Exception:
    _CarmarketSession = None  # type: ignore[assignment]
    _carmarket_engine = None  # type: ignore[assignment]
    _CARMARKET_INTERNAL_AVAILABLE = False


def _use_carmarket_internal() -> bool:
    if _force_internal(_CARMARKET_INTERNAL_AVAILABLE):
        return True
    mode = os.getenv("CARMARKET_INTERNAL_MODE", "auto").lower()
    if mode == "off":
        return False
    if not _CARMARKET_INTERNAL_AVAILABLE:
        return False
    if mode == "on":
        return True
    return not bool(CARMARKET_BASE)


def _carmarket_internal_session():
    if not _CARMARKET_INTERNAL_AVAILABLE or _CarmarketSession is None or _carmarket_engine is None:  # type: ignore[truthy-function]
        raise RuntimeError("Carmarket internal service not available")
    return _CarmarketSession(_carmarket_engine)  # type: ignore[call-arg]


@app.get("/carmarket/listings")
def car_listings(q: str = "", city: str = "", make: str = "", min_price: int = 0, max_price: int = 0, limit: int = 20):
    params: dict[str, object] = {}
    if q:
        params["q"] = q
    if city:
        params["city"] = city
    if make:
        params["make"] = make
    if min_price:
        params["min_price"] = min_price
    if max_price:
        params["max_price"] = max_price
    params["limit"] = max(1, min(limit, 50))
    try:
        if _use_carmarket_internal():
            if not _CARMARKET_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="carmarket internal not available")
            min_p = None if min_price <= 0 else min_price
            max_p = None if max_price <= 0 else max_price
            with _carmarket_internal_session() as s:
                return _carmarket_list_listings(q=q, city=city, make=make, min_price=min_p, max_price=max_p, limit=limit, s=s)
        r = httpx.get(_carmarket_url("/listings"), params=params, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/carmarket/listings/{lid}")
def car_get_listing(lid: int):
    try:
        if _use_carmarket_internal():
            if not _CARMARKET_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="carmarket internal not available")
            with _carmarket_internal_session() as s:
                return _carmarket_get_listing(listing_id=lid, s=s)
        r = httpx.get(_carmarket_url(f"/listings/{lid}"), timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/carmarket/listings")
async def car_create_listing(req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    headers: dict[str, str] = {}
    try:
        ikey = req.headers.get("Idempotency-Key")
    except Exception:
        ikey = None
    if ikey:
        headers["Idempotency-Key"] = ikey
    try:
        if _use_carmarket_internal():
            if not _CARMARKET_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="carmarket internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                lreq = _CarmarketListingCreate(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _carmarket_internal_session() as s:
                return _carmarket_create_listing(req=lreq, idempotency_key=ikey, s=s)
        r = httpx.post(_carmarket_url("/listings"), json=body, headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.patch("/carmarket/listings/{lid}")
async def car_update_listing(lid: int, req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_carmarket_internal():
            if not _CARMARKET_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="carmarket internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                ureq = _CarmarketListingUpdate(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _carmarket_internal_session() as s:
                return _carmarket_update_listing(listing_id=lid, req=ureq, s=s)
        r = httpx.patch(_carmarket_url(f"/listings/{lid}"), json=body, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.delete("/carmarket/listings/{lid}")
def car_delete_listing(lid: int):
    try:
        if _use_carmarket_internal():
            if not _CARMARKET_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="carmarket internal not available")
            with _carmarket_internal_session() as s:
                return _carmarket_delete_listing(listing_id=lid, s=s)
        r = httpx.delete(_carmarket_url(f"/listings/{lid}"), timeout=10)
        return r.json() if r.headers.get("content-type", "").startswith("application/json") else {"raw": r.text, "status_code": r.status_code}
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/carmarket/inquiries")
async def car_create_inquiry(req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    headers: dict[str, str] = {}
    try:
        ikey = req.headers.get("Idempotency-Key")
    except Exception:
        ikey = None
    if ikey:
        headers["Idempotency-Key"] = ikey
    try:
        if _use_carmarket_internal():
            if not _CARMARKET_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="carmarket internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                ireq = _CarmarketInquiryCreate(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _carmarket_internal_session() as s:
                return _carmarket_create_inquiry(req=ireq, idempotency_key=ikey, s=s)
        r = httpx.post(_carmarket_url("/inquiries"), json=body, headers=headers, timeout=10)
        return r.json() if r.headers.get("content-type", "").startswith("application/json") else {"raw": r.text, "status_code": r.status_code}
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/payments/alias/verify")
async def payments_alias_verify(req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                req_model = _PayAliasVerifyReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            try:
                with _pay_internal_session() as s:
                    return _pay_alias_verify(req_model, s=s)
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(status_code=502, detail=str(e))
        r = httpx.post(
            _payments_url("/alias/verify"),
            json=body,
            headers=_payments_headers(),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/payments/alias/resolve/{handle}")
def payments_alias_resolve(handle: str):
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            try:
                with _pay_internal_session() as s:
                    return _pay_alias_resolve(handle=handle, s=s)
            except HTTPException:
                raise
            except Exception as e:
                raise HTTPException(status_code=502, detail=str(e))
        r = httpx.get(
            _payments_url(f"/alias/resolve/{handle}"),
            headers=_payments_headers(),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


# ---- Admin alias moderation proxies ----
@app.post("/payments/admin/alias/block")
async def payments_admin_alias_block(req: Request):
    _require_superadmin(req)
    if not PAYMENTS_INTERNAL_SECRET:
        raise HTTPException(status_code=403, detail="Server not configured for admin alias")
    try:
        body = await req.json()
    except Exception:
        body = None
    headers = {"X-Internal-Secret": PAYMENTS_INTERNAL_SECRET}
    try:
        r = httpx.post(
            _payments_url("/admin/alias/block"),
            json=body,
            headers=_payments_headers(headers),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/payments/admin/alias/rename")
async def payments_admin_alias_rename(req: Request):
    _require_superadmin(req)
    if not PAYMENTS_INTERNAL_SECRET:
        raise HTTPException(status_code=403, detail="Server not configured for admin alias")
    try:
        body = await req.json()
    except Exception:
        body = None
    headers = {"X-Internal-Secret": PAYMENTS_INTERNAL_SECRET}
    try:
        r = httpx.post(
            _payments_url("/admin/alias/rename"),
            json=body,
            headers=_payments_headers(headers),
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/payments/admin/alias/search")
def payments_admin_alias_search(request: Request, handle: str = "", status: str = "", user_id: str = "", limit: int = 50):
    _require_superadmin(request)
    if not PAYMENTS_INTERNAL_SECRET:
        raise HTTPException(status_code=403, detail="Server not configured for admin alias")
    headers = {"X-Internal-Secret": PAYMENTS_INTERNAL_SECRET}
    params = {}
    if handle:
        params["handle"] = handle
    if status:
        params["status"] = status
    if user_id:
        params["user_id"] = user_id
    params["limit"] = limit
    try:
        r = httpx.get(
            _payments_url("/admin/alias/search"),
            headers=_payments_headers(headers),
            params=params,
            timeout=10,
        )
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


# ---- Admin risk proxies ----
@app.get("/payments/admin/risk/metrics")
def payments_admin_risk_metrics(request: Request, minutes: int = 5, top: int = 10):
    _require_superadmin(request)
    if not PAYMENTS_INTERNAL_SECRET:
        raise HTTPException(status_code=403, detail="Server not configured for admin risk")
    headers = {"X-Internal-Secret": PAYMENTS_INTERNAL_SECRET}
    params = {"minutes": minutes, "top": top}
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            with _pay_internal_session() as s:
                result = _pay_admin_risk_metrics(minutes=minutes, top=top, s=s, admin_ok=True)
        else:
            r = httpx.get(
                _payments_url("/admin/risk/metrics"),
                headers=_payments_headers(headers),
                params=params,
                timeout=10,
            )
            result = r.json()
        _audit_from_request(request, "risk_metrics", minutes=minutes, top=top)
        return result
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


# ---- Payments merchant export proxy ----
@app.get("/payments/admin/export/merchant")
def payments_admin_export_merchant(request: Request, merchant: str, from_iso: str = "", to_iso: str = ""):
    _require_admin_v2(request)
    if not PAYMENTS_INTERNAL_SECRET:
        raise HTTPException(status_code=403, detail="Server not configured for admin export")
    headers = {"X-Internal-Secret": PAYMENTS_INTERNAL_SECRET}
    params = {"merchant": merchant}
    if from_iso:
        params["from_iso"] = from_iso
    if to_iso:
        params["to_iso"] = to_iso
    try:
        _audit_from_request(request, "export_merchant_txns", merchant=merchant, from_iso=from_iso or None, to_iso=to_iso or None)
        with httpx.stream(
            "GET",
            _payments_url("/admin/txns/export_by_merchant"),
            headers=_payments_headers(headers),
            params=params,
            timeout=None,
        ) as r:
            disp = r.headers.get("content-disposition", f"attachment; filename=txns_{merchant}.csv")
            return StreamingResponse(r.iter_bytes(), media_type="text/csv", headers={"Content-Disposition": disp})
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/payments/admin/risk/events")
def payments_admin_risk_events(request: Request, minutes: int = 5, to_wallet_id: str = "", device_id: str = "", ip: str = "", limit: int = 100):
    _require_superadmin(request)
    if not PAYMENTS_INTERNAL_SECRET:
        raise HTTPException(status_code=403, detail="Server not configured for admin risk")
    headers = {"X-Internal-Secret": PAYMENTS_INTERNAL_SECRET}
    params = {"minutes": minutes, "limit": limit}
    if to_wallet_id:
        params["to_wallet_id"] = to_wallet_id
    if device_id:
        params["device_id"] = device_id
    if ip:
        params["ip"] = ip
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            with _pay_internal_session() as s:
                result = _pay_admin_risk_events(minutes=minutes, to_wallet_id=to_wallet_id or None, device_id=device_id or None, ip=ip or None, limit=limit, s=s, admin_ok=True)
        else:
            r = httpx.get(
                _payments_url("/admin/risk/events"),
                headers=_payments_headers(headers),
                params=params,
                timeout=10,
            )
            result = r.json()
        _audit_from_request(
            request,
            "risk_events",
            minutes=minutes,
            to_wallet_id=to_wallet_id or None,
            device_id=device_id or None,
            ip=ip or None,
            limit=limit,
        )
        return result
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/payments/admin/risk/deny/add")
async def payments_admin_risk_deny_add(req: Request):
    _require_superadmin(req)
    if not PAYMENTS_INTERNAL_SECRET:
        raise HTTPException(status_code=403, detail="Server not configured for admin risk")
    try:
        body = await req.json()
    except Exception:
        body = None
    headers = {"X-Internal-Secret": PAYMENTS_INTERNAL_SECRET}
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                rreq = _PayRiskDenyReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _pay_internal_session() as s:
                result = _pay_admin_risk_deny_add(rreq, s=s, admin_ok=True)
        else:
            r = httpx.post(
                _payments_url("/admin/risk/deny/add"),
                json=body,
                headers=_payments_headers(headers),
                timeout=10,
            )
            result = r.json()
        kind = ""
        value = ""
        try:
            if isinstance(body, dict):
                kind = (body.get("kind") or "").strip()
                value = (body.get("value") or "").strip()
        except Exception:
            pass
        _audit_from_request(req, "risk_deny_add", kind=kind, value=value)
        return result
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/payments/admin/risk/deny/remove")
async def payments_admin_risk_deny_remove(req: Request):
    _require_superadmin(req)
    if not PAYMENTS_INTERNAL_SECRET:
        raise HTTPException(status_code=403, detail="Server not configured for admin risk")
    try:
        body = await req.json()
    except Exception:
        body = None
    headers = {"X-Internal-Secret": PAYMENTS_INTERNAL_SECRET}
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                rreq = _PayRiskDenyReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _pay_internal_session() as s:
                result = _pay_admin_risk_deny_remove(rreq, s=s, admin_ok=True)
        else:
            r = httpx.post(
                _payments_url("/admin/risk/deny/remove"),
                json=body,
                headers=_payments_headers(headers),
                timeout=10,
            )
            result = r.json()
        kind = ""
        value = ""
        try:
            if isinstance(body, dict):
                kind = (body.get("kind") or "").strip()
                value = (body.get("value") or "").strip()
        except Exception:
            pass
        _audit_from_request(req, "risk_deny_remove", kind=kind, value=value)
        return result
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/payments/admin/risk/deny/list")
def payments_admin_risk_deny_list(request: Request, kind: str = "", limit: int = 200):
    _require_superadmin(request)
    if not PAYMENTS_INTERNAL_SECRET:
        raise HTTPException(status_code=403, detail="Server not configured for admin risk")
    headers = {"X-Internal-Secret": PAYMENTS_INTERNAL_SECRET}
    params = {"limit": limit}
    if kind:
        params["kind"] = kind
    try:
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            with _pay_internal_session() as s:
                result = _pay_admin_risk_deny_list(kind=kind or None, limit=limit, s=s, admin_ok=True)
        else:
            r = httpx.get(
                _payments_url("/admin/risk/deny/list"),
                headers=_payments_headers(headers),
                params=params,
                timeout=10,
            )
            result = r.json()
        _audit_from_request(request, "risk_deny_list", kind=kind or None, limit=limit)
        return result
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/payments-debug", response_class=HTMLResponse)
def payments_debug_page():
    # Legacy Debug-UI – bitte Shamell bzw. API-Clients verwenden.
    return _legacy_console_removed_page("Shamell · Payments debug")
    # Simple in-page tool to create user, show wallet, topup (server) and transfer
    html = """
<!doctype html>
<html><head><meta name=viewport content="width=device-width, initial-scale=1" />
<title>Payments Debug</title>
<link rel="icon" href="/icons/payments.svg" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="default" />
<link rel="manifest" href="/payments-debug/manifest.json" />
<link rel="apple-touch-icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAQAAACqK7W/AAAAKUlEQVR42u3BAQ0AAADCoPdPbQ43oAAAAAAAAAAAAAAAAAAAAAAAPQkqtwAAbkQwXgAAAABJRU5ErkJggg==" />
<script src="/ds.js"></script>
<style>
  body{font-family:sans-serif;margin:20px;max-width:720px;background:#ffffff;color:#000000;}
  input,button{font-size:16px;padding:8px;margin:4px 0}
  code{background:#f5f5f5;padding:2px 4px;border-radius:4px}
  .btn{padding:8px 12px;border-radius:4px;border:1px solid #cccccc;background:#f3f4f6;color:#000000}
  .btnPri{padding:8px 12px;border-radius:4px;background:#2563eb;color:#ffffff;border:0}
  .card{border-radius:4px;border:1px solid #dddddd;padding:12px;background:#ffffff}
  .topbar{position:sticky;top:0;z-index:10;background:#ffffff;padding:8px 10px;border-bottom:1px solid #dddddd;margin:0 0 8px 0}
  .row{display:flex;align-items:center;gap:8px}
</style>
</head><body>
<div class="topbar row"><div style="flex:1;font-weight:600">Payments Debug</div><button id=db_refresh>Refresh Wallet</button></div>
<h1 style="display:none">Payments Debug</h1>
<p>Base: <code>/payments/*</code> via BFF</p>
<div id=dbg_flash style="position:fixed;inset:0;background:#e5e7eb;opacity:0;pointer-events:none;transition:opacity .2s;"></div>
<div class="card" data-ds="card">
  <h3>Create User</h3>
  <input id=phone placeholder="Phone e.g. +9637000000xx" />
  <button onclick="createUser()">Create/Fetch</button>
  <div id=user></div>
</div>
<div class="card" data-ds="card">
  <h3>Wallet</h3>
  <input id=wallet placeholder="Wallet ID" />
  <button onclick="getWallet()">Refresh</button>
  <div id=wout></div>
</div>
<div id=dbg_hero class="card" data-ds="card" style="display:none;border:0">
  <div style="display:flex;align-items:center;gap:12px">
    <div style="padding:10px;border-radius:4px;border:1px solid #dddddd">Wallet</div>
    <div style="flex:1">
      <div style="opacity:.9;font-size:13px">Wallet</div>
      <div id=dh_wallet style="font-weight:600;overflow:hidden;text-overflow:ellipsis;white-space:nowrap"></div>
    </div>
    <div style="text-align:right">
      <div style="opacity:.9;font-size:13px">Saldo</div>
      <div id=dh_balance style="font-weight:700;font-size:18px">—</div>
      <div id=dh_kyc style="opacity:.9;font-size:12px"></div>
    </div>
    <button onclick="getWallet()" style="margin-left:8px;padding:6px 10px;border-radius:4px;border:1px solid #cccccc;background:#f3f4f6">Refresh</button>
  </div>
  
</div>
<div class="card" data-ds="card">
  <h3>Admin Topup (server)</h3>
  <input id=amt value=100000 />
  <button onclick="topup()">Topup</button>
  <div id=topout></div>
</div>
<div class="card" data-ds="card">
  <h3>Transfer</h3>
  <input id=to placeholder="To wallet id or @alias" />
  <input id=tamt value=25000 />
  <button onclick="transfer()">Send</button>
  <div id=xout></div>
</div>
  <div class="card" data-ds="card">
    <h3>Quick Pay</h3>
    <input id=qp_to2 placeholder="To wallet id or @alias" />
    <input id=qp_amt2 type=number placeholder="Amount (cents)" />
    <button onclick="quickPayDbg()">Pay</button>
    <small>Alias supported (@name). Uses Idempotency-Key.</small>
    <div id=qp_out2></div>
  </div>
  <div class="card" data-ds="card">
    <h3>Scan to Pay</h3>
    <button onclick="scanStartPayDbg()">Scan PAY QR</button>
    <div id=scannerDbg style="width:260px;height:220px"></div>
  </div>
  <div class="card" data-ds="card">
    <h3>Alias QR</h3>
    <input id=aq_handle_dbg placeholder="@yourname" />
    <input id=aq_amount_dbg type=number placeholder="Amount (cents, optional)" />
    <button onclick="aliasQRDbg()">Generate Alias QR</button>
    <div id=aqr_dbg></div>
    <pre id=apayload_dbg></pre>
    <small>Format: ALIAS|name=@...|amount=...</small>
  </div>
<div class="card" data-ds="card">
  <h3>My QR</h3>
  <input id=qr_amt2 type=number placeholder="Amount (cents, optional)" />
  <button onclick="genMyQR()">Generate My QR</button>
  <div id=qr2></div>
  <pre id=qrp2></pre>
  <p><small>Scannable payload: PAY|wallet=&lt;wallet&gt;|amount=&lt;cents&gt;</small></p>
</div>
<div class="card" data-ds="card">
  <h3>Topup QR</h3>
  <p><small>Generate a QR for app Topup scan. Format: TOPUP|wallet=&lt;wallet&gt;|amount=&lt;cents&gt;.</small></p>
  <div class=row>
    <input id=t_wallet_dbg placeholder="Wallet (defaults to Wallet field above)" />
    <input id=t_amt_dbg type=number placeholder="Amount (cents)" />
    <button onclick="topupQRDbg()">Generate</button>
  </div>
  <div id=tqr_dbg></div>
  <pre id=tpayload_dbg></pre>
</div>
<div class="card" data-ds="card">
  <h3>Offline Queue</h3>
  <button onclick="syncQueued()">Sync Now</button>
  <pre id=qout></pre>
</div>
<hr/>
<div class="card" data-ds="card">
  <h2>Sonic‑Pay (Token)</h2>
  <h3>Payer: Issue Token</h3>
  <input id=sp_amt value=10000 />
  <button onclick="sonicIssue()">Issue</button>
  <pre id=sp_issue></pre>
  <h3>Payee: Redeem Token</h3>
  <input id=sp_token placeholder="paste token here" />
  <button onclick="sonicRedeem()">Redeem</button>
  <pre id=sp_redeem></pre>
  <p><small>Note: Token is HMAC-signed and short-lived; ideally it is transmitted acoustically/Bluetooth. For testing, copy/paste it here.</small></p>
  <script>
  async function sonicIssue(){
    const wid=document.getElementById('wallet').value;
    const amt=parseInt(document.getElementById('sp_amt').value||'0',10);
    const r=await fetch('/payments/sonic/issue',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({from_wallet_id:wid,amount_cents:amt})});
    const j=await r.json();
    document.getElementById('sp_issue').textContent=JSON.stringify(j,null,2);
    try{ await navigator.clipboard.writeText(j.token);}catch(e){}
  }
  async function sonicRedeem(){
    const tok=document.getElementById('sp_token').value.trim();
    const wid=document.getElementById('wallet').value;
    try{
      const r=await fetch('/payments/sonic/redeem',{method:'POST',headers:{'content-type':'application/json','Idempotency-Key':'srx-'+Date.now()},body:JSON.stringify({token:tok,to_wallet_id:wid})});
      const j=await r.json();
      document.getElementById('sp_redeem').textContent=JSON.stringify(j,null,2);
    }catch(e){document.getElementById('sp_redeem').textContent='Error '+e}
  }
  </script>
<script src="https://unpkg.com/html5-qrcode@2.3.10/html5-qrcode.min.js"></script>
<script>
  // Unify DS with /app glass tokens
  const DS = { btn: 'btn', btnPri: 'btnPri', card: 'card', input: 'input' };
  function applyDS(){
    try{ document.getElementById('db_refresh').className = DS.btnPri; }catch(_){ }
    document.querySelectorAll('[data-ds="card"]').forEach(el=> el.className = DS.card);
    document.querySelectorAll('input').forEach(el=> el.className = DS.input);
    document.querySelectorAll('button').forEach(el=>{ if(!el.className){ el.className=DS.btn; } });
  }
  // --- Ensure wallet helpers ---
  async function me_ensureWallet(){ try{
    const r = await fetch('/me/wallet'); const j = await r.json();
    if(j && j.wallet_id){
      try{ document.getElementById('me_wallet_chip').textContent = j.wallet_id; }catch(_){ }
      try{ const el=document.getElementById('me_wallet'); if(el){ el.value=j.wallet_id; } }catch(_){ }
      try{ const el2=document.getElementById('wh_wallet'); if(el2){ el2.textContent=j.wallet_id; document.getElementById('wallet_hero').classList.remove('hidden'); } }catch(_){ }
    }
  }catch(_){ }
  }
  function me_copyWallet(){ try{ const t=document.getElementById('me_wallet_chip').textContent||''; if(t && navigator.clipboard){ navigator.clipboard.writeText(t); } }catch(_){ }
  }
  document.addEventListener('DOMContentLoaded', ()=>{ try{ me_ensureWallet(); }catch(_){ } });
  document.addEventListener('DOMContentLoaded', applyDS);
  function heroGradient(kyc){ if(kyc==='pro') return 'linear-gradient(90deg,#7c3aed,#fbbf24)'; if(kyc==='plus') return 'linear-gradient(90deg,#3b82f6,#22c55e)'; return 'linear-gradient(90deg,#4f46e5,#60a5fa)'; }
  async function scanStartPayDbg(){
    try{
      const el = document.getElementById('scannerDbg');
      const html5QrCode = new Html5Qrcode(el.id);
      await html5QrCode.start({ facingMode: "environment" }, { fps: 10, qrbox: 200 }, (decodedText)=>{
        try{
          if(decodedText && (decodedText.startsWith('PAY|') || decodedText.startsWith('ALIAS|'))){
            const parts = decodedText.split('|');
            const map={}; for(const p of parts.slice(1)){ const kv=p.split('='); if(kv.length==2) map[kv[0]]=decodeURIComponent(kv[1]); }
            if(map['wallet']){ document.getElementById('qp_to2').value = map['wallet']; }
            if(map['name']){ document.getElementById('qp_to2').value = map['name']; }
            if(map['amount']){ document.getElementById('qp_amt2').value = map['amount']; }
            try{ if(navigator.vibrate) navigator.vibrate(20);}catch(e){}
            (function(){ const f=document.getElementById('dbg_flash'); if(f){ f.style.opacity='1'; setTimeout(()=>{ f.style.opacity='0'; }, 380);} })();
            html5QrCode.stop();
          }
        }catch(_){ }
      });
    }catch(e){ alert('scan error: '+e); }
  }
  </script>
</div>
<hr/>
<div>
  <h2>Favorites & Requests</h2>
  <div class="card">
    <h3>Favorites</h3>
    <div class=row>
      <input id=fv_to placeholder="favorite wallet id" />
      <input id=fv_alias placeholder="alias (optional)" />
      <button class="btnPri" onclick="fvAdd()">Add</button>
      <button class="btn" onclick="fvLoad()">Load</button>
    </div>
    <div id=fv_list_dbg></div>
  </div>
  <div class="card">
    <h3>Requests</h3>
    <div class=row>
      <input id=rq_to placeholder="Payer wallet id or @alias" />
      <input id=rq_amt type=number placeholder="Amount (cents)" />
      <button class="btnPri" onclick="rqCreate()">Request</button>
      <button class="btn" onclick="rqIncoming()">Incoming</button>
      <button class="btn" onclick="rqOutgoing()">Outgoing</button>
    </div>
    <div id=rq_out class="card" style="white-space:pre-wrap"></div>
  </div>
  <div class="card">
    <h3>Payments Roles (Admin)</h3>
    <div class=row>
      <input id=role_phone placeholder="+963..." />
      <select id=role_sel>
        <option value="merchant">merchant</option>
        <option value="qr_seller">qr_seller</option>
        <option value="cashout_operator">cashout_operator</option>
      </select>
      <button class="btnPri" onclick="roleAdd()">Add</button>
      <button class="btn" onclick="roleRemove()">Remove</button>
      <button class="btn" onclick="roleList()">List</button>
    </div>
    <div id=role_out class="card" style="white-space:pre-wrap"></div>
  </div>
</div>
<div>
  <h2>Alias‑Admin</h2>
  <h3>Blockieren</h3>
  <input id=ab_handle placeholder="@name" />
  <button onclick="ablock()">Block</button>
  <pre id=ab_out></pre>
  <h3>Umbenennen</h3>
  <input id=ar_from placeholder="@alt" /> → <input id=ar_to placeholder="@neu" />
  <button onclick="arename()">Rename</button>
  <pre id=ar_out></pre>
  <h3>Suchen</h3>
  <input id=as_handle placeholder="contains" /> Status: <input id=as_status placeholder="active/pending/blocked" />
  <button onclick="asearch()">Search</button>
  <pre id=as_out></pre>
  <script>
  async function ablock(){ const h=document.getElementById('ab_handle').value; const r=await fetch('/payments/admin/alias/block',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({handle:h})}); document.getElementById('ab_out').textContent=await r.text(); }
  async function arename(){ const f=document.getElementById('ar_from').value; const t=document.getElementById('ar_to').value; const r=await fetch('/payments/admin/alias/rename',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({from_handle:f,to_handle:t})}); document.getElementById('ar_out').textContent=await r.text(); }
  async function asearch(){ const h=document.getElementById('as_handle').value; const s=document.getElementById('as_status').value; const u=new URLSearchParams(); if(h)u.set('handle',h); if(s)u.set('status',s); const r=await fetch('/payments/admin/alias/search?'+u.toString()); document.getElementById('as_out').textContent=await r.text(); }
  </script>
</div>
<script>
if ('serviceWorker' in navigator) { try { navigator.serviceWorker.register('/payments-debug/sw.js'); } catch(e) {} }
function _queue(){ try{return JSON.parse(localStorage.getItem('offline_txns')||'[]')}catch(e){return []} }
function _hue2(s){ let h=0; for(let i=0;i<s.length;i++){ h=(h*31 + s.charCodeAt(i))&0xffffffff; } return Math.abs(h)%360; }
function avatar2(label){ const h=_hue2((label||'').replace('@','')); const c1=`hsl(${h} 90% 55%)`; const c2=`hsl(${(h+24)%360} 85% 65%)`; const init=((label||'').replace('@','')[0]||'?').toUpperCase(); return `<span style="display:inline-flex;align-items:center;justify-content:center;width:28px;height:28px;border-radius:9999px;background:linear-gradient(135deg, ${c1}, ${c2});color:#fff;font-weight:700;box-shadow:0 2px 6px rgba(0,0,0,.18)">${init}</span>`; }
function _saveQueue(q){ localStorage.setItem('offline_txns', JSON.stringify(q)); renderQueue(); }
function _genIKey(){ return 'sr-'+Date.now().toString(36)+'-'+Math.random().toString(36).slice(2,8) }
function _codeFromIKey(k){ const s=k.replace(/[^a-z0-9]/gi,'').slice(-6).toUpperCase(); return 'SR-'+s.slice(0,3)+'-'+s.slice(3) }
// Minimal QR (GIF data URL) generator
!function(o){function r(o){this.mode=n.MODE_8BIT_BYTE,this.data=o,this.parsedData=[];for(var r=0,l=this.data.length;r<l;r++){var t=[],h=this.data.charCodeAt(r);h>65536?(t[0]=240|(1835008&h)>>>18,t[1]=128|(258048&h)>>>12,t[2]=128|(4032&h)>>>6,t[3]=128|63&h):h>2048?(t[0]=224|(61440&h)>>>12,t[1]=128|(4032&h)>>>6,t[2]=128|63&h):h>128?(t[0]=192|(1984&h)>>>6,t[1]=128|63&h):t[0]=h,this.parsedData.push(t)}this.parsedData=Array.prototype.concat.apply([],this.parsedData),this.parsedData.length!=this.data.length&&(this.parsedData.unshift(191),this.parsedData.unshift(187),this.parsedData.unshift(239))}function l(o,r){this.typeNumber=o,this.errorCorrectLevel=r,this.modules=null,this.moduleCount=0,this.dataCache=null,this.dataList=[]}var n={PAD0:236,PAD1:17,MODE_8BIT_BYTE:4};r.prototype={getLength:function(){return this.parsedData.length},write:function(o){for(var r=0,l=this.parsedData.length;r<l;r++)o.put(this.parsedData[r],8)}},l.prototype={addData:function(o){this.dataList.push(new r(o)),this.dataCache=null},isDark:function(o,r){if(o<0||this.moduleCount<=o||r<0||this.moduleCount<=r)throw new Error(o+","+r);return this.modules[o][r]},getModuleCount:function(){return this.moduleCount},make:function(){this.makeImpl(!1,this.getBestMaskPattern())},makeImpl:function(o,r){this.moduleCount=21,this.modules=new Array(this.moduleCount);for(var l=0;l<this.moduleCount;l++){this.modules[l]=new Array(this.moduleCount);for(var n=0;n<this.moduleCount;n++)this.modules[l][n]=null}this.setupPositionProbePattern(0,0),this.setupPositionProbePattern(this.moduleCount-7,0),this.setupPositionProbePattern(0,this.moduleCount-7),this.mapData(this.createData(this.typeNumber,this.errorCorrectLevel,r),r)},setupPositionProbePattern:function(o,r){for(var l=-1;l<=7;l++)if(!(o+l<=-1||this.moduleCount<=o+l))for(var n=-1;n<=7;n++)r+n<=-1||this.moduleCount<=r+n||(this.modules[o+l][r+n]=l>=0&&l<=6&&(0==n||6==n)||n>=0&&n<=6&&(0==l||6==l)||l>=2&&l<=4&&n>=2&&n<=4)},getBestMaskPattern:function(){return 0},createData:function(o,r){for(var l=[],n=0;n<this.dataList.length;n++){var t=this.dataList[n];l.push(4),l.push(t.getLength()),l=l.concat(t.parsedData)}for(l.push(236),l.push(17),l.push(236),l.push(17);l.length<19;)l.push(0);return l.slice(0,19)},mapData:function(o,r){for(var l=0;l<this.moduleCount;l++)for(var n=0;n<this.moduleCount;n++)if(null===this.modules[l][n]){var t=!((l+n)%3);this.modules[l][n]=t}},createImgTag:function(o,r){o=o||2,r=r||0;var l=this.getModuleCount()*o+2*r,n=l,t='<img src="'+this.createDataURL(o,r)+'" width="'+l+'" height="'+n+'"/>';return t},createDataURL:function(o,r){o=o||2,r=r||0;var l=this.getModuleCount()*o+2*r,n=l,t=o,h=r,e=h,i=Math.round(255);for(var a="GIF89a",u=String.fromCharCode,d=a+u(0)+u(0)+u(0)+u(0)+"\x00\x00\xF7\x00\x00",s=0;s<16;s++){var c=s?0:i;d+=u(c)+u(c)+u(c)}d+="\x2C\x00\x00\x00\x00"+u(0)+u(0)+"\x00\x00\x00\x00\x02";for(var f=1;f<l;f++){var g="";for(var p=0;p<n;p++){var m=this.isDark(Math.floor((p-r)/o),Math.floor((f-h)/o))?0:1;g+=m?"\x01":"\x00"}d+=u(g.length)+g}return 'data:image/gif;base64,'+btoa(d)}};
function _makeQR2(text){ const qr = new l(1,0); qr.addData(text); qr.make(); const el=document.getElementById('qr2'); el.innerHTML=qr.createImgTag(4,2); }
function genMyQR(){ const w=document.getElementById('wallet').value.trim(); if(!w){ alert('Wallet required'); return; } const a=parseInt(document.getElementById('qr_amt2').value||'0',10); const p='PAY|wallet='+encodeURIComponent(w)+(a>0?('|amount='+a):''); document.getElementById('qrp2').textContent=p; _makeQR2(p); }
  async function createUser(){
  const phone = document.getElementById('phone').value;
  const r = await fetch('/payments/users', {method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({phone})});
  const j = await r.json();
  document.getElementById('user').textContent = JSON.stringify(j);
  if(j.wallet_id){ localStorage.setItem('wallet_id', j.wallet_id); document.getElementById('wallet').value = j.wallet_id; }
}
async function getWallet(){
  const wid = document.getElementById('wallet').value;
  const r = await fetch('/payments/wallets/'+wid);
  const j = await r.json();
  document.getElementById('wout').textContent = JSON.stringify(j);
  try{
    const k=(j.kyc_level||'').toLowerCase();
    const hero=document.getElementById('dbg_hero');
    if(wid){ hero.style.display='block'; document.getElementById('dh_wallet').textContent=wid; document.getElementById('dh_balance').textContent=(j.balance_cents||0)+' '+(j.currency||''); document.getElementById('dh_kyc').textContent='KYC: '+(k||'basic'); hero.style.background=heroGradient(k||'basic'); }
  }catch(_){ }
}
async function topup(){
  const wid = document.getElementById('wallet').value;
  const amt = parseInt(document.getElementById('amt').value||'0',10);
  const r = await fetch('/payments/wallets/'+wid+'/topup', {method:'POST', headers:{'content-type':'application/json','Idempotency-Key':'dbg-'+Date.now()}, body: JSON.stringify({amount_cents: amt})});
  const j = await r.json();
  document.getElementById('topout').textContent = JSON.stringify(j);
}
async function transfer(){
  const from = document.getElementById('wallet').value;
  const to = document.getElementById('to').value;
  const amt = parseInt(document.getElementById('tamt').value||'0',10);
  const ikey=_genIKey();
  const isAlias = (to||'').trim().startsWith('@');
  const payload = isAlias ? {from_wallet_id: from, to_alias: to.trim(), amount_cents: amt} : {from_wallet_id: from, to_wallet_id: to, amount_cents: amt};
  try{
    const r = await fetch('/payments/transfer', {method:'POST', headers:{'content-type':'application/json','Idempotency-Key':ikey}, body: JSON.stringify(payload)});
    if(!r.ok){ throw new Error('status '+r.status) }
    const j = await r.json();
    document.getElementById('xout').textContent = JSON.stringify(j);
  }catch(e){
    // offline fallback: queue
    const rec={ikey, code:_codeFromIKey(ikey), from_wallet_id:from, to_wallet_id:to, amount_cents:amt, created_at: new Date().toISOString()};
    const q=_queue(); q.push(rec); _saveQueue(q);
    document.getElementById('xout').textContent = 'Offline receipt code: '+rec.code+' (queued)';
    try{ navigator.share && navigator.share({text:'Payment '+rec.code+' '+amt+'c to '+to}); }catch(_){ }
  }
  async function resolveMaybe(v){ if(v&&v.startsWith('@')){ const r=await fetch('/payments/alias/resolve/'+encodeURIComponent(v)); const j=await r.json(); return j.wallet_id||null; } return v; }
  async function quickPayDbg(){ const from=gi('wallet'); let to=gi('qp_to2'); const amt=parseInt(document.getElementById('qp_amt2').value||'0',10); if(!from||!to||!(amt>0)){ alert('missing'); return; } const ik='dbg-'+Date.now().toString(36)+'-'+Math.random().toString(36).slice(2,6); const body=(to.startsWith('@')? {from_wallet_id:from,to_alias:to,amount_cents:amt}: {from_wallet_id:from,to_wallet_id:to,amount_cents:amt}); const r=await fetch('/payments/transfer',{method:'POST',headers:{'content-type':'application/json','Idempotency-Key':ik},body:JSON.stringify(body)}); document.getElementById('qp_out2').textContent=await r.text(); }
  function aliasQRDbg(){ const h=document.getElementById('aq_handle_dbg').value.trim(); const a=parseInt(document.getElementById('aq_amount_dbg').value||'0',10); if(!h||!h.startsWith('@')){ alert('alias must start with @'); return; } const p='ALIAS|name='+encodeURIComponent(h)+(a>0?('|amount='+a):''); document.getElementById('apayload_dbg').textContent=p; const el=document.getElementById('aqr_dbg'); const tmp=el.id; el.id='qr'; try{ makeQR(p); } finally { el.id=tmp; } }
async function fvAdd(){ const o=gi('wallet'); const to=gi('fv_to'); const alias=gi('fv_alias')||null; if(!o||!to){ alert('missing'); return; } const r=await fetch('/payments/favorites',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({owner_wallet_id:o,favorite_wallet_id:to,alias:alias})}); try{ await r.text(); }catch(_){ } await fvLoad(); }
async function fvLoad(){ const o=gi('wallet'); if(!o){ alert('wallet'); return; } const r=await fetch('/payments/favorites?owner_wallet_id='+encodeURIComponent(o)); const arr=await r.json(); const box=document.getElementById('fv_list_dbg'); box.innerHTML=''; for(const f of arr){ const label=(f.alias||''); const id=f.favorite_wallet_id; const row=document.createElement('div'); row.className='row'; row.innerHTML=avatar2(label||id)+`<div style="flex:1">${label||''}<div style="color:#6b7280;font-size:12px">${id}</div></div>`; const pay=document.createElement('button'); pay.className='btnPri'; pay.textContent='Pay'; pay.onclick=()=>{ document.getElementById('qp_to2').value = label||id; }; row.appendChild(pay); box.appendChild(row);} }
  async function rqCreate(){ const from=gi('wallet'); let to=gi('rq_to'); const amt=parseInt(document.getElementById('rq_amt').value||'0',10); to=await resolveMaybe(to); if(!from||!to||!(amt>0)){ alert('missing'); return; } const r=await fetch('/payments/requests',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({from_wallet_id:from,to_wallet_id:to,amount_cents:amt})}); document.getElementById('rq_out').textContent=await r.text(); }
  function avatar2(label){ const h=[...label].reduce((a,c)=>((a*31+c.charCodeAt(0))>>>0),0)%360; const c1=`hsl(${h} 90% 55%)`; const c2=`hsl(${(h+24)%360} 85% 65%)`; const init=(label.replace('@','')[0]||'?').toUpperCase(); return `<span style="display:inline-flex;align-items:center;justify-content:center;width:28px;height:28px;border-radius:9999px;background:linear-gradient(135deg, ${c1}, ${c2});color:#fff;font-weight:700;box-shadow:0 2px 6px rgba(0,0,0,.18)">${init}</span>`; }
  function rqRender(arr, incoming){ const box=document.getElementById('rq_out'); box.innerHTML=''; for(const e of arr){ const from=e.from_wallet_id||''; const to=e.to_wallet_id||''; const who=incoming? from : to; const row=document.createElement('div'); row.style.display='flex'; row.style.alignItems='center'; row.style.gap='10px'; row.style.borderBottom='1px solid #e5e7eb'; row.style.padding='6px 0'; row.innerHTML=avatar2(who)+`<div style=\"flex:1\"><div style=\"font-weight:600\">${e.amount_cents||0} </div><div style=\"color:#6b7280;font-size:12px\">${incoming?'from ':'to '}${who}</div></div>`; if(incoming){ const a=document.createElement('button'); a.textContent='Pay'; a.className='btnPri'; a.onclick=async()=>{ await fetch('/payments/requests/'+e.id+'/accept',{method:'POST'}); rqIncoming(); }; const c=document.createElement('button'); c.textContent='Decline'; c.className='btn'; c.onclick=async()=>{ await fetch('/payments/requests/'+e.id+'/cancel',{method:'POST'}); rqIncoming(); }; row.appendChild(a); row.appendChild(c); } else { const c=document.createElement('button'); c.textContent='Cancel'; c.className='btn'; c.onclick=async()=>{ await fetch('/payments/requests/'+e.id+'/cancel',{method:'POST'}); rqOutgoing(); }; row.appendChild(c); } box.appendChild(row);} }
  async function rqIncoming(){ const w=gi('wallet'); const r=await fetch('/payments/requests?wallet_id='+encodeURIComponent(w)+'&kind=incoming'); const arr=await r.json(); rqRender(arr,true); }
  async function rqOutgoing(){ const w=gi('wallet'); const r=await fetch('/payments/requests?wallet_id='+encodeURIComponent(w)+'&kind=outgoing'); const arr=await r.json(); rqRender(arr,false); }
  async function roleAdd(){ try{ const ph=gi('role_phone').value.trim(); const ro=gi('role_sel').value; const r=await fetch('/admin/roles',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({phone:ph,role:ro})}); gi('role_out').textContent=await r.text(); }catch(e){ gi('role_out').textContent='Error '+e; } }
  async function roleRemove(){ try{ const ph=gi('role_phone').value.trim(); const ro=gi('role_sel').value; const r=await fetch('/admin/roles',{method:'DELETE',headers:{'content-type':'application/json'},body:JSON.stringify({phone:ph,role:ro})}); gi('role_out').textContent=await r.text(); }catch(e){ gi('role_out').textContent='Error '+e; } }
  async function roleList(){ try{ const ro=gi('role_sel').value; const r=await fetch('/admin/roles?role='+encodeURIComponent(ro)+'&limit=200'); gi('role_out').textContent=await r.text(); }catch(e){ gi('role_out').textContent='Error '+e; } }
}
async function refreshBal(){ const wid=_wid(); if(!wid){return;} const r=await fetch('/payments/wallets/'+wid); const j=await r.json(); document.getElementById('bal').textContent = JSON.stringify(j,null,2); try{ const hero=document.getElementById('mp_hero'); hero.style.display='block'; document.getElementById('mh_wallet').textContent=wid; document.getElementById('mh_balance').textContent=(j.balance_cents||0)+' '+(j.currency||''); }catch(_){ } }
async function syncQueued(){
  const q=_queue(); if(q.length===0){ document.getElementById('qout').textContent='No pending txns'; return; }
  const rem=[]; const results=[];
  for(const rec of q){
    try{
      const r=await fetch('/payments/transfer', {method:'POST', headers:{'content-type':'application/json','Idempotency-Key':rec.ikey}, body: JSON.stringify({from_wallet_id: rec.from_wallet_id, to_wallet_id: rec.to_wallet_id, amount_cents: rec.amount_cents})});
      if(r.ok){ results.push({code:rec.code, ok:true}); } else { results.push({code:rec.code, ok:false, status:r.status}); rem.push(rec); }
    }catch(err){ rem.push(rec); }
  }
  _saveQueue(rem);
  document.getElementById('qout').textContent = JSON.stringify({synced: results}, null, 2);
}
function renderQueue(){ const q=_queue(); document.getElementById('qout').textContent = JSON.stringify(q,null,2); }
window.addEventListener('online', ()=>{ try{syncQueued()}catch(e){} });
renderQueue();
// init
document.getElementById('wallet').value = localStorage.getItem('wallet_id')||'';
</script>
</body></html>
"""
    return HTMLResponse(content=html)


@app.get("/payments-social", response_class=HTMLResponse)
def payments_social_page(request: Request):
    if not _auth_phone(request):
        return RedirectResponse(url="/login", status_code=303)
    return _legacy_console_removed_page("Shamell · Payments")
    html = """
<!doctype html>
<html><head><meta name=viewport content="width=device-width, initial-scale=1" />
<title>Payments – Favorites & Requests</title>
<style>body{font-family:sans-serif;margin:20px;max-width:900px} input,button{font-size:14px;padding:6px;margin:4px 0} table{border-collapse:collapse;width:100%} th,td{border:1px solid #ddd;padding:6px} pre{background:#f4f4f4;padding:8px;white-space:pre-wrap} small{color:#666}</style>
</head><body>
<h1>Favorites & Requests</h1>

<section>
  <h2>My Wallet</h2>
  <input id=me placeholder="my wallet id" />
  <button onclick="saveMe()">Save</button>
  <small id=mes></small>
</section>

<section>
  <h2>Favorites</h2>
  <div>
    <input id=fav_to placeholder="favorite wallet id" />
    <input id=fav_alias placeholder="alias (optional)" />
    <button onclick="addFav()">Add Favorite</button>
  </div>
  <table id=favs><thead><tr><th>Alias</th><th>Wallet</th><th>Actions</th></tr></thead><tbody></tbody></table>
</section>

<section>
  <h2>Quick Pay</h2>
  <div>
    <input id=qp_to placeholder="To wallet id or @alias" />
    <input id=qp_amt type=number placeholder="Amount (cents)" />
    <button onclick="quickPay()">Pay</button>
    <button onclick="scanStartPay()">Scan PAY QR</button>
  </div>
  <small>Uses /payments/transfer with Idempotency-Key and alias support.</small>
  <div>
    <h3>Recent</h3>
    <div id=qp_recent></div>
  </div>
  <div id=scanner2 style="width:260px;height:220px"></div>
</section>

<section>
  <h2>Request Money</h2>
  <div>
    <label>From (requester) = Me</label>
    <input id=req_to placeholder="Payer wallet id" />
    <input id=req_amt type=number placeholder="Amount (cents)" />
    <input id=req_msg placeholder="Message (optional)" />
    <button onclick="createReq()">Request</button>
  </div>
  <div>
    <h3>Incoming</h3>
    <table id=incoming><thead><tr><th>ID</th><th>From</th><th>Amount</th><th>Status</th><th>Actions</th></tr></thead><tbody></tbody></table>
  </div>
  <div>
    <h3>Outgoing</h3>
    <table id=outgoing><thead><tr><th>ID</th><th>To</th><th>Amount</th><th>Status</th><th>Actions</th></tr></thead><tbody></tbody></table>
  </div>
</section>

<section>
  <h2>Alias</h2>
  <div>
    <input id=al_handle placeholder="@yourname" />
    <button onclick="alRequest()">Request Link</button>
    <input id=al_code placeholder="123456" />
    <button onclick="alVerify()">Verify</button>
    <button onclick="alResolve()">Resolve</button>
    <pre id=al_out></pre>
  </div>
</section>

<section>
  <h2>Split Bill</h2>
  <p><small>Creates requests from Me (payee) to each participant (payer) with equal shares.</small></p>
  <div>
    <input id=sb_total type=number placeholder="Total amount (cents)" />
  </div>
  <div>
    <textarea id=sb_participants placeholder="Participant wallet IDs (comma or newline separated)" style="width:100%;height:80px"></textarea>
  </div>
  <button onclick="splitBill()">Create Requests</button>
  <pre id=sb_out></pre>
</section>

  <section>
    <h2>My QR</h2>
    <div>
      <input id=qr_amt type=number placeholder="Amount (cents, optional)" />
      <button onclick="genQR()">Generate QR</button>
      <div id=qr></div>
      <pre id=qrp></pre>
      <small>Scannable payload: PAY|wallet=&lt;me&gt;|amount=&lt;cents&gt;</small>
    </div>
  </section>

  <section>
    <h2>Alias QR</h2>
    <div>
      <input id=aq_handle placeholder="@yourname" />
      <input id=aq_amount type=number placeholder="Amount (cents, optional)" />
      <button onclick="aliasQRSocial()">Generate Alias QR</button>
      <div id=aqr></div>
      <pre id=apayload></pre>
      <small>Format: ALIAS|name=@...|amount=...</small>
    </div>
  </section>

<script src="https://unpkg.com/html5-qrcode@2.3.10/html5-qrcode.min.js"></script>
<script>
function saveMe(){ const v=gi('me'); localStorage.setItem('me_wallet', v); qs('#mes').textContent='saved'; loadFavs(); loadReqs(); }
function me(){ let v=gi('me'); if(!v){ v=localStorage.getItem('me_wallet')||''; si('me',v); } return v; }
function gi(id){ return (document.getElementById(id).value||'').trim(); }
function si(id,v){ document.getElementById(id).value=v; }
function qs(s){ return document.querySelector(s); }
function td(v){ const x=document.createElement('td'); x.textContent=v; return x; }

async function addFav(){ const o=me(); const to=gi('fav_to'); const alias=gi('fav_alias')||null; if(!o||!to){ alert('me and favorite required'); return; }
  const r=await fetch('/payments/favorites',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({owner_wallet_id:o,favorite_wallet_id:to,alias:alias})});
  if(!r.ok){ alert('error adding favorite'); return; } loadFavs(); }

async function delFav(id){ await fetch('/payments/favorites/'+id,{method:'DELETE'}); loadFavs(); }

async function loadFavs(){ const o=me(); if(!o){ return; } const r=await fetch('/payments/favorites?owner_wallet_id='+encodeURIComponent(o)); const arr=await r.json(); const tb=document.querySelector('#favs tbody'); tb.innerHTML=''; for(const f of arr){ const tr=document.createElement('tr'); tr.appendChild(td(f.alias||'')); tr.appendChild(td(f.favorite_wallet_id)); const act=document.createElement('td'); act.innerHTML='<button onclick="payFav(\''+(f.alias?f.alias:(''+f.favorite_wallet_id))+'\')">Pay</button> <button onclick="delFav(\''+f.id+'\')">Delete</button>'; tr.appendChild(act); tb.appendChild(tr);} }

function _recent(){ try{ return JSON.parse(localStorage.getItem('recent_payees')||'[]'); }catch(e){ return []; } }
function _saveRecent(list){ localStorage.setItem('recent_payees', JSON.stringify(list)); renderRecent(); }
function addRecent(target){ if(!target) return; const list=_recent().filter(x=>x!==target); list.unshift(target); while(list.length>5) list.pop(); _saveRecent(list); }
function renderRecent(){ const list=_recent(); const el=document.getElementById('qp_recent'); if(!el) return; if(list.length===0){ el.textContent='(none)'; return; } el.innerHTML=''; for(const t of list){ const b=document.createElement('button'); b.textContent=t; b.onclick=()=>{ document.getElementById('qp_to').value=t; }; el.appendChild(b); el.appendChild(document.createTextNode(' ')); } }

async function payFav(target){ const from=me(); if(!from){ alert('save my wallet first'); return; } let amt=parseInt(prompt('Amount (cents):','1000')||'0',10); if(!(amt>0)){ return; } const ik='pv-'+Date.now().toString(36)+'-'+Math.random().toString(36).slice(2,6); let body; if(target.startsWith('@')){ body={from_wallet_id:from,to_alias:target,amount_cents:amt}; } else { body={from_wallet_id:from,to_wallet_id:target,amount_cents:amt}; } const r=await fetch('/payments/transfer',{method:'POST',headers:{'content-type':'application/json','Idempotency-Key':ik},body:JSON.stringify(body)}); if(!r.ok){ alert('pay failed'); } else { addRecent(target); alert('paid'); }
}

async function quickPay(){ const from=me(); const to=gi('qp_to'); const amt=parseInt(gi('qp_amt')||'0',10); if(!from||!to||(amt<=0)){ alert('fields missing'); return; } const ik='qp-'+Date.now().toString(36)+'-'+Math.random().toString(36).slice(2,6); const body=(to.startsWith('@')? {from_wallet_id:from,to_alias:to,amount_cents:amt}: {from_wallet_id:from,to_wallet_id:to,amount_cents:amt}); const r=await fetch('/payments/transfer',{method:'POST',headers:{'content-type':'application/json','Idempotency-Key':ik},body:JSON.stringify(body)}); if(!r.ok){ alert('pay failed'); } else { addRecent(to); alert('paid'); }
}

async function resolveAliasMaybe(v){ if(v && v.startsWith('@')){ const h=v; const r=await fetch('/payments/alias/resolve/'+encodeURIComponent(h)); const j=await r.json(); return j.wallet_id||null; } return v; }
async function createReq(){ const from=me(); let to=gi('req_to'); const amt=parseInt(gi('req_amt')||'0',10); const message=gi('req_msg')||null; if(!from||!to||amt<=0){ alert('fields missing'); return; } to = await resolveAliasMaybe(to); if(!to){ alert('could not resolve recipient'); return; } const body={from_wallet_id:from,to_wallet_id:to,amount_cents:amt,message:message}; const r=await fetch('/payments/requests',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); if(!r.ok){ alert('error'); return; } loadReqs(); }
async function loadReqs(){ const w=me(); if(!w){ return; }
  const inc=await (await fetch('/payments/requests?wallet_id='+encodeURIComponent(w)+'&kind=incoming')).json();
  const out=await (await fetch('/payments/requests?wallet_id='+encodeURIComponent(w)+'&kind=outgoing')).json();
  const tin=document.querySelector('#incoming tbody'); tin.innerHTML='';
  for(const r of inc){ const tr=document.createElement('tr'); tr.appendChild(td(r.id)); tr.appendChild(td(r.from_wallet_id)); tr.appendChild(td(r.amount_cents)); tr.appendChild(td(r.status)); const act=document.createElement('td'); act.innerHTML='<button onclick="acc(\''+r.id+'\')">Pay</button> <button onclick="can(\''+r.id+'\')">Decline</button>'; tr.appendChild(act); tin.appendChild(tr); }
  const tout=document.querySelector('#outgoing tbody'); tout.innerHTML='';
  for(const r of out){ const tr=document.createElement('tr'); tr.appendChild(td(r.id)); tr.appendChild(td(r.to_wallet_id)); tr.appendChild(td(r.amount_cents)); tr.appendChild(td(r.status)); const act=document.createElement('td'); act.innerHTML='<button onclick="can(\''+r.id+'\')">Cancel</button>'; tr.appendChild(act); tout.appendChild(tr); }
}
async function acc(id){ const r=await fetch('/payments/requests/'+id+'/accept',{method:'POST'}); if(!r.ok){ alert('accept failed'); } loadReqs(); }
async function can(id){ const r=await fetch('/payments/requests/'+id+'/cancel',{method:'POST'}); if(!r.ok){ alert('cancel failed'); } loadReqs(); }

async function splitBill(){
  const from=me(); const total=parseInt(gi('sb_total')||'0',10); const list=(document.getElementById('sb_participants').value||'').split(/[\n,]+/).map(x=>x.trim()).filter(x=>x);
  if(!from||!(total>0)||list.length===0){ alert('fill all fields'); return; }
  const n=list.length; const base=Math.floor(total/n); let rem=total - base*n; const created=[];
  for(let i=0;i<n;i++){
    let to=list[i]; const amt=base + (rem>0?1:0); if(rem>0) rem--; const toWallet = await resolveAliasMaybe(to); if(!toWallet){ created.push({to, error:'resolve failed'}); continue; }
    const body={from_wallet_id:from,to_wallet_id:toWallet,amount_cents:amt,message:'split-bill'};
    const r=await fetch('/payments/requests',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)});
    const t=await r.text(); created.push({to, status:r.status, body:t});
  }
  document.getElementById('sb_out').textContent=JSON.stringify(created,null,2);
  loadReqs();
}

// Minimal QR generator (reuse from Merchant)
!function(o){function r(o){this.mode=n.MODE_8BIT_BYTE,this.data=o,this.parsedData=[];for(var r=0,l=this.data.length;r<l;r++){var t=[],h=this.data.charCodeAt(r);h>65536?(t[0]=240|(1835008&h)>>>18,t[1]=128|(258048&h)>>>12,t[2]=128|(4032&h)>>>6,t[3]=128|63&h):h>2048?(t[0]=224|(61440&h)>>>12,t[1]=128|(4032&h)>>>6,t[2]=128|63&h):h>128?(t[0]=192|(1984&h)>>>6,t[1]=128|63&h):t[0]=h,this.parsedData.push(t)}this.parsedData=Array.prototype.concat.apply([],this.parsedData),this.parsedData.length!=this.data.length&&(this.parsedData.unshift(191),this.parsedData.unshift(187),this.parsedData.unshift(239))}function l(o,r){this.typeNumber=o,this.errorCorrectLevel=r,this.modules=null,this.moduleCount=0,this.dataCache=null,this.dataList=[]}var n={PAD0:236,PAD1:17,MODE_8BIT_BYTE:4};r.prototype={getLength:function(){return this.parsedData.length},write:function(o){for(var r=0,l=this.parsedData.length;r<l;r++)o.put(this.parsedData[r],8)}},l.prototype={addData:function(o){this.dataList.push(new r(o)),this.dataCache=null},isDark:function(o,r){if(o<0||this.moduleCount<=o||r<0||this.moduleCount<=r)throw new Error(o+","+r);return this.modules[o][r]},getModuleCount:function(){return this.moduleCount},make:function(){this.makeImpl(!1,this.getBestMaskPattern())},makeImpl:function(o,r){this.moduleCount=21,this.modules=new Array(this.moduleCount);for(var l=0;l<this.moduleCount;l++){this.modules[l]=new Array(this.moduleCount);for(var n=0;n<this.moduleCount;n++)this.modules[l][n]=null}this.setupPositionProbePattern(0,0),this.setupPositionProbePattern(this.moduleCount-7,0),this.setupPositionProbePattern(0,this.moduleCount-7),this.mapData(this.createData(this.typeNumber,this.errorCorrectLevel,r),r)},setupPositionProbePattern:function(o,r){for(var l=-1;l<=7;l++)if(!(o+l<=-1||this.moduleCount<=o+l))for(var n=-1;n<=7;n++)r+n<=-1||this.moduleCount<=r+n||(this.modules[o+l][r+n]=l>=0&&l<=6&&(0==n||6==n)||n>=0&&n<=6&&(0==l||6==l)||l>=2&&l<=4&&n>=2&&n<=4)},getBestMaskPattern:function(){return 0},createData:function(o,r){for(var l=[],n=0;n<this.dataList.length;n++){var t=this.dataList[n];l.push(4),l.push(t.getLength()),l=l.concat(t.parsedData)}for(l.push(236),l.push(17),l.push(236),l.push(17);l.length<19;)l.push(0);return l.slice(0,19)},mapData:function(o,r){for(var l=0;l<this.moduleCount;l++)for(var n=0;n<this.moduleCount;n++)if(null===this.modules[l][n]){var t=!((l+n)%3);this.modules[l][n]=t}},createImgTag:function(o,r){o=o||2,r=r||0;var l=this.getModuleCount()*o+2*r,n=l,t='<img src="'+this.createDataURL(o,r)+'" width="'+l+'" height="'+n+'"/>';return t},createDataURL:function(o,r){o=o||2,r=r||0;var l=this.getModuleCount()*o+2*r,n=l,t=o,h=r,e=h,i=Math.round(255);for(var a=\"GIF89a\",u=String.fromCharCode,d=a+u(0)+u(0)+u(0)+u(0)+\"\\x00\\x00\\xF7\\x00\\x00\",s=0;s<16;s++){var c=s?0:i;d+=u(c)+u(c)+u(c)}d+=\"\\x2C\\x00\\x00\\x00\\x00\"+u(0)+u(0)+\"\\x00\\x00\\x00\\x00\\x02\";for(var f=1;f<l;f++){var g=\"\";for(var p=0;p<n;p++){var m=this.isDark(Math.floor((p-r)/o),Math.floor((f-h)/o))?0:1;g+=m?\"\\x01\":\"\\x00\"}d+=u(g.length)+g}return 'data:image/gif;base64,'+btoa(d)}};
function makeQR(text){ const qr = new l(1,0); qr.addData(text); qr.make(); const el=document.getElementById('qr'); el.innerHTML=qr.createImgTag(4,2); }
function genQR(){ const w=me(); const a=parseInt(gi('qr_amt')||'0',10); if(!w){ alert('save my wallet first'); return; } const p='PAY|wallet='+encodeURIComponent(w)+(a>0?('|amount='+a):''); document.getElementById('qrp').textContent=p; makeQR(p); }
function aliasQRSocial(){ const h=gi('aq_handle'); const a=parseInt(gi('aq_amount')||'0',10); if(!h||!h.startsWith('@')){ alert('alias must start with @'); return; } const p='ALIAS|name='+encodeURIComponent(h)+(a>0?('|amount='+a):''); document.getElementById('apayload').textContent=p; const qrEl=document.getElementById('aqr'); const tmp=qrEl.id; qrEl.id='qr'; try{ makeQR(p); } finally { qrEl.id=tmp; } }
function topupQRDbg(){ const w=(document.getElementById('t_wallet_dbg').value||document.getElementById('wallet').value||'').trim(); const a=parseInt(document.getElementById('t_amt_dbg').value||'0',10); if(!w){ alert('wallet required'); return; } const p='TOPUP|wallet='+encodeURIComponent(w)+(a>0?('|amount='+a):''); document.getElementById('tpayload_dbg').textContent=p; const el=document.getElementById('tqr_dbg'); const tmp=el.id; el.id='qr'; try{ makeQR(p); } finally { el.id=tmp; } }

// init
si('me', localStorage.getItem('me_wallet')||''); loadFavs(); loadReqs(); renderRecent();

async function scanStartPay(){
  try{
    const el = document.getElementById('scanner2');
    const html5QrCode = new Html5Qrcode(el.id);
    await html5QrCode.start({ facingMode: "environment" }, { fps: 10, qrbox: 200 }, (decodedText)=>{
      try{
        if(decodedText && (decodedText.startsWith('PAY|') || decodedText.startsWith('ALIAS|'))){
          const parts = decodedText.split('|');
          const map={}; for(const p of parts.slice(1)){ const kv=p.split('='); if(kv.length==2) map[kv[0]]=decodeURIComponent(kv[1]); }
          if(map['wallet']){ document.getElementById('qp_to').value = map['wallet']; }
          if(map['name']){ document.getElementById('qp_to').value = map['name']; }
          if(map['amount']){ document.getElementById('qp_amt').value = map['amount']; }
          html5QrCode.stop();
        }
      }catch(_){ }
    });
  }catch(e){ alert('scan error: '+e); }
}

async function alRequest(){ const h=gi('al_handle'); const w=me(); if(!h||!w){ alert('handle and me required'); return; } const r=await fetch('/payments/alias/request',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({handle:h,wallet_id:w})}); document.getElementById('al_out').textContent=await r.text(); }
async function alVerify(){ const h=gi('al_handle'); const c=gi('al_code'); if(!h||!c){ alert('handle+code'); return; } const r=await fetch('/payments/alias/verify',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({handle:h,code:c})}); document.getElementById('al_out').textContent=await r.text(); }
async function alResolve(){ const h=gi('al_handle'); if(!h){ return; } const r=await fetch('/payments/alias/resolve/'+encodeURIComponent(h)); document.getElementById('al_out').textContent=await r.text(); }
</script>
</body></html>
"""
    return HTMLResponse(content=html)


@app.get("/payments-debug/manifest.json")
def payments_debug_manifest():
    manifest = {
        "name": "SuperApp Payments Debug",
        "short_name": "Payments",
        "start_url": "/payments-debug",
        "display": "standalone",
        "background_color": "#0f172a",
        "theme_color": "#0f172a",
        "icons": [
            {"src": "/icons/payments-192.png", "sizes": "192x192", "type": "image/png"},
            {"src": "/icons/payments-512.png", "sizes": "512x512", "type": "image/png"},
            {"src": "/icons/payments.svg", "sizes": "any", "type": "image/svg+xml"}
        ]
    }
    return JSONResponse(content=manifest)


@app.get("/payments-debug/sw.js")
def payments_debug_sw():
    js = """
    self.addEventListener('install', (event) => {
      self.skipWaiting();
    });
    self.addEventListener('activate', (event) => {
      event.waitUntil(self.clients.claim());
    });
    self.addEventListener('fetch', (event) => {
      return; // network-first
    });
    """
    return Response(content=js, media_type="application/javascript")


# --- PWA manifests for operator/stub modules ---
def _manifest_for(module: str, title: str, start_url: str):
    return {
        "name": f"SuperApp {title}",
        "short_name": title,
        "start_url": start_url,
        "display": "standalone",
        "background_color": "#0f172a",
        "theme_color": "#0f172a",
        "icons": [
            {"src": f"/icons/{module}-192.png", "sizes": "192x192", "type": "image/png"},
            {"src": f"/icons/{module}-512.png", "sizes": "512x512", "type": "image/png"},
            {"src": f"/icons/{module}.svg", "sizes": "any", "type": "image/svg+xml"},
        ],
    }


@app.get("/agriculture/manifest.json")
def agriculture_manifest():
    return JSONResponse(content=_manifest_for("agriculture", "Agriculture", "/agriculture"))


@app.get("/commerce/manifest.json")
def commerce_manifest():
    return JSONResponse(content=_manifest_for("commerce", "Commerce", "/commerce"))


@app.get("/doctors/manifest.json")
def doctors_manifest():
    return JSONResponse(content=_manifest_for("doctors", "Doctors", "/doctors"))


@app.get("/flights/manifest.json")
def flights_manifest():
    return JSONResponse(content=_manifest_for("flights", "Flights", "/flights"))


@app.get("/jobs/manifest.json")
def jobs_manifest():
    return JSONResponse(content=_manifest_for("jobs", "Jobs", "/jobs"))


@app.get("/livestock/manifest.json")
def livestock_manifest():
    return JSONResponse(content=_manifest_for("livestock", "Livestock", "/livestock"))


@app.get("/bus/manifest.json")
def bus_manifest():
    # Start to admin page by default
    return JSONResponse(content=_manifest_for("bus", "Bus", "/bus/admin"))


@app.get("/merchant", response_class=HTMLResponse)
def merchant_page(request: Request):
    if not _auth_phone(request):
        return RedirectResponse(url="/login", status_code=303)
    html = """
<!doctype html>
<html><head><meta name=viewport content="width=device-width, initial-scale=1" />
<title>Merchant POS</title>
<link rel="icon" href="/icons/merchant.svg" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="default" />
<link rel="manifest" href="/merchant/manifest.json" />
<script src="/ds.js"></script>
<style>
  body{font-family:sans-serif;margin:20px;max-width:720px;background:#ffffff;color:#000000;}
  input,button{font-size:16px;padding:8px;margin:4px 0}
  input{background:#ffffff;border:1px solid #cccccc;border-radius:4px;color:#000000}
  button{border:1px solid #cccccc;background:#f3f4f6;border-radius:4px;color:#000000;box-shadow:none}
  #qr{margin-top:10px}
  pre{background:rgba(255,255,255,.08);padding:8px;white-space:pre-wrap;border-radius:12px;border:1px solid rgba(255,255,255,.2);backdrop-filter:blur(10px)}
</style>
</head><body>
<h1>Merchant POS</h1>
<p>Generate a QR for customers to scan and pay.</p>
<div>
  <label>Wallet ID</label>
  <input id=wallet placeholder="wallet id" />
  <button onclick="saveWid()">Save</button>
</div>
<div id=mp_hero style="display:none;margin:12px 0;padding:14px;border-radius:4px;border:1px solid #dddddd">
  <div style="display:flex;align-items:center;gap:12px">
    <div style="padding:10px;border-radius:4px;border:1px solid #dddddd">Wallet</div>
    <div style="flex:1">
      <div style="opacity:.9;font-size:13px">Merchant Wallet</div>
      <div id=mh_wallet style="font-weight:600;overflow:hidden;text-overflow:ellipsis;white-space:nowrap"></div>
    </div>
    <div style="text-align:right">
      <div style="opacity:.9;font-size:13px">Saldo</div>
      <div id=mh_balance style="font-weight:700;font-size:18px">—</div>
    </div>
    <button onclick="refreshBal()" style="margin-left:8px;padding:6px 10px;border-radius:4px;border:1px solid #cccccc;background:#f3f4f6">Refresh</button>
  </div>
</div>
<hr/>
<div id=alias_pay_section>
  <h2>Alias‑Pay (@name)</h2>
  <h3>Alias reservieren</h3>
  <input id=a_handle placeholder="@deinname" />
  <button onclick="aliasRequest()">Anfordern</button>
  <pre id=a_req></pre>
  <h3>Alias verifizieren</h3>
  <input id=a_code placeholder="123456" />
  <button onclick="aliasVerify()">Verifizieren</button>
  <pre id=a_ver></pre>
  <script>
  async function aliasRequest(){
    const h=document.getElementById('a_handle').value;
    const wid=document.getElementById('wallet').value;
    const r=await fetch('/payments/alias/request',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({handle:h,wallet_id:wid})});
    const j=await r.json();
    document.getElementById('a_req').textContent=JSON.stringify(j,null,2);
  }
  async function aliasVerify(){
    const h=document.getElementById('a_handle').value;
    const c=document.getElementById('a_code').value;
    const r=await fetch('/payments/alias/verify',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({handle:h,code:c})});
    const j=await r.json();
    document.getElementById('a_ver').textContent=JSON.stringify(j,null,2);
  }
  </script>
</div>
<div>
  <label>Amount (cents)</label>
  <input id=amount value=25000 />
  <button onclick="genQR()">Generate QR</button>
  <div id=qr></div>
  <pre id=payload></pre>
</div>
<div id=alias_qr_section>
  <h2>Alias QR</h2>
  <label>@Alias</label>
  <input id=aq_handle placeholder="@kunde" />
  <label>Amount (cents)</label>
  <input id=aq_amount value=25000 />
  <button onclick="aliasQR()">Generate Alias QR</button>
  <div id=aqr></div>
  <pre id=apayload></pre>
  <p style="color:#666">Format: <code>ALIAS|name=@...|amount=...</code></p>
  <p style="color:#666">Clients can scan this to prefill a transfer to the alias.</p>
  <hr/>
</div>
<div>
  <h2>Scan to Pay</h2>
  <div id=mp_flash style="position:fixed;inset:0;background:#e5e7eb;opacity:0;pointer-events:none;transition:opacity .2s;"></div>
  <button onclick="scanStartMerch()">Scan PAY/ALIAS QR</button>
  <div id=scannerMerch style="width:260px;height:220px"></div>
  <pre id=scanout></pre>
</div>
<div>
  <h3>Balance</h3>
  <button onclick="refreshBal()">Refresh Balance</button>
  <pre id=bal></pre>
</div>
<div>
  <h3>Recent Transactions</h3>
  <button onclick="loadTxns()">Load</button>
  <pre id=txns></pre>
</div>
<div>
  <h3>Offline Codes (Verify Later)</h3>
  <input id=code placeholder="SR-ABC-123" />
  <button onclick="verifyCode()">Verify</button>
  <pre id=ver></pre>
</div>
<script>
function saveWid(){ const v = document.getElementById('wallet').value; localStorage.setItem('merchant_wid', v); }
function _wid(){ let v = document.getElementById('wallet').value; if(!v){ v = localStorage.getItem('merchant_wid')||''; document.getElementById('wallet').value = v; } return v; }
function genQR(){
  const wid=_wid(); const amt=parseInt(document.getElementById('amount').value||'0',10);
  if(!wid){ alert('wallet required'); return; }
  const p = 'PAY|wallet='+wid + (amt>0?('|amount='+amt):'');
  document.getElementById('payload').textContent = p;
  makeQR(p);
}
function aliasQR(){
  const handle=(document.getElementById('aq_handle').value||'').trim();
  const amt=parseInt(document.getElementById('aq_amount').value||'0',10);
  if(!handle || !handle.startsWith('@')){ alert('alias must start with @'); return; }
  const p = 'ALIAS|name='+encodeURIComponent(handle) + (amt>0?('|amount='+amt):'');
  document.getElementById('apayload').textContent = p;
  // render into separate container
  const qrEl=document.getElementById('aqr');
  // reuse makeQR by temporarily swapping target id
  const old = document.getElementById('qr');
  const tmpId = qrEl.id;
  qrEl.id = 'qr';
  try { makeQR(p); } finally { qrEl.id = tmpId; }
}
async function refreshBal(){ const wid=_wid(); if(!wid){return;} const r=await fetch('/payments/wallets/'+wid); const j=await r.json(); document.getElementById('bal').textContent = JSON.stringify(j,null,2); try{ const hero=document.getElementById('mp_hero'); hero.style.display='block'; document.getElementById('mh_wallet').textContent=wid; document.getElementById('mh_balance').textContent=(j.balance_cents||0)+' '+(j.currency||''); }catch(_){ } }
async function loadTxns(){ const wid=_wid(); if(!wid){return;} const r=await fetch('/payments/txns?wallet_id='+encodeURIComponent(wid)+'&limit=20'); const j=await r.json(); document.getElementById('txns').textContent = JSON.stringify(j,null,2); }
// Minimal QR generator (qrcode.js MIT - reduced)
/* eslint-disable */
!function(o){function r(o){this.mode=n.MODE_8BIT_BYTE,this.data=o,this.parsedData=[];for(var r=0,l=this.data.length;r<l;r++){var t=[],h=this.data.charCodeAt(r);h>65536?(t[0]=240|(1835008&h)>>>18,t[1]=128|(258048&h)>>>12,t[2]=128|(4032&h)>>>6,t[3]=128|63&h):h>2048?(t[0]=224|(61440&h)>>>12,t[1]=128|(4032&h)>>>6,t[2]=128|63&h):h>128?(t[0]=192|(1984&h)>>>6,t[1]=128|63&h):t[0]=h,this.parsedData.push(t)}this.parsedData=Array.prototype.concat.apply([],this.parsedData),this.parsedData.length!=this.data.length&&(this.parsedData.unshift(191),this.parsedData.unshift(187),this.parsedData.unshift(239))}function l(o,r){this.typeNumber=o,this.errorCorrectLevel=r,this.modules=null,this.moduleCount=0,this.dataCache=null,this.dataList=[]}var n={PAD0:236,PAD1:17,MODE_8BIT_BYTE:4};r.prototype={getLength:function(){return this.parsedData.length},write:function(o){for(var r=0,l=this.parsedData.length;r<l;r++)o.put(this.parsedData[r],8)}},l.prototype={addData:function(o){this.dataList.push(new r(o)),this.dataCache=null},isDark:function(o,r){if(o<0||this.moduleCount<=o||r<0||this.moduleCount<=r)throw new Error(o+","+r);return this.modules[o][r]},getModuleCount:function(){return this.moduleCount},make:function(){this.makeImpl(!1,this.getBestMaskPattern())},makeImpl:function(o,r){this.moduleCount=21,this.modules=new Array(this.moduleCount);for(var l=0;l<this.moduleCount;l++){this.modules[l]=new Array(this.moduleCount);for(var n=0;n<this.moduleCount;n++)this.modules[l][n]=null}this.setupPositionProbePattern(0,0),this.setupPositionProbePattern(this.moduleCount-7,0),this.setupPositionProbePattern(0,this.moduleCount-7),this.mapData(this.createData(this.typeNumber,this.errorCorrectLevel,r),r)},setupPositionProbePattern:function(o,r){for(var l=-1;l<=7;l++)if(!(o+l<=-1||this.moduleCount<=o+l))for(var n=-1;n<=7;n++)r+n<=-1||this.moduleCount<=r+n||(this.modules[o+l][r+n]=l>=0&&l<=6&&(0==n||6==n)||n>=0&&n<=6&&(0==l||6==l)||l>=2&&l<=4&&n>=2&&n<=4)},getBestMaskPattern:function(){return 0},createData:function(o,r){for(var l=[],n=0;n<this.dataList.length;n++){var t=this.dataList[n];l.push(4),l.push(t.getLength()),l=l.concat(t.parsedData)}for(l.push(236),l.push(17),l.push(236),l.push(17);l.length<19;)l.push(0);return l.slice(0,19)},mapData:function(o,r){for(var l=0;l<this.moduleCount;l++)for(var n=0;n<this.moduleCount;n++)if(null===this.modules[l][n]){var t=!((l+n)%3);this.modules[l][n]=t}},createImgTag:function(o,r){o=o||2,r=r||0;var l=this.getModuleCount()*o+2*r,n=l,t='<img src="'+this.createDataURL(o,r)+'" width="'+l+'" height="'+n+'"/>';return t},createDataURL:function(o,r){o=o||2,r=r||0;var l=this.getModuleCount()*o+2*r,n=l,t=o,h=r,e=h,i=Math.round(255);for(var a="GIF89a",u=String.fromCharCode,d=a+u(0)+u(0)+u(0)+u(0)+"\x00\x00\xF7\x00\x00",s=0;s<16;s++){var c=s?0:i;d+=u(c)+u(c)+u(c)}d+="\x2C\x00\x00\x00\x00"+u(0)+u(0)+"\x00\x00\x00\x00\x02";for(var f=1;f<l;f++){var g="";for(var p=0;p<n;p++){var m=this.isDark(Math.floor((p-r)/o),Math.floor((f-h)/o))?0:1;g+=m?"\x01":"\x00"}d+=u(g.length)+g}return 'data:image/gif;base64,'+btoa(d)}};
function makeQR(text){ const qr = new l(1,0); qr.addData(text); qr.make(); const el=document.getElementById('qr'); el.innerHTML=qr.createImgTag(4,2); }
document.getElementById('wallet').value = localStorage.getItem('merchant_wid')||'';
async function verifyCode(){
  const c=document.getElementById('code').value.trim();
  const ikey=c.replace(/[^a-z0-9]/gi,'');
  try{ const r=await fetch('/payments/idempotency/'+ikey); const j=await r.json(); document.getElementById('ver').textContent = JSON.stringify(j,null,2); }catch(e){ document.getElementById('ver').textContent='Error: '+e; }
}
</script>
<script src="https://unpkg.com/html5-qrcode@2.3.10/html5-qrcode.min.js"></script>
<script>
async function scanStartMerch(){
  try{
    const el = document.getElementById('scannerMerch');
    const html5QrCode = new Html5Qrcode(el.id);
    await html5QrCode.start({ facingMode: "environment" }, { fps: 10, qrbox: 200 }, (decodedText)=>{
      try{
        if(decodedText && (decodedText.startsWith('PAY|') || decodedText.startsWith('ALIAS|'))){
          const parts = decodedText.split('|');
          const map={}; for(const p of parts.slice(1)){ const kv=p.split('='); if(kv.length==2) map[kv[0]]=decodeURIComponent(kv[1]); }
          let info='';
          if(map['wallet']){ info+='wallet='+map['wallet']+'\n'; }
          if(map['name']){ info+='alias='+map['name']+'\n'; document.getElementById('aq_handle').value = map['name']; }
          if(map['amount']){ info+='amount='+map['amount']+'\n'; document.getElementById('amount').value = map['amount']; document.getElementById('aq_amount').value = map['amount']; }
          document.getElementById('scanout').textContent=info || decodedText;
          try{ if(navigator.vibrate) navigator.vibrate(20);}catch(e){}
          (function(){ const f=document.getElementById('mp_flash'); if(f){ f.style.opacity='1'; setTimeout(()=>{ f.style.opacity='0'; }, 380);} })();
          html5QrCode.stop();
        }
      }catch(_){ }
    });
  }catch(e){ alert('scan error: '+e); }
}
// Optional Alias toggle (default hidden unless ?alias=1)
(function(){ try{ const p=new URLSearchParams(location.search); const on=p.get('alias')==='1'; if(!on){ const a=document.getElementById('alias_pay_section'); if(a) a.style.display='none'; const b=document.getElementById('alias_qr_section'); if(b) b.style.display='none'; } }catch(_){ } })();
</script>
</body></html>
"""
    return HTMLResponse(content=html)


@app.get("/merchant/manifest.json")
def merchant_manifest():
    manifest = {
        "name": "SuperApp Merchant",
        "short_name": "Merchant",
        "start_url": "/merchant",
        "display": "standalone",
        "background_color": "#ffffff",
        "theme_color": "#111111",
        "icons": [
            {"src": "/icons/merchant-192.png", "sizes": "192x192", "type": "image/png"},
            {"src": "/icons/merchant-512.png", "sizes": "512x512", "type": "image/png"},
            {"src": "/icons/merchant.svg", "sizes": "any", "type": "image/svg+xml"}
        ]
    }
    return JSONResponse(content=manifest)


@app.get("/admin/risk", response_class=HTMLResponse)
def admin_risk_page(request: Request):
    if not _auth_phone(request):
        return RedirectResponse(url="/login", status_code=303)
    return _legacy_console_removed_page("Shamell · Risk admin")
    html = """
<!doctype html>
<html><head><meta name=viewport content="width=device-width, initial-scale=1" />
<title>Risk Admin</title>
<link rel="icon" href="/icons/payments.svg" />
<script src="/ds.js"></script>
<style>
  body{font-family:sans-serif;margin:20px;max-width:960px;background:#ffffff;color:#000000;}
  input,button,select{font-size:14px;padding:6px;margin:4px 0}
  pre{background:#f5f5f5;padding:8px;white-space:pre-wrap;border-radius:4px;border:1px solid #dddddd}
  .card{border-radius:4px;border:1px solid #dddddd;padding:12px;background:#ffffff}
  .topbar{position:sticky;top:0;z-index:10;background:#ffffff;padding:8px 10px;border-bottom:1px solid #dddddd;margin:0 0 8px 0}
</style>
</head><body>
<div class="topbar"><div style="display:flex;align-items:center;gap:8px"><div style="flex:1;font-weight:600">Risk Admin</div><button onclick="loadMetrics()" class="px-3 py-2 rounded bg-blue-600/90 text-white">Refresh</button></div></div>

<section class="card">
  <h2>Metrics</h2>
  <label>Minutes</label> <input id=m_minutes type=number value=5 />
  <label>Top</label> <input id=m_top type=number value=10 />
  <button onclick="loadMetrics()">Load</button>
  <pre id=m_out></pre>
</section>

<section class="card" style="margin-top:12px">
  <h2>Events</h2>
  <label>Minutes</label> <input id=e_minutes type=number value=5 />
  <label>To Wallet</label> <input id=e_to />
  <label>Device</label> <input id=e_dev />
  <label>IP</label> <input id=e_ip />
  <label>Limit</label> <input id=e_limit type=number value=100 />
  <button onclick="loadEvents()">Load</button>
  <pre id=e_out></pre>
</section>

<section class="card" style="margin-top:12px">
  <h2>Denylist</h2>
  <label>Kind</label>
  <select id=d_kind><option value="device">device</option><option value="ip">ip</option></select>
  <label>Value</label> <input id=d_val />
  <button onclick="denyAdd()">Add</button>
  <button onclick="denyRemove()">Remove</button>
  <button onclick="denyList()">List</button>
  <pre id=d_out></pre>
</section>

<script>
async function loadMetrics(){
  const u=new URLSearchParams({minutes:document.getElementById('m_minutes').value, top:document.getElementById('m_top').value});
  const r=await fetch('/payments/admin/risk/metrics?'+u.toString());
  document.getElementById('m_out').textContent = await r.text();
}
async function loadEvents(){
  const u=new URLSearchParams();
  const mins=document.getElementById('e_minutes').value; if(mins)u.set('minutes', mins);
  const to=document.getElementById('e_to').value; if(to)u.set('to_wallet_id', to);
  const dev=document.getElementById('e_dev').value; if(dev)u.set('device_id', dev);
  const ip=document.getElementById('e_ip').value; if(ip)u.set('ip', ip);
  const lim=document.getElementById('e_limit').value; if(lim)u.set('limit', lim);
  const r=await fetch('/payments/admin/risk/events?'+u.toString());
  document.getElementById('e_out').textContent = await r.text();
}
async function denyAdd(){
  const k=document.getElementById('d_kind').value; const v=document.getElementById('d_val').value;
  const r=await fetch('/payments/admin/risk/deny/add',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({kind:k,value:v})});
  document.getElementById('d_out').textContent = await r.text();
}
async function denyRemove(){
  const k=document.getElementById('d_kind').value; const v=document.getElementById('d_val').value;
  const r=await fetch('/payments/admin/risk/deny/remove',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({kind:k,value:v})});
  document.getElementById('d_out').textContent = await r.text();
}
async function denyList(){
  const k=document.getElementById('d_kind').value; const r=await fetch('/payments/admin/risk/deny/list?kind='+encodeURIComponent(k));
  document.getElementById('d_out').textContent = await r.text();
}
</script>
</body></html>
"""
    return HTMLResponse(content=html)


@app.get("/admin/exports", response_class=HTMLResponse)
def admin_exports_page(request: Request):
    if not _auth_phone(request):
        return RedirectResponse(url="/login", status_code=303)
    return _legacy_console_removed_page("Shamell · Admin exports")


@app.get("/carmarket", response_class=HTMLResponse)
def carmarket_page(request: Request):
    if not _auth_phone(request):
        return RedirectResponse(url="/login", status_code=303)
    html = """
<!doctype html>
<html><head><meta name=viewport content="width=device-width, initial-scale=1" />
<title>Carmarket</title>
<link rel="icon" href="/icons/carmarket.svg" />
<script src="/ds.js"></script>
<style>
  body{font-family:sans-serif;margin:20px;max-width:900px;background:#ffffff;color:#000000;}
  .card{border-radius:4px;border:1px solid #dddddd;padding:12px;background:#ffffff}
  .topbar{position:sticky;top:0;z-index:10;background:#ffffff;padding:8px 10px;border-bottom:1px solid #dddddd;margin:0 0 12px 0}
  table{border-collapse:collapse;width:100%}
  th,td{border:1px solid #dddddd;padding:6px}
</style>
</head><body>
<div class="topbar"><div style="display:flex;align-items:center;gap:8px"><div style="flex:1;font-weight:600">Carmarket</div><button onclick="loadList()" class="px-3 py-2 rounded bg-blue-600/90 text-white">Refresh</button></div></div>
<section class="card">
  <h2>Browse</h2>
  <div style="display:flex;gap:8px;flex-wrap:wrap">
    <input id=q placeholder="Search" class="px-3 py-2 rounded border border-gray-300" />
    <input id=city placeholder="City" class="px-3 py-2 rounded border border-gray-300" />
    <input id=make placeholder="Make" class="px-3 py-2 rounded border border-gray-300" />
    <button onclick="loadList()" class="px-3 py-2 rounded bg-blue-600 text-white">Search</button>
  </div>
  <table id=list><thead><tr><th>ID</th><th>Title</th><th>Price</th><th>City</th><th>Make</th><th>Actions</th></tr></thead><tbody></tbody></table>
</section>
<section class="card" style="margin-top:12px">
  <h2>Post Listing</h2>
  <div style="display:flex;gap:8px;flex-wrap:wrap">
    <input id=title placeholder="Title" class="px-3 py-2 rounded border border-gray-300" />
    <input id=price type=number placeholder="Price (cents)" class="px-3 py-2 rounded border border-gray-300" />
    <input id=pmake placeholder="Make" class="px-3 py-2 rounded border border-gray-300" />
    <input id=pmodel placeholder="Model" class="px-3 py-2 rounded border border-gray-300" />
    <input id=year type=number placeholder="Year" class="px-3 py-2 rounded border border-gray-300" />
    <input id=pcity placeholder="City" class="px-3 py-2 rounded border border-gray-300" />
    <input id=phone placeholder="Contact phone" class="px-3 py-2 rounded border border-gray-300" />
    <input id=desc placeholder="Description" class="px-3 py-2 rounded border border-gray-300" />
    <button onclick="postListing()" class="px-3 py-2 rounded bg-green-600 text-white">Create</button>
  </div>
  <pre id=post_out></pre>
</section>
<section class="card" style="margin-top:12px">
  <h2>Inquiry</h2>
  <div style="display:flex;gap:8px;flex-wrap:wrap">
    <input id=ilid type=number placeholder="Listing ID" class="px-3 py-2 rounded border border-gray-300" />
    <input id=iname placeholder="Your name" class="px-3 py-2 rounded border border-gray-300" />
    <input id=iphone placeholder="Phone" class="px-3 py-2 rounded border border-gray-300" />
    <input id=imsg placeholder="Message" class="px-3 py-2 rounded border border-gray-300" />
    <button onclick="postInquiry()" class="px-3 py-2 rounded bg-blue-600 text-white">Send</button>
  </div>
  <pre id=iout></pre>
</section>
<script>
async function loadList(){
  const u=new URLSearchParams(); const q=document.getElementById('q').value; if(q)u.set('q',q); const c=document.getElementById('city').value; if(c)u.set('city',c); const m=document.getElementById('make').value; if(m)u.set('make',m);
  const r=await fetch('/carmarket/listings?'+u.toString()); const arr=await r.json();
  const tb=document.querySelector('#list tbody'); tb.innerHTML='';
  for(const l of arr){
    const tr=document.createElement('tr');
    tr.innerHTML=`<td>${l.id}</td><td>${l.title}</td><td>${l.price_cents}</td><td>${l.city||''}</td><td>${l.make||''}</td><td><button onclick=del(${l.id})>Delete</button></td>`;
    tb.appendChild(tr);
  }
}
async function postListing(){
  const body={title:gi('title'), price_cents:pi('price'), make:gi('pmake')||null, model:gi('pmodel')||null, year:pi('year')||null, city:gi('pcity')||null, contact_phone:gi('phone')||null, description:gi('desc')||null};
  const r=await fetch('/carmarket/listings',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)});
  const j=await r.json(); document.getElementById('post_out').textContent=JSON.stringify(j,null,2); loadList();
}
async function del(id){ await fetch('/carmarket/listings/'+id,{method:'DELETE'}); loadList(); }
async function postInquiry(){
  const body={listing_id:pi('ilid'), name:gi('iname'), phone:gi('iphone')||null, message:gi('imsg')||null};
  const r=await fetch('/carmarket/inquiries',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); document.getElementById('iout').textContent=await r.text();
}
function gi(id){ return (document.getElementById(id).value||'').trim(); }
function pi(id){ const v=parseInt(document.getElementById(id).value||'0',10); return isNaN(v)?0:v; }
loadList();
</script>
</body></html>
"""
    return HTMLResponse(content=html)


@app.get("/carrental", response_class=HTMLResponse)
def carrental_page(request: Request):
    if not _auth_phone(request):
        return RedirectResponse(url="/login", status_code=303)
    html = """
<!doctype html>
<html><head><meta name=viewport content="width=device-width, initial-scale=1" />
<title>Car Rental</title>
<link rel="icon" href="/icons/carrental.svg" />
<script src="/ds.js"></script>
<style>
  body{font-family:sans-serif;margin:20px;max-width:960px;background:#ffffff;color:#000000;}
  .card{border-radius:4px;border:1px solid #dddddd;padding:12px;background:#ffffff}
  .topbar{position:sticky;top:0;z-index:10;background:#ffffff;padding:8px 10px;border-bottom:1px solid #dddddd;margin:0 0 12px 0}
  table{border-collapse:collapse;width:100%}
  th,td{border:1px solid #dddddd;padding:6px}
</style>
</head><body>
<div class="topbar"><div style="display:flex;align-items:center;gap:8px"><div style="flex:1;font-weight:600">Car Rental</div><button onclick="loadCars()" class="px-3 py-2 rounded bg-blue-600/90 text-white">Refresh</button></div></div>
<section class="card">
  <h2>Cars</h2>
  <div style="display:flex;gap:8px;flex-wrap:wrap">
    <input id=q placeholder="Search" class="px-3 py-2 rounded border border-gray-300" />
    <input id=city placeholder="City" class="px-3 py-2 rounded border border-gray-300" />
    <button onclick="loadCars()" class="px-3 py-2 rounded bg-blue-600 text-white">Search</button>
  </div>
  <table id=cars><thead><tr><th>ID</th><th>Title</th><th>Make</th><th>Year</th><th>Day/Hour</th><th>Owner Wallet</th></tr></thead><tbody></tbody></table>
</section>
<section class="card" style="margin-top:12px">
  <h2>Quote & Book</h2>
  <div style="display:flex;gap:8px;flex-wrap:wrap">
    <label>Car ID</label> <input id=carid class="px-3 py-2 rounded border border-gray-300" />
    <label>From (ISO)</label> <input id=from class="px-3 py-2 rounded border border-gray-300" />
    <label>To (ISO)</label> <input id=to class="px-3 py-2 rounded border border-gray-300" />
    <button onclick="quote()" class="px-3 py-2 rounded bg-blue-600 text-white">Quote</button>
  </div>
  <pre id=qout></pre>
  <h3>Book</h3>
  <div style="display:flex;gap:8px;flex-wrap:wrap">
    <input id=name placeholder="Your name" class="px-3 py-2 rounded border border-gray-300" />
    <input id=phone placeholder="Phone" class="px-3 py-2 rounded border border-gray-300" />
    <input id=rw placeholder="Renter wallet (optional)" class="px-3 py-2 rounded border border-gray-300" />
    <label><input type=checkbox id=confirm /> Pay now (confirm)</label>
    <button onclick="book()" class="px-3 py-2 rounded bg-green-600 text-white">Book</button>
  </div>
  <pre id=bout></pre>
</section>
<section>
  <h2>Booking status</h2>
  <input id=bid placeholder="booking_id" />
  <button onclick="bstatus()">Status</button>
  <button onclick="bcancel()">Cancel</button>
  <button onclick="bconfirm()">Confirm (pay)</button>
  <pre id=bstat></pre>
</section>
<section>
  <h2>Admin</h2>
  <div>
    <button onclick="loadCars()">Refresh Cars</button>
    <button onclick="dlex('cars')">Export Cars CSV</button>
  </div>
  <div>
    <button onclick="loadBookings()">Refresh Bookings</button>
    <select id=bst><option value="">any</option><option>requested</option><option>confirmed</option><option>canceled</option><option>completed</option></select>
    <button onclick="dlex('bookings')">Export Bookings CSV</button>
    <pre id=blist></pre>
  </div>
</section>
<script>
async function loadCars(){ const u=new URLSearchParams(); const q=document.getElementById('q').value; if(q)u.set('q',q); const c=document.getElementById('city').value; if(c)u.set('city',c); const r=await fetch('/carrental/cars?'+u.toString()); const arr=await r.json(); const tb=document.querySelector('#cars tbody'); tb.innerHTML=''; for(const x of arr){ const tr=document.createElement('tr'); tr.innerHTML = `<td>${x.id}</td><td>${x.title}</td><td>${x.make||''} ${x.model||''}</td><td>${x.year||''}</td><td>${x.price_per_day_cents||''}/${x.price_per_hour_cents||''}</td><td>${x.owner_wallet_id||''}</td>`; tb.appendChild(tr);} }
async function quote(){ const body={car_id:parseInt(document.getElementById('carid').value||'0',10), from_iso:document.getElementById('from').value, to_iso:document.getElementById('to').value}; const r=await fetch('/carrental/quote',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); document.getElementById('qout').textContent=await r.text(); }
async function book(){ const body={car_id:parseInt(document.getElementById('carid').value||'0',10), renter_name:document.getElementById('name').value, renter_phone:document.getElementById('phone').value, renter_wallet_id:document.getElementById('rw').value||null, from_iso:document.getElementById('from').value, to_iso:document.getElementById('to').value, confirm:document.getElementById('confirm').checked}; const r=await fetch('/carrental/book',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); document.getElementById('bout').textContent=await r.text(); try{ const j=await r.clone().json(); document.getElementById('bid').value=j.id; }catch(_){ } }
async function bstatus(){ const id=document.getElementById('bid').value; const r=await fetch('/carrental/bookings/'+id); document.getElementById('bstat').textContent=await r.text(); }
async function bcancel(){ const id=document.getElementById('bid').value; const r=await fetch('/carrental/bookings/'+id+'/cancel',{method:'POST'}); document.getElementById('bstat').textContent=await r.text(); }
async function bconfirm(){ const id=document.getElementById('bid').value; const r=await fetch('/carrental/bookings/'+id+'/confirm',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({confirm:true})}); document.getElementById('bstat').textContent=await r.text(); }
async function loadBookings(){ const st=document.getElementById('bst').value; const u=new URLSearchParams(); if(st)u.set('status',st); const r=await fetch('/carrental/bookings?'+u.toString()); document.getElementById('blist').textContent=await r.text(); }
function dlex(kind){ if(kind==='cars'){ window.location.href='/carrental/admin/cars/export'; } else { const st=document.getElementById('bst').value; window.location.href='/carrental/admin/bookings/export'+(st?('?status='+encodeURIComponent(st)):''); } }
loadCars();
</script>
</body></html>
"""
    return HTMLResponse(content=html)


@app.get("/food", response_class=HTMLResponse)
def food_page(request: Request):
    if not _auth_phone(request):
        return RedirectResponse(url="/login", status_code=303)
    html = """
<!doctype html>
<html><head><meta name=viewport content="width=device-width, initial-scale=1" />
<title>Food</title>
<link rel="icon" href="/icons/food.svg" />
<script src="/ds.js"></script>
<style>
  body{font-family:sans-serif;margin:20px;max-width:1000px;background:#ffffff;color:#000000;}
  .card{border-radius:4px;border:1px solid #dddddd;padding:12px;background:#ffffff}
  .topbar{position:sticky;top:0;z-index:10;background:#ffffff;padding:8px 10px;border-bottom:1px solid #dddddd;margin:0 0 12px 0}
  table{border-collapse:collapse;width:100%}
  th,td{border:1px solid #dddddd;padding:6px}
</style>
</head><body>
<div class="topbar"><div style="display:flex;align-items:center;gap:8px"><div style="flex:1;font-weight:600">Food Ordering</div><button onclick="loadRests()" class="px-3 py-2 rounded bg-blue-600/90 text-white">Refresh</button></div></div>
<section class="card">
  <h2>Restaurants</h2>
  <div style="display:flex;gap:8px;flex-wrap:wrap"><input id=frq placeholder="Search" class="px-3 py-2 rounded border border-gray-300" />
  <input id=frcity placeholder="City" class="px-3 py-2 rounded border border-gray-300" />
  <button onclick="loadRests()" class="px-3 py-2 rounded bg-blue-600 text-white">Search</button></div>
  <table id=rests><thead><tr><th>ID</th><th>Name</th><th>City</th><th>Owner Wallet</th><th>Menu</th></tr></thead><tbody></tbody></table>
</section>
<section class="card" style="margin-top:12px">
  <h2>Menu & Order</h2>
  <div style="display:flex;gap:8px;flex-wrap:wrap"><label>Restaurant</label> <input id=rid class="px-3 py-2 rounded border border-gray-300" />
  <button onclick="loadMenu()" class="px-3 py-2 rounded bg-blue-600 text-white">Load Menu</button></div>
  <table id=menu><thead><tr><th>ID</th><th>Name</th><th>Price</th><th>Qty</th></tr></thead><tbody></tbody></table>
  <div>
    <label>Customer</label> <input id=cname placeholder="Name" class="px-3 py-2 rounded border border-gray-300" /> <input id=cphone placeholder="Phone" class="px-3 py-2 rounded border border-gray-300" />
    <input id=wallet placeholder="Customer wallet (optional)" class="px-3 py-2 rounded border border-gray-300" />
    <label><input type=checkbox id=confirm /> Pay now (confirm)</label>
    <button onclick="placeOrder()" class="px-3 py-2 rounded bg-green-600 text-white">Place Order</button>
    <pre id=oout></pre>
  </div>
</section>
<section>
  <h2>Order status</h2>
  <input id=oid placeholder="order_id" />
  <button onclick="ostatus()">Status</button>
  <select id=st><option>accepted</option><option>preparing</option><option>ready</option><option>completed</option><option>canceled</option></select>
  <button onclick="oset()">Set</button>
  <pre id=os></pre>
</section>
<script>
async function loadRests(){ const u=new URLSearchParams(); const q=document.getElementById('frq').value; if(q)u.set('q',q); const c=document.getElementById('frcity').value; if(c)u.set('city',c); const r=await fetch('/food/restaurants?'+u.toString()); const arr=await r.json(); const tb=document.querySelector('#rests tbody'); tb.innerHTML=''; for(const x of arr){ const tr=document.createElement('tr'); tr.innerHTML = `<td>${x.id}</td><td>${x.name}</td><td>${x.city||''}</td><td>${x.owner_wallet_id||''}</td><td><button onclick=sel(${x.id})>Select</button></td>`; tb.appendChild(tr);} }
function sel(id){ document.getElementById('rid').value=id; loadMenu(); }
async function loadMenu(){ const rid=document.getElementById('rid').value; const r=await fetch('/food/restaurants/'+rid+'/menu'); const arr=await r.json(); const tb=document.querySelector('#menu tbody'); tb.innerHTML=''; for(const m of arr){ const tr=document.createElement('tr'); tr.innerHTML = `<td>${m.id}</td><td>${m.name}</td><td>${m.price_cents}</td><td><input id='q_${m.id}' value='1' /></td>`; tb.appendChild(tr);} }
async function placeOrder(){ const rid=parseInt(document.getElementById('rid').value||'0',10); const qs=Array.from(document.querySelectorAll('#menu tbody input')); const items=[]; for(const q of qs){ const id=parseInt(q.id.split('_')[1],10); const qty=parseInt(q.value||'0',10); if(qty>0) items.push({menu_item_id:id, qty:qty}); } if(items.length===0){ alert('choose items'); return; } const body={restaurant_id:rid, customer_name:document.getElementById('cname').value, customer_phone:document.getElementById('cphone').value, customer_wallet_id:document.getElementById('wallet').value||null, items, confirm:document.getElementById('confirm').checked}; const r=await fetch('/food/orders',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); const t=await r.text(); document.getElementById('oout').textContent=t; try{ const j=JSON.parse(t); document.getElementById('oid').value=j.id; }catch(_){} }
async function ostatus(){ const id=document.getElementById('oid').value; const r=await fetch('/food/orders/'+id); document.getElementById('os').textContent=await r.text(); }
async function oset(){ const id=document.getElementById('oid').value; const st=document.getElementById('st').value; const r=await fetch('/food/orders/'+id+'/status',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({status:st})}); document.getElementById('os').textContent=await r.text(); }
loadRests();
</script>
</body></html>
"""
    return HTMLResponse(content=html)


@app.get("/realestate", response_class=HTMLResponse)
def realestate_page(request: Request):
    if not _auth_phone(request):
        return RedirectResponse(url="/login", status_code=303)
    html = """
<!doctype html>
<html><head><meta name=viewport content="width=device-width, initial-scale=1" />
<title>RealEstate</title>
<link rel="icon" href="/icons/realestate.svg" />
<style>
  body{font-family:sans-serif;margin:20px;max-width:1100px;background:#ffffff;color:#000000;}
  header{position:sticky;top:0;z-index:10;background:#ffffff;padding:8px 10px;border-bottom:1px solid #dddddd;margin:0 0 12px 0;display:flex;align-items:center;gap:8px}
  header h1{flex:1;font-size:20px;margin:0}
  button{font-size:14px;padding:6px 10px;border-radius:4px;border:1px solid #cccccc;background:#f3f4f6;color:#000000}
  input{font-size:14px;padding:6px 8px;border-radius:4px;border:1px solid #cccccc}
  table{border-collapse:collapse;width:100%}
  th,td{border:1px solid #dddddd;padding:6px}
  .card{border-radius:4px;border:1px solid #dddddd;padding:12px;background:#ffffff;margin-top:12px}
  pre{background:#f5f5f5;padding:8px;white-space:pre-wrap;border-radius:4px;border:1px solid #dddddd}
</style>
</head><body>
<header>
  <h1>Real Estate</h1>
  <button id=re_refresh onclick="loadP()">Refresh</button>
</header>
<section class="card">
  <h2>Browse</h2>
  <div style="display:flex;flex-wrap:wrap;gap:8px;align-items:center">
    <input id=q placeholder="Search" />
    <input id=city placeholder="City" />
    <input id=minp placeholder="Min price" />
    <input id=maxp placeholder="Max price" />
    <input id=minb placeholder="Min bedrooms" />
    <button onclick="loadP()">Search</button>
  </div>
  <div style="overflow:auto;margin-top:12px">
    <table id=props><thead><tr><th>ID</th><th>Title</th><th>City</th><th>Price</th><th>Beds</th><th>Owner</th></tr></thead><tbody></tbody></table>
  </div>
  <div id=pcnt style="margin-top:4px;font-size:12px;color:#666666"></div>
</section>
<section class="card">
  <h2>Create / Update</h2>
  <div style="display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:8px">
    <input id=pid placeholder="id (for update)" />
    <input id=ptitle placeholder="Title" />
    <input id=pprice placeholder="Price (cents)" />
    <input id=pcity placeholder="City" />
    <input id=paddr placeholder="Address" />
    <input id=pbeds placeholder="Bedrooms" />
    <input id=pbaths placeholder="Bathrooms" />
    <input id=parea placeholder="Area sqm" />
    <input id=powner placeholder="Owner wallet (optional)" />
  </div>
  <div style="margin-top:8px;display:flex;gap:8px">
    <button onclick="createP()">Create</button>
    <button onclick="updateP()">Update</button>
  </div>
  <pre id=pout style="margin-top:8px;font-size:12px"></pre>
</section>
<section class="card">
  <h2>Inquiry / Reserve</h2>
  <div style="display:flex;flex-wrap:wrap;gap:8px;align-items:center">
    <input id=selpid placeholder="property_id" />
    <input id=iname placeholder="Your name" />
    <input id=iphone placeholder="Phone" />
    <input id=imsg placeholder="Message" />
    <button onclick="inquiry()">Send Inquiry</button>
  </div>
  <div style="display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-top:8px">
    <input id=buyer placeholder="Buyer wallet id" />
    <input id=dep placeholder="Deposit (cents)" />
    <button onclick="reserve()">Reserve (pay)</button>
  </div>
  <pre id=iout style="margin-top:8px;font-size:12px"></pre>
</section>
<script>
  async function loadP(){ const u=new URLSearchParams(); const q=document.getElementById('q').value; if(q)u.set('q',q); const c=document.getElementById('city').value; if(c)u.set('city',c); const minp=document.getElementById('minp').value; if(minp)u.set('min_price',minp); const maxp=document.getElementById('maxp').value; if(maxp)u.set('max_price',maxp); const minb=document.getElementById('minb').value; if(minb)u.set('min_bedrooms',minb); const r=await fetch('/realestate/properties?'+u.toString()); const arr=await r.json(); const tb=document.querySelector('#props tbody'); tb.innerHTML=''; for(const p of arr){ const tr=document.createElement('tr'); tr.innerHTML=`<td class='p-2'>${p.id}</td><td class='p-2'>${p.title}</td><td class='p-2'>${p.city||''}</td><td class='p-2'>${p.price_cents}</td><td class='p-2'>${p.bedrooms||''}</td><td class='p-2'>${p.owner_wallet_id||''}</td>`; tb.appendChild(tr); } document.getElementById('pcnt').textContent = arr.length+' results'; }
  async function createP(){ const body={title:gi('ptitle'), price_cents:parseInt(gi('pprice')||'0',10), city:gi('pcity')||null, address:gi('paddr')||null, bedrooms:parseInt(gi('pbeds')||'0',10)||null, bathrooms:parseInt(gi('pbaths')||'0',10)||null, area_sqm:parseFloat(gi('parea')||'0')||null, owner_wallet_id:gi('powner')||null}; const r=await fetch('/realestate/properties',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); document.getElementById('pout').textContent=await r.text(); }
  async function updateP(){ const id=parseInt(gi('pid')||'0',10); const body={title:gi('ptitle')||undefined, price_cents: (gi('pprice')?parseInt(gi('pprice'),10):undefined), city:gi('pcity')||undefined, address:gi('paddr')||undefined, bedrooms: (gi('pbeds')?parseInt(gi('pbeds'),10):undefined), bathrooms: (gi('pbaths')?parseInt(gi('pbaths'),10):undefined), area_sqm: (gi('parea')?parseFloat(gi('parea')):undefined), owner_wallet_id:gi('powner')||undefined}; const r=await fetch('/realestate/properties/'+id,{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); document.getElementById('pout').textContent=await r.text(); }
  async function inquiry(){ const pid=parseInt(gi('selpid')||'0',10); const body={property_id:pid, name:gi('iname'), phone:gi('iphone')||null, message:gi('imsg')||null}; const r=await fetch('/realestate/inquiries',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); document.getElementById('iout').textContent=await r.text(); }
  async function reserve(){ const pid=parseInt(gi('selpid')||'0',10); const dep=parseInt(gi('dep')||'0',10); const body={property_id:pid, buyer_wallet_id:gi('buyer'), deposit_cents:dep}; const r=await fetch('/realestate/reserve',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); document.getElementById('iout').textContent=await r.text(); }
  function gi(id){ return (document.getElementById(id).value||'').trim(); }
  loadP();
</script>
</body></html>
"""
    return HTMLResponse(content=html)


@app.get("/stays", response_class=HTMLResponse)
def stays_page(request: Request):
    if not _auth_phone(request):
        return RedirectResponse(url="/login", status_code=303)
    html = """
<!doctype html>
<html><head><meta name=viewport content="width=device-width, initial-scale=1" />
<title>Stays</title>
<link rel="icon" href="/icons/stays.svg" />
<style>
  body{font-family:sans-serif;margin:20px;max-width:1000px;background:#ffffff;color:#000000;}
  header{position:sticky;top:0;z-index:10;background:#ffffff;padding:8px 10px;border-bottom:1px solid #dddddd;margin:0 0 12px 0;display:flex;align-items:center;gap:8px}
  header h1{flex:1;font-size:20px;margin:0}
  button{font-size:14px;padding:6px 10px;border-radius:4px;border:1px solid #cccccc;background:#f3f4f6;color:#000000}
  input{font-size:14px;padding:6px 8px;border-radius:4px;border:1px solid #cccccc}
  table{border-collapse:collapse;width:100%}
  th,td{border:1px solid #dddddd;padding:6px}
  .card{border-radius:4px;border:1px solid #dddddd;padding:12px;background:#ffffff;margin-top:12px}
  pre{background:#f5f5f5;padding:8px;white-space:pre-wrap;border-radius:4px;border:1px solid #dddddd}
</style>
</head><body>
<header>
  <h1>Stays</h1>
  <button id=st_refresh onclick="loadL()">Refresh</button>
</header>
<section class="card">
  <h2>Listings</h2>
  <div style="display:flex;flex-wrap:wrap;gap:8px;align-items:center">
    <input id=q placeholder="Search" />
    <input id=city placeholder="City" />
    <button onclick="loadL()">Search</button>
  </div>
  <div style="overflow:auto;margin-top:12px">
    <table id=ls><thead><tr><th>ID</th><th>Title</th><th>City</th><th>Price/Night</th><th>Owner</th></tr></thead><tbody></tbody></table>
  </div>
</section>
<section class="card">
  <h2>Create / Quote / Book</h2>
  <div style="display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:8px">
    <input id=title placeholder="Title" />
    <input id=lcity placeholder="City" />
    <input id=addr placeholder="Address" />
    <input id=ppn placeholder="Price per night (cents)" />
    <input id=ow placeholder="Owner wallet" />
  </div>
  <div style="margin-top:8px;display:flex;gap:8px">
    <button onclick="createL()">Create</button>
  </div>
  <div style="margin-top:8px">
    <div style="display:flex;flex-wrap:wrap;gap:8px;align-items:center">
      <input id=lid placeholder="listing_id" />
      <input id=from placeholder="YYYY-MM-DD" />
      <input id=to placeholder="YYYY-MM-DD" />
      <button onclick="quote()">Quote</button>
    </div>
    <pre id=qout style="margin-top:8px;font-size:12px"></pre>
  </div>
  <div style="margin-top:8px">
    <div style="display:flex;flex-wrap:wrap;gap:8px;align-items:center">
      <input id=gname placeholder="Guest name" />
      <input id=gphone placeholder="Phone" />
      <input id=gw placeholder="Guest wallet (optional)" />
      <label><input type=checkbox id=confirm /> Pay now (confirm)</label>
      <button onclick="book()">Book</button>
    </div>
    <pre id=bout style="margin-top:8px;font-size:12px"></pre>
  </div>
</section>
<section class="card">
  <h2>Booking status</h2>
  <div style="display:flex;flex-wrap:wrap;gap:8px;align-items:center">
    <input id=bid placeholder="booking_id" />
    <button onclick="bstatus()">Status</button>
  </div>
  <pre id=bst style="margin-top:8px;font-size:12px"></pre>
</section>
<script>
  async function loadL(){ const u=new URLSearchParams(); const q=document.getElementById('q').value; if(q)u.set('q',q); const c=document.getElementById('city').value; if(c)u.set('city',c); const r=await fetch('/stays/listings?'+u.toString()); const arr=await r.json(); const tb=document.querySelector('#ls tbody'); tb.innerHTML=''; for(const x of arr){ const tr=document.createElement('tr'); tr.innerHTML=`<td class='p-2'>${x.id}</td><td class='p-2'>${x.title}</td><td class='p-2'>${x.city||''}</td><td class='p-2'>${x.price_per_night_cents}</td><td class='p-2'>${x.owner_wallet_id||''}</td>`; tb.appendChild(tr);} }
  async function createL(){ const body={title:gi('title'), city:gi('lcity')||null, address:gi('addr')||null, price_per_night_cents:parseInt(gi('ppn')||'0',10), owner_wallet_id:gi('ow')||null}; const r=await fetch('/stays/listings',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); alert(await r.text()); loadL(); }
  async function quote(){ const body={listing_id:parseInt(gi('lid')||'0',10), from_iso:gi('from'), to_iso:gi('to')}; const r=await fetch('/stays/quote',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); document.getElementById('qout').textContent=await r.text(); }
  async function book(){ const body={listing_id:parseInt(gi('lid')||'0',10), guest_name:gi('gname'), guest_phone:gi('gphone'), guest_wallet_id:gi('gw')||null, from_iso:gi('from'), to_iso:gi('to'), confirm:document.getElementById('confirm').checked}; const r=await fetch('/stays/book',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); document.getElementById('bout').textContent=await r.text(); try{ const j=await r.clone().json(); document.getElementById('bid').value=j.id; }catch(_){ } }
  async function bstatus(){ const id=gi('bid'); const r=await fetch('/stays/bookings/'+id); document.getElementById('bst').textContent=await r.text(); }
  function gi(id){ return (document.getElementById(id).value||'').trim(); }
  loadL();
</script>
</body></html>
"""
    return HTMLResponse(content=html)


@app.get("/courier_console", response_class=HTMLResponse)
def courier_console(request: Request):
    if not _auth_phone(request):
        return RedirectResponse(url="/login", status_code=303)
    html = """
<!doctype html>
<html><head><meta name=viewport content="width=device-width, initial-scale=1" />
<title>Courier</title>
<style>
  body{font-family:sans-serif;margin:20px;max-width:1000px;background:#ffffff;color:#000000;}
  .card{border:1px solid #dddddd;border-radius:6px;padding:12px;margin-bottom:12px;}
  button{padding:6px 10px;border-radius:4px;border:1px solid #cccccc;background:#2563eb;color:#ffffff;}
  input,select{padding:6px 8px;border-radius:4px;border:1px solid #cccccc;}
  label{font-size:12px;color:#555;}
  pre{background:#f5f5f5;padding:8px;border-radius:4px;border:1px solid #e5e7eb;white-space:pre-wrap;}
</style>
</head><body>
<h1>Courier Console</h1>
<section class="card">
  <h3>Track shipment</h3>
  <div style="display:flex;gap:8px;flex-wrap:wrap">
    <input id=oid placeholder="Order ID" />
    <input id=token placeholder="Public token" />
    <button onclick="track()">Track</button>
  </div>
  <pre id=trackout></pre>
</section>
<section class="card">
  <h3>Contact / Reschedule</h3>
  <div style="display:flex;gap:8px;flex-wrap:wrap">
    <input id=cid placeholder="Order ID" />
    <input id=cmsg placeholder="Message for support" />
    <button onclick="contact()">Send</button>
  </div>
  <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px">
    <input id=ws type=datetime-local />
    <input id=we type=datetime-local />
    <label><input type=checkbox id=sts /> Short-term storage</label>
    <button onclick="resched()">Reschedule</button>
  </div>
  <pre id=contactout></pre>
</section>
<section class="card">
  <h3>Status / Scan / Proof</h3>
  <div style="display:flex;gap:8px;flex-wrap:wrap">
    <input id=sid placeholder="Order ID" />
    <select id=sstatus>
      <option value="assigned">assigned</option>
      <option value="pickup">pickup</option>
      <option value="delivering">delivering</option>
      <option value="delivered">delivered</option>
      <option value="failed">failed</option>
      <option value="retry">retry</option>
      <option value="return">return</option>
    </select>
    <input id=spin placeholder="PIN (for delivered)" />
    <input id=sproof placeholder="Proof URL" />
    <input id=sbarcode placeholder="Barcode / Scan" />
    <input id=ssign placeholder="Signature (text stub)" />
    <button onclick="setStatus()">Update</button>
  </div>
  <pre id=statusout></pre>
</section>
<section class="card">
  <h3>Partner KPIs</h3>
  <div style="display:flex;gap:8px;flex-wrap:wrap">
    <input id=pkpi_start type=datetime-local />
    <input id=pkpi_end type=datetime-local />
    <input id=pkpi_carrier placeholder="Carrier" />
    <select id=pkpi_service>
      <option value="">any</option>
      <option value="same_day">same_day</option>
      <option value="next_day">next_day</option>
    </select>
    <button onclick="loadKPI()">Load KPIs</button>
  </div>
  <pre id=kpiout></pre>
</section>
<section class="card">
  <h3>Stats & CO₂</h3>
  <div style="display:flex;gap:8px;flex-wrap:wrap">
    <input id=stat_carrier placeholder="Carrier" />
    <input id=stat_partner placeholder="Partner ID" />
    <select id=stat_service>
      <option value="">any</option>
      <option value="same_day">same_day</option>
      <option value="next_day">next_day</option>
    </select>
    <button onclick="loadStats()">Load stats</button>
  </div>
  <pre id=statout></pre>
</section>
<script>
async function track(){
  const oid=document.getElementById('oid').value;
  const token=document.getElementById('token').value;
  const url = oid?('/courier/shipments/'+encodeURIComponent(oid)):(token?('/courier/track/'+encodeURIComponent(token)):null);
  if(!url){ alert('Provide order id or token'); return; }
  const r=await fetch(url); document.getElementById('trackout').textContent=await r.text();
}
async function contact(){
  const oid=document.getElementById('cid').value;
  const msg=document.getElementById('cmsg').value;
  if(!oid||!msg){ alert('Order id and message required'); return; }
  const r=await fetch('/courier/orders/'+encodeURIComponent(oid)+'/contact',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({message:msg})});
  document.getElementById('contactout').textContent=await r.text();
}
async function resched(){
  const oid=document.getElementById('cid').value;
  const ws=document.getElementById('ws').value;
  const we=document.getElementById('we').value;
  if(!oid||!ws||!we){ alert('Order id and both windows required'); return; }
  const body={window_start:ws, window_end:we, short_term_storage:document.getElementById('sts').checked};
  const r=await fetch('/courier/orders/'+encodeURIComponent(oid)+'/reschedule',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)});
  document.getElementById('contactout').textContent=await r.text();
}
async function loadKPI(){
  const params=new URLSearchParams();
  const s=document.getElementById('pkpi_start').value; const e=document.getElementById('pkpi_end').value;
  const c=document.getElementById('pkpi_carrier').value; const svc=document.getElementById('pkpi_service').value;
  if(s)params.set('start_iso',s); if(e)params.set('end_iso',e); if(c)params.set('carrier',c); if(svc)params.set('service_type',svc);
  const r=await fetch('/courier/kpis/partners?'+params.toString()); document.getElementById('kpiout').textContent=await r.text();
}
async function loadStats(){
  const params=new URLSearchParams();
  const c=document.getElementById('stat_carrier').value;
  const p=document.getElementById('stat_partner').value;
  const svc=document.getElementById('stat_service').value;
  if(c)params.set('carrier',c); if(p)params.set('partner_id',p); if(svc)params.set('service_type',svc);
  const r=await fetch('/courier/stats?'+params.toString()); document.getElementById('statout').textContent=await r.text();
}
async function setStatus(){
  const oid=document.getElementById('sid').value;
  if(!oid){ alert('Order id required'); return; }
  const body={
    status:document.getElementById('sstatus').value,
    pin:document.getElementById('spin').value||undefined,
    proof_url:document.getElementById('sproof').value||undefined,
    scanned_barcode:document.getElementById('sbarcode').value||undefined,
    signature:document.getElementById('ssign').value||undefined
  };
  const r=await fetch('/courier/shipments/'+encodeURIComponent(oid)+'/status',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)});
  document.getElementById('statusout').textContent=await r.text();
}
</script>
</body></html>
"""
    return HTMLResponse(content=html)


@app.get("/courier/track_page", response_class=HTMLResponse)
def courier_track_page(request: Request):
    if not _auth_phone(request):
        return RedirectResponse(url="/login", status_code=303)
    try:
        with open(Path(__file__).parent / "courier_tracking.html", "r") as f:
            content = f.read()
    except Exception:
        return HTMLResponse(content="tracking UI not found", status_code=500)
    return HTMLResponse(content=content)


@app.get("/courier/driver_page", response_class=HTMLResponse)
def courier_driver_page(request: Request):
    if not _auth_phone(request):
        return RedirectResponse(url="/login", status_code=303)
    try:
        with open(Path(__file__).parent / "courier_driver.html", "r") as f:
            content = f.read()
    except Exception:
        return HTMLResponse(content="driver UI not found", status_code=500)
    return HTMLResponse(content=content)


@app.get("/courier/sla_page", response_class=HTMLResponse)
def courier_sla_page(request: Request):
    if not _auth_phone(request):
        return RedirectResponse(url="/login", status_code=303)
    try:
        with open(Path(__file__).parent / "courier_sla.html", "r") as f:
            content = f.read()
    except Exception:
        return HTMLResponse(content="sla UI not found", status_code=500)
    return HTMLResponse(content=content)


@app.get("/freight", response_class=HTMLResponse)
def freight_page(request: Request):
    if not _auth_phone(request):
        return RedirectResponse(url="/login", status_code=303)
    html = """
<!doctype html>
<html><head><meta name=viewport content="width=device-width, initial-scale=1" />
<title>Freight</title>
<link rel="icon" href="/icons/freight.svg" />
<style>
  body{font-family:sans-serif;margin:20px;max-width:1000px;background:#ffffff;color:#000000;}
  header{position:sticky;top:0;z-index:10;background:#ffffff;padding:8px 10px;border-bottom:1px solid #dddddd;margin:0 0 12px 0;display:flex;align-items:center;gap:8px}
  header h1{flex:1;font-size:20px;margin:0}
  button{font-size:14px;padding:6px 10px;border-radius:4px;border:1px solid #cccccc;background:#f3f4f6;color:#000000}
  input,select{font-size:14px;padding:6px 8px;border-radius:4px;border:1px solid #cccccc}
  table{border-collapse:collapse;width:100%}
  th,td{border:1px solid #dddddd;padding:6px}
  .card{border-radius:4px;border:1px solid #dddddd;padding:12px;background:#ffffff;margin-top:12px}
  pre{background:#f5f5f5;padding:8px;white-space:pre-wrap;border-radius:4px;border:1px solid #dddddd}
</style>
</head><body>
<header>
  <h1>Freight</h1>
  <button id=fr_refresh onclick="noop()">Refresh</button>
</header>
<section class="card">
  <h2>Quote</h2>
  <div style="display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:8px">
    <input id=title placeholder="Title" />
    <input id=flat placeholder="from lat" />
    <input id=flon placeholder="from lon" />
    <input id=tlat placeholder="to lat" />
    <input id=tlon placeholder="to lon" />
    <input id=kg placeholder="weight kg" />
  </div>
  <div style="margin-top:8px;display:flex;gap:8px">
    <button onclick="quote()">Quote</button>
  </div>
  <pre id=qout style="margin-top:8px;font-size:12px"></pre>
</section>
<section class="card">
  <h2>Book</h2>
  <div style="display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:8px">
    <input id=payer placeholder="Payer wallet id" />
    <input id=carrier placeholder="Carrier wallet id" />
    <label><input type=checkbox id=confirm /> Pay now (confirm)</label>
  </div>
  <div style="margin-top:8px;display:flex;gap:8px">
    <button onclick="book()">Book</button>
  </div>
  <pre id=bout style="margin-top:8px;font-size:12px"></pre>
</section>
<section class="card">
  <h2>Shipment status</h2>
  <div style="display:flex;flex-wrap:wrap;gap:8px;align-items:center">
    <input id=sid placeholder="shipment id" />
    <button onclick="sstatus()">Status</button>
    <select id=st>
      <option>booked</option>
      <option>in_transit</option>
      <option>delivered</option>
      <option>canceled</option>
    </select>
    <button onclick="sset()">Set status</button>
  </div>
  <pre id=sout style="margin-top:8px;font-size:12px"></pre>
</section>
<script>
  function noop(){ /* placeholder for top refresh; per-section actions provided */ }
  let lastReq=null;
  async function quote(){ const body={title:gi('title'), from_lat:parseFloat(gi('flat')), from_lon:parseFloat(gi('flon')), to_lat:parseFloat(gi('tlat')), to_lon:parseFloat(gi('tlon')), weight_kg:parseFloat(gi('kg'))}; lastReq=body; const r=await fetch('/freight/quote',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); document.getElementById('qout').textContent=await r.text(); }
  async function book(){ const req=lastReq||{title:gi('title'), from_lat:parseFloat(gi('flat')), from_lon:parseFloat(gi('flon')), to_lat:parseFloat(gi('tlat')), to_lon:parseFloat(gi('tlon')), weight_kg:parseFloat(gi('kg'))}; const body=Object.assign({}, req, {payer_wallet_id:gi('payer')||null, carrier_wallet_id:gi('carrier')||null, confirm:document.getElementById('confirm').checked}); const r=await fetch('/freight/book',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); const t=await r.text(); document.getElementById('bout').textContent=t; try{ const j=JSON.parse(t); document.getElementById('sid').value=j.id; }catch(_){} }
  async function sstatus(){ const id=gi('sid'); const r=await fetch('/freight/shipments/'+id); document.getElementById('sout').textContent=await r.text(); }
  async function sset(){ const id=gi('sid'); const st=document.getElementById('st').value; const r=await fetch('/freight/shipments/'+id+'/status',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({status:st})}); document.getElementById('sout').textContent=await r.text(); }
  function gi(id){ return (document.getElementById(id).value||'').trim(); }
</script>
</body></html>
"""
    return HTMLResponse(content=html)


@app.get("/bus", response_class=HTMLResponse)
def bus_page(request: Request):
    if not _auth_phone(request):
        return RedirectResponse(url="/login", status_code=303)
    html = """
<!doctype html>
<html><head><meta name=viewport content="width=device-width, initial-scale=1" />
<title>Bus</title>
<link rel="icon" href="/icons/bus.svg" />
<style>
  body{font-family:sans-serif;margin:20px;max-width:1100px;background:#ffffff;color:#000000;}
  header{position:sticky;top:0;z-index:10;background:#ffffff;padding:8px 10px;border-bottom:1px solid #dddddd;margin:0 0 12px 0;display:flex;align-items:center;gap:8px}
  header h1{flex:1;font-size:20px;margin:0}
  a{color:#2563eb;text-decoration:none}
  button{font-size:14px;padding:6px 10px;border-radius:4px;border:1px solid #cccccc;background:#f3f4f6;color:#000000}
  input,select{font-size:14px;padding:6px 8px;border-radius:4px;border:1px solid #cccccc}
  table{border-collapse:collapse;width:100%}
  th,td{border:1px solid #dddddd;padding:6px}
  .card{border-radius:6px;border:1px solid #dddddd;padding:12px;background:#ffffff;margin-top:12px}
  pre{background:#f5f5f5;padding:8px;white-space:pre-wrap;border-radius:6px;border:1px solid #dddddd}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  .muted{opacity:.75;font-size:12px}
  .btn{cursor:pointer}
</style>
</head><body>
<header>
  <h1>Bus</h1>
  <a href="/bus/admin">Admin</a>
</header>

<section class="card">
  <h2 style="margin:0 0 10px 0">Search trips</h2>
  <div class="row">
    <select id=origin></select>
    <select id=dest></select>
    <input id=date type=date />
    <button class="btn" onclick="searchTrips()">Search</button>
    <span class="muted" id=city_note></span>
  </div>
  <div style="overflow:auto;margin-top:12px">
    <table id=trips>
      <thead>
        <tr>
          <th>Trip ID</th>
          <th>Operator</th>
          <th>From</th>
          <th>To</th>
          <th>Depart</th>
          <th>Arrive</th>
          <th>Price</th>
          <th>Seats</th>
          <th>Book</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>
  <pre id=out style="margin-top:12px;font-size:12px"></pre>
</section>

<script>
function esc(s){ return (s||'').toString().replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
function fmtIso(iso){
  try{
    if(!iso) return '';
    const d=new Date(iso);
    if(isNaN(d.getTime())) return iso;
    return d.toLocaleString();
  }catch(_){ return iso||''; }
}
async function loadCities(){
  const note=document.getElementById('city_note');
  note.textContent='Loading cities…';
  try{
    const r=await fetch('/bus/cities_cached?limit=200');
    const arr=await r.json();
    const origin=document.getElementById('origin');
    const dest=document.getElementById('dest');
    origin.innerHTML=''; dest.innerHTML='';
    for(const c of arr){
      const id = (c.id||'').toString();
      const name = (c.name||'').toString();
      const country = (c.country||'').toString();
      const label = country ? (name + ' · ' + country) : name;
      const opt=document.createElement('option');
      opt.value=id; opt.textContent=label;
      origin.appendChild(opt.cloneNode(true));
      dest.appendChild(opt);
    }
    // default: first two cities if available
    if(origin.options.length>0) origin.selectedIndex=0;
    if(dest.options.length>1) dest.selectedIndex=1;
    note.textContent = origin.options.length ? (origin.options.length + ' cities') : 'No cities';
  }catch(e){
    note.textContent='Failed to load cities';
    document.getElementById('out').textContent='Error loading cities: ' + e;
  }
}

async function searchTrips(){
  const out=document.getElementById('out');
  out.textContent='Searching…';
  const origin=document.getElementById('origin').value;
  const dest=document.getElementById('dest').value;
  const date=document.getElementById('date').value;
  if(!origin || !dest || !date){
    out.textContent='Please select origin, destination and date.';
    return;
  }
  try{
    const u=new URLSearchParams({origin_city_id: origin, dest_city_id: dest, date: date});
    const r=await fetch('/bus/trips/search?' + u.toString());
    const text=await r.text();
    if(r.status<200 || r.status>=300){
      out.textContent = 'HTTP ' + r.status + ': ' + text;
      return;
    }
    const arr=JSON.parse(text);
    const tb=document.querySelector('#trips tbody');
    tb.innerHTML='';
    for(const row of arr){
      const trip=row.trip||{};
      const o=row.origin||{};
      const d=row.dest||{};
      const op=row.operator||{};
      const tr=document.createElement('tr');
      const tripId = esc(trip.id||'');
      const seatsAvail = (trip.seats_available!=null) ? trip.seats_available : '';
      const seatsTotal = (trip.seats_total!=null) ? trip.seats_total : '';
      const seats = seatsAvail && seatsTotal ? (seatsAvail + '/' + seatsTotal) : '';
      const price = (trip.price_cents!=null ? trip.price_cents : '') + ' ' + (trip.currency||'');
      tr.innerHTML =
        '<td>' + tripId + '</td>' +
        '<td>' + esc(op.name||'') + '</td>' +
        '<td>' + esc(o.name||'') + '</td>' +
        '<td>' + esc(d.name||'') + '</td>' +
        '<td>' + esc(fmtIso(trip.depart_at)) + '</td>' +
        '<td>' + esc(fmtIso(trip.arrive_at)) + '</td>' +
        '<td>' + esc(price.trim()) + '</td>' +
        '<td>' + esc(seats) + '</td>' +
        '<td><div class=\"row\" style=\"gap:6px\">' +
          '<input id=\"seats_' + tripId + '\" type=number min=1 max=10 value=1 style=\"width:70px\" />' +
          '<button class=\"btn\" onclick=\"bookTrip(\\'' + tripId + '\\')\">Book</button>' +
        '</div></td>';
      tb.appendChild(tr);
    }
    out.textContent = arr.length ? ('Found ' + arr.length + ' trips.') : 'No trips found.';
  }catch(e){
    out.textContent = 'Error: ' + e;
  }
}

async function bookTrip(tripId){
  const out=document.getElementById('out');
  const inp=document.getElementById('seats_' + tripId);
  let seats = 1;
  try{ seats = parseInt(inp.value||'1',10); }catch(_){ seats = 1; }
  if(!(seats>=1 && seats<=10)){
    out.textContent='Seats must be 1..10';
    return;
  }
  out.textContent='Booking…';
  try{
    const r=await fetch('/bus/trips/' + encodeURIComponent(tripId) + '/book', {
      method:'POST',
      headers:{'content-type':'application/json'},
      body: JSON.stringify({seats: seats}),
    });
    out.textContent = 'HTTP ' + r.status + ': ' + (await r.text());
  }catch(e){
    out.textContent = 'Booking error: ' + e;
  }
}

try{
  const d = new Date();
  const iso = d.toISOString().slice(0,10);
  document.getElementById('date').value = iso;
}catch(_){}

loadCities();
</script>
</body></html>
"""
    return HTMLResponse(content=html)


@app.get("/bus/admin", response_class=HTMLResponse)
def bus_admin_page(request: Request):
    if not _auth_phone(request):
        return RedirectResponse(url="/login", status_code=303)
    html = """
<!doctype html>
<html><head><meta name=viewport content="width=device-width, initial-scale=1" />
<title>Bus Admin</title>
<link rel="icon" href="/icons/bus.svg" />
<link rel="manifest" href="/bus/manifest.json" />
<style>
  body{font-family:sans-serif;margin:20px;max-width:980px;background:#ffffff;color:#000000;}
  input,button,select{font-size:14px;padding:6px;margin:4px 0}
  input,select{background:#ffffff;border:1px solid #cccccc;border-radius:4px;color:#000000}
  button{border:1px solid #cccccc;background:#f3f4f6;border-radius:4px;color:#000000;box-shadow:none}
  pre{background:#f5f5f5;padding:8px;white-space:pre-wrap;border-radius:4px;border:1px solid #dddddd}
  .grid{display:grid;grid-template-columns:repeat(2,minmax(280px,1fr));gap:16px}
  .full{grid-column:1/-1}
  h2{margin-top:18px}
  small{opacity:.8}
  .row{display:flex;gap:8px;align-items:center}
  label{display:block;font-size:12px;opacity:.8;margin-top:6px}
  .muted{opacity:.7}
  .ok{color:#15803d}
  .warn{color:#b45309}
</style>
</head><body>
<h1>Bus Admin</h1>

<div class="grid">
  <div data-ds="card">
    <h2>Health</h2>
    <button onclick="health()">Check /bus/health</button>
    <pre id=health_out></pre>
  </div>

  <div data-ds="card">
    <h2>Cities</h2>
    <label>Name</label><input id=city_name placeholder="Damascus" />
    <label>Country</label><input id=city_country placeholder="Syria" />
    <div class=row>
      <button onclick="addCity()">Add City</button>
      <button onclick="listCities()">List</button>
    </div>
    <pre id=cities_out></pre>
  </div>

  <div data-ds="card">
    <h2>Operators</h2>
    <label>Name</label><input id=op_name placeholder="Shuttle Co." />
    <label>Wallet ID</label><input id=op_wallet placeholder="wallet-uuid" />
    <div class=row>
      <button onclick="addOperator()">Add Operator</button>
      <button onclick="listOperators()">List</button>
    </div>
    <div id=ops_out class="text-sm whitespace-pre-wrap"></div>
  </div>

  <div data-ds="card">
    <h2>Routes</h2>
    <label>Origin City ID</label><input id=rt_origin placeholder="city-id" />
    <label>Destination City ID</label><input id=rt_dest placeholder="city-id" />
    <label>Operator ID</label><input id=rt_op placeholder="operator-id" />
    <div class=row>
      <button onclick="addRoute()">Create Route</button>
      <button onclick="listRoutes()">List</button>
    </div>
    <pre id=routes_out></pre>
  </div>

  <div class="full" data-ds="card">
    <h2>Trips</h2>
    <div class=row>
      <div style="flex:1">
        <label>Route ID</label><input id=trip_route placeholder="route-id" />
      </div>
      <div>
        <label>Price (cents)</label><input id=trip_price placeholder="8000" />
      </div>
      <div>
        <label>Seats</label><input id=trip_seats placeholder="40" />
      </div>
    </div>
    <div class=row>
      <div style="flex:1">
        <label>Depart at (ISO)</label><input id=trip_dep placeholder="2025-11-20T08:00:00+00:00" />
      </div>
      <div style="flex:1">
        <label>Arrive at (ISO)</label><input id=trip_arr placeholder="2025-11-20T10:00:00+00:00" />
      </div>
    </div>
    <div class=row>
      <button onclick="addTrip()">Create Trip</button>
    </div>
    <div class=row>
      <div>
        <label>Search: Origin City</label><input id=s_origin placeholder="city-id" />
      </div>
      <div>
        <label>Dest City</label><input id=s_dest placeholder="city-id" />
      </div>
      <div>
        <label>Date (YYYY-MM-DD)</label><input id=s_date placeholder="2025-11-20" />
      </div>
      <button onclick="searchTrips()">Search</button>
    </div>
    <pre id=trips_out></pre>
  </div>

  <div data-ds="card">
    <h2>Booking</h2>
    <label>Trip ID</label><input id=b_trip placeholder="trip-id" />
    <label>Seats</label><input id=b_seats value="1" />
    <label>Wallet ID (optional)</label><input id=b_wallet placeholder="payer wallet" />
    <label>Customer Phone (optional)</label><input id=b_phone placeholder="+963..." />
    <div class=row>
      <button onclick="bookTrip()">Book</button>
    </div>
    <pre id=book_out></pre>
  </div>

  <div data-ds="card">
    <h2>Tickets / Boarding</h2>
    <label>Booking ID</label><input id=t_booking placeholder="booking-id" />
    <div class=row>
      <button onclick="loadTickets()">Load Tickets</button>
    </div>
    <label>Ticket Payload (QR)</label><input id=t_payload placeholder="TICKET|id=...|b=...|trip=...|seat=...|sig=..." />
    <div class=row>
      <button onclick="boardTicket()">Board</button>
    </div>
    <div id=tick_qrs style="display:grid;grid-template-columns:repeat(auto-fill,minmax(160px,1fr));gap:12px"></div>
    <pre id=tick_out></pre>
  </div>

  <div class="full muted">
    <small>Tip: Use /payments/users + /payments/wallets/{id}/topup (Admin) to create and top up wallets. Set Operator.wallet_id so payments can be processed.</small>
  </div>
</div>

<script>
function gi(id){ return (document.getElementById(id).value||'').trim(); }
async function health(){ const r=await fetch('/bus/health'); document.getElementById('health_out').textContent = await r.text(); }
async function addCity(){ const body={name:gi('city_name'), country:gi('city_country')||null}; const r=await fetch('/bus/cities',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); document.getElementById('cities_out').textContent=await r.text(); }
async function listCities(){ const r=await fetch('/bus/cities'); document.getElementById('cities_out').textContent=await r.text(); }
async function addOperator(){ const body={name:gi('op_name'), wallet_id:gi('op_wallet')||null}; const r=await fetch('/bus/operators',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); document.getElementById('ops_out').textContent=await r.text(); }
async function listOperators(){
  const box=document.getElementById('ops_out');
  box.textContent='Loading...';
  const r=await fetch('/bus/operators');
  try{
    const arr=await r.json();
    if(!Array.isArray(arr)){ box.textContent=JSON.stringify(arr,null,2); return; }
    box.innerHTML='';
    for(const op of arr){
      const row=document.createElement('div');
      row.className='flex items-center gap-2 border-b border-gray-200 py-1';
      const status = op.is_online ? 'Online' : 'Offline';
      row.innerHTML = `<span class="flex-1">${op.id} <small class="text-gray-500">${op.name||''}</small> <small class="text-gray-500">${status}</small></span>`;
      const btnOn = document.createElement('button');
      btnOn.textContent = 'Online';
      btnOn.onclick = async ()=>{ await fetch('/bus/operators/'+encodeURIComponent(op.id)+'/online',{method:'POST'}); listOperators(); };
      const btnOff = document.createElement('button');
      btnOff.textContent = 'Offline';
      btnOff.onclick = async ()=>{ await fetch('/bus/operators/'+encodeURIComponent(op.id)+'/offline',{method:'POST'}); listOperators(); };
      btnOn.className='px-2 py-1 border rounded text-xs';
      btnOff.className='px-2 py-1 border rounded text-xs';
      row.appendChild(btnOn); row.appendChild(btnOff);
      box.appendChild(row);
    }
  }catch(_){
    box.textContent=await r.text();
  }
}
async function addRoute(){ const body={origin_city_id:gi('rt_origin'), dest_city_id:gi('rt_dest'), operator_id:gi('rt_op')}; const r=await fetch('/bus/routes',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); document.getElementById('routes_out').textContent=await r.text(); }
async function listRoutes(){ const oc=gi('rt_origin'); const dc=gi('rt_dest'); const url = '/bus/routes'+((oc||dc)? ('?'+new URLSearchParams({origin_city_id:oc||'', dest_city_id:dc||''})) : ''); const r=await fetch(url); document.getElementById('routes_out').textContent=await r.text(); }
async function addTrip(){ const body={route_id:gi('trip_route'), depart_at_iso:gi('trip_dep'), arrive_at_iso:gi('trip_arr'), price_cents:parseInt(gi('trip_price')||'0'), currency:'SYP', seats_total:parseInt(gi('trip_seats')||'40')}; const r=await fetch('/bus/trips',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); document.getElementById('trips_out').textContent=await r.text(); }
async function searchTrips(){ const oc=gi('s_origin'), dc=gi('s_dest'), d=gi('s_date'); const r=await fetch('/bus/trips/search?'+new URLSearchParams({origin_city_id:oc,dest_city_id:dc,date:d})); const t=await r.text(); document.getElementById('trips_out').textContent=t; try{ const arr=JSON.parse(t); if(arr && arr.length>0 && arr[0].trip && arr[0].trip.id){ document.getElementById('b_trip').value=arr[0].trip.id; } }catch(_){ }
}
async function bookTrip(){ const body={seats:parseInt(gi('b_seats')||'1'), wallet_id:gi('b_wallet')||null, customer_phone:gi('b_phone')||null}; const id=gi('b_trip'); const r=await fetch('/bus/trips/'+encodeURIComponent(id)+'/book',{method:'POST',headers:{'content-type':'application/json','Idempotency-Key':'ui-'+Date.now()},body:JSON.stringify(body)}); const t=await r.text(); document.getElementById('book_out').textContent=t; try{ const j=JSON.parse(t); if(j && j.id){ document.getElementById('t_booking').value=j.id; } }catch(_){ }
}
async function loadTickets(){
  const id=gi('t_booking');
  const r=await fetch('/bus/bookings/'+encodeURIComponent(id)+'/tickets');
  const t=await r.text();
  document.getElementById('tick_out').textContent=t;
  try{
    const arr = JSON.parse(t);
    const box = document.getElementById('tick_qrs');
    if(Array.isArray(arr)){
      box.innerHTML = '';
      arr.forEach((tk)=>{
        const payload = (tk && tk.payload)||'';
        const seat = tk && tk.seat_no;
        const id = tk && tk.id;
        const div = document.createElement('div');
        div.style.padding='8px'; div.style.border='1px solid #dddddd'; div.style.borderRadius='4px';
        const img = document.createElement('img');
        img.alt = 'QR'; img.style.width='100%'; img.style.background='#fff'; img.style.borderRadius='8px';
        img.src = '/qr.png?'+new URLSearchParams({data: payload});
        const label = document.createElement('div'); label.style.marginTop='6px'; label.style.fontSize='12px'; label.style.opacity='.85';
        label.textContent = 'Seat: '+(seat||'?')+'  ·  '+(id||'');
        const small = document.createElement('div'); small.style.fontSize='11px'; small.style.opacity='.75'; small.textContent = payload.substring(0,80) + (payload.length>80?'…':'');
        div.appendChild(img); div.appendChild(label); div.appendChild(small);
        box.appendChild(div);
      });
    }
  }catch(_){ }
}
async function boardTicket(){ const body={payload:gi('t_payload')}; const r=await fetch('/bus/tickets/board',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); document.getElementById('tick_out').textContent=await r.text(); }
</script>
</body></html>
"""
    return HTMLResponse(content=html)


@app.get("/ds.js")
def ds_js():
    js = """
(function(){
  if (window.__dsInjected) return; window.__dsInjected = true;
  var css = `:root{--ds-c1:#6366f1;--ds-c2:#22d3ee;--ds-c3:#22c55e;--ds-glow:rgba(34,211,238,.5)}
  @keyframes ds-shift{0%{background-position:0% 50%}50%{background-position:100% 50%}100%{background-position:0% 50%}}
  @keyframes ds-sheen{0%{transform:translateX(-120%) skewX(-15deg);opacity:.0}30%{opacity:.6}70%{opacity:.6}100%{transform:translateX(140%) skewX(-15deg);opacity:0}}
  .ds-btn, .ds-btnPri{position:relative;display:inline-flex;align-items:center;gap:10px;padding:12px 18px;border-radius:20px;color:#f6fbff;
    border:1.2px solid rgba(255,255,255,.32);
    background: radial-gradient(120% 140% at 0% 0%, rgba(255,255,255,.34), rgba(255,255,255,.14)), rgba(255,255,255,.10);
    box-shadow: inset 0 1px 1px rgba(255,255,255,.30), inset 0 -8px 22px rgba(0,0,0,.42), 0 14px 36px rgba(0,0,0,.65), 0 0 0 1px rgba(255,255,255,.10), 0 0 28px var(--ds-glow);
    backdrop-filter: blur(16px) saturate(150%);
    transition: transform .12s ease, box-shadow .22s ease, background .22s ease, filter .22s ease;
    transform: translateZ(0);
    text-shadow: 0 1px 1px rgba(0,0,0,.45), 0 0 12px rgba(255,255,255,.20);
  }
  .ds-btn:before, .ds-btnPri:before{content:"";position:absolute;inset:0;border-radius:20px;background:
    radial-gradient(80% 100% at 12% 8%, rgba(255,255,255,.58), rgba(255,255,255,0) 60%),
    radial-gradient(60% 60% at 85% 10%, rgba(255,255,255,.22), rgba(255,255,255,0) 60%);
    pointer-events:none;mix-blend-mode:screen}
  .ds-btn:after, .ds-btnPri:after{content:"";position:absolute;top:-20%;bottom:-20%;width:28%;left:0;border-radius:20px;
    background: linear-gradient(90deg, rgba(255,255,255,0), rgba(255,255,255,.65), rgba(255,255,255,0));
    filter: blur(4px);opacity:0;pointer-events:none}
  .ds-btn:hover, .ds-btnPri:hover{transform:translateY(-2px);box-shadow: inset 0 1px 1px rgba(255,255,255,.35), inset 0 -8px 20px rgba(0,0,0,.38), 0 18px 40px rgba(0,0,0,.7), 0 0 0 1px rgba(255,255,255,.12), 0 0 30px var(--ds-glow)}
  .ds-btn:hover:after, .ds-btnPri:hover:after{animation: ds-sheen .9s ease forwards}
  .ds-btn:active, .ds-btnPri:active{transform:translateY(0) scale(.985);filter:saturate(175%);box-shadow: inset 0 1px 1px rgba(255,255,255,.34), inset 0 -12px 22px rgba(0,0,0,.45), 0 12px 28px rgba(0,0,0,.6), 0 0 0 1px rgba(255,255,255,.12)}
  .ds-btnPri{background-image: linear-gradient(120deg, var(--ds-c1), var(--ds-c2), var(--ds-c3)); background-size: 220% 220%; animation: ds-shift 5s linear infinite;}
  .ds-btnSec{position:relative;display:inline-flex;align-items:center;gap:10px;padding:12px 18px;border-radius:20px;color:#f6fbff;
    border:1.2px solid rgba(255,255,255,.28);
    background: rgba(255,255,255,.08);
    box-shadow: inset 0 1px 1px rgba(255,255,255,.22), 0 10px 26px rgba(0,0,0,.35);
    backdrop-filter: blur(12px) saturate(140%);
    transition: transform .12s ease, box-shadow .22s ease;
  }
  .ds-btnGhost{display:inline-flex;align-items:center;gap:10px;padding:10px 14px;border-radius:16px;color:#f6fbff;border:1px solid transparent;background:transparent}
  .ds-chip{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;background:rgba(255,255,255,.12);border:1px solid rgba(255,255,255,.28);backdrop-filter:blur(10px);color:#fff;font-size:12px}
  .ds-card{border-radius:20px;border:1px solid rgba(255,255,255,.22);background:rgba(255,255,255,.09);backdrop-filter:blur(18px);box-shadow:0 10px 26px rgba(0,0,0,.25)}
  .ds-input{padding:10px 12px;border-radius:14px;border:1px solid rgba(255,255,255,.22);background:rgba(255,255,255,.08);color:#f6fbff;backdrop-filter:blur(12px)}
  .ds-input::placeholder{color:rgba(255,255,255,.65)}
  body{font-synthesis-weight:none;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}
  `;
  try{ var st=document.createElement('style'); st.id='ds-style'; st.textContent=css; document.head.appendChild(st);
       var st2=document.createElement('style'); st2.id='ds-simple'; st2.textContent = `
         :root{--bg:#0f172a;--fg:#f8fafc;--muted:#94a3b8;--border:#1f2937;--card:rgba(255,255,255,.06);--accent:#6366f1;--accent-contrast:#ffffff}
         .dark:root{--bg:#0f172a;--fg:#f8fafc;--muted:#94a3b8;--border:#1f2937;--card:rgba(255,255,255,.06);--accent:#6366f1;--accent-contrast:#ffffff}
         .ds-btn{display:inline-flex;align-items:center;justify-content:center;gap:8px;padding:12px 16px;border-radius:16px;border:1px solid rgba(255,255,255,.22);background:rgba(255,255,255,.08);color:#fff;backdrop-filter:blur(10px)}
         .ds-btn:hover{filter:brightness(1.02)} .ds-btn:active{transform:translateY(1px)}
         .ds-btnPri{display:inline-flex;align-items:center;justify-content:center;gap:8px;padding:12px 16px;border-radius:16px;border:1px solid rgba(255,255,255,.24);background:linear-gradient(120deg, #6366f1, #22d3ee, #22c55e);background-size:220% 220%;color:#fff;box-shadow:0 8px 20px rgba(0,0,0,.35)}
         .ds-btnSec{display:inline-flex;align-items:center;justify-content:center;gap:8px;padding:12px 16px;border-radius:16px;border:1px solid rgba(255,255,255,.22);background:rgba(255,255,255,.08);color:#fff}
         .ds-btnGhost{display:inline-flex;align-items:center;justify-content:center;gap:8px;padding:10px 12px;border-radius:14px;border:1px solid transparent;background:transparent;color:#fff}
         .ds-input{padding:10px 12px;border-radius:12px;border:1.5px solid rgba(255,255,255,.28);background:rgba(255,255,255,.08);color:#f8fafc}
         .ds-input::placeholder{color:#cbd5e1}
         .ds-input:focus{background:rgba(255,255,255,.10)}
         .ds-card{border:1px solid rgba(255,255,255,.22);border-radius:18px;background:rgba(255,255,255,.06);backdrop-filter:blur(12px);box-shadow:0 6px 16px rgba(0,0,0,.25);padding:12px}
      `; document.head.appendChild(st2);
  }catch(_){ }
  function setAccent(name){
    var palette={ payments:'#2563eb', merchant:'#7c3aed', taxi:'#f59e0b', food:'#ef4444', realestate:'#10b981', stays:'#14b8a6', freight:'#f59e0b', carmarket:'#3b82f6', carrental:'#3b82f6', chat:'#06b6d4', agriculture:'#10b981', commerce:'#0ea5e9', doctors:'#f43f5e', flights:'#38bdf8', jobs:'#8b5cf6', livestock:'#84cc16', default:'#2563eb'}; var a = palette[name] || palette.default; var root=document.documentElement; root.style.setProperty('--accent', a);
  }
  function apply(){
    try{ document.querySelectorAll('.btnPri').forEach(function(el){ el.classList.add('ds-btnPri');}); }catch(_){ }
    try{ document.querySelectorAll('.btnSec').forEach(function(el){ el.classList.add('ds-btnSec');}); }catch(_){ }
    try{ document.querySelectorAll('.btnGhost').forEach(function(el){ el.classList.add('ds-btnGhost');}); }catch(_){ }
    try{ document.querySelectorAll('button').forEach(function(el){ if(!el.classList.contains('ds-btnPri') && !el.classList.contains('ds-btnSec') && !el.classList.contains('ds-btnGhost')) el.classList.add('ds-btn');}); }catch(_){ }
    try{ document.querySelectorAll('[data-chip], .chip').forEach(function(el){ el.classList.add('ds-chip');}); }catch(_){ }
    try{ document.querySelectorAll('[data-ds="card"]').forEach(function(el){ el.classList.add('ds-card');}); }catch(_){ }
    try{ document.querySelectorAll('input, textarea, select').forEach(function(el){ el.classList.add('ds-input');}); }catch(_){ }
  }
  function applyBG(){
    try{
      var enforce = (document.body && document.body.getAttribute('data-bg') === 'simple');
      if(!enforce) return; // do not override page-specific gradients unless explicitly requested
      var st=document.getElementById('ds-bg');
      if(!st){ st=document.createElement('style'); st.id='ds-bg'; document.head.appendChild(st); }
      st.textContent = 'body{background:var(--bg)!important;color:var(--fg)!important}';
    }catch(_){ }
  }
  window.DS = window.DS || {};
  window.DS.setAccent = setAccent;
  window.DS.apply = apply;
  window.DS.applyBG = applyBG;
  // Auto-accent from body data-accent
  try{ var acc=document.body && document.body.getAttribute('data-accent'); if(acc) setAccent(acc); }catch(_){ }
  applyBG();
  apply();
})();
"""
    return Response(content=js, media_type="application/javascript")

@app.get("/agriculture", response_class=HTMLResponse)
def agriculture_page(request: Request):
    if not _auth_phone(request):
        return RedirectResponse(url="/login", status_code=303)
    html = """
<!doctype html>
<html><head><meta name=viewport content="width=device-width, initial-scale=1" />
<title>Agriculture Operator</title>
<link rel="icon" href="/icons/agriculture.svg" />
<link rel="manifest" href="/agriculture/manifest.json" />
<style>
  body{font-family:sans-serif;margin:20px;max-width:820px;background:#ffffff;color:#000000;}
  input,button{font-size:14px;padding:6px;margin:4px 0}
  input{background:#ffffff;border:1px solid #cccccc;border-radius:4px;color:#000000}
  button{border:1px solid #cccccc;background:#f3f4f6;border-radius:4px;color:#000000;box-shadow:none}
  pre{background:#f5f5f5;padding:8px;white-space:pre-wrap;border-radius:4px;border:1px solid #dddddd}
</style>
</head><body>
<div style="position:sticky;top:0;z-index:10;background:#ffffff;padding:8px 10px;border-bottom:1px solid #dddddd;margin:0 0 12px 0;display:flex;align-items:center;gap:8px"><div style="flex:1;font-weight:600">Agriculture (Operator)</div></div>
<p>Stub dashboard. When the API is available this page will surface listings/orders/quotes.</p>
<div>
  <button onclick="health()">Check Health</button>
  <pre id=out></pre>
</div>
<script>
async function health(){ try{ const r=await fetch('/agriculture/health'); document.getElementById('out').textContent=await r.text(); }catch(e){ document.getElementById('out').textContent='Error: '+e; } }
</script>
</body></html>
"""
    return HTMLResponse(content=html)


@app.get("/commerce", response_class=HTMLResponse)
def commerce_page(request: Request):
    if not _auth_phone(request):
        return RedirectResponse(url="/login", status_code=303)
    html = """
<!doctype html>
<html><head><meta name=viewport content="width=device-width, initial-scale=1" />
<title>Commerce Operator</title>
<link rel="icon" href="/icons/commerce.svg" />
<link rel="manifest" href="/commerce/manifest.json" />
<style>
  body{font-family:sans-serif;margin:20px;max-width:820px;background:#ffffff;color:#000000;}
  input,button{font-size:14px;padding:6px;margin:4px 0}
  input{background:#ffffff;border:1px solid #cccccc;border-radius:4px;color:#000000}
  button{border:1px solid #cccccc;background:#f3f4f6;border-radius:4px;color:#000000;box-shadow:none}
  pre{background:#f5f5f5;padding:8px;white-space:pre-wrap;border-radius:4px;border:1px solid #dddddd}
</style>
</head><body>
<div style="position:sticky;top:0;z-index:10;background:#ffffff;padding:8px 10px;border-bottom:1px solid #dddddd;margin:0 0 12px 0;display:flex;align-items:center;gap:8px"><div style="flex:1;font-weight:600">Commerce (Operator)</div></div>
<p>Stub dashboard. Planned modules: catalog, carts, orders, payouts.</p>
<div>
  <button onclick="health()">Check Health</button>
  <pre id=out></pre>
</div>
<script>
async function health(){ try{ const r=await fetch('/commerce/health'); document.getElementById('out').textContent=await r.text(); }catch(e){ document.getElementById('out').textContent='Error: '+e; } }
</script>
</body></html>
"""
    return HTMLResponse(content=html)


@app.get("/doctors", response_class=HTMLResponse)
def doctors_page():
    html = """
<!doctype html>
<html><head><meta name=viewport content="width=device-width, initial-scale=1" />
<title>Doctors · Booking</title>
<link rel="icon" href="/icons/doctors.svg" />
<style>
  :root { --accent:#f43f5e; --bg:#0b1520; --panel:#111c29; --muted:#9fb0c7; --border:#1e2a38; --card:#0e1926; }
  *{box-sizing:border-box;}
  body{margin:0;padding:24px;font-family:"Inter",-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;background:linear-gradient(135deg,#0b1520 0%,#0d1b2b 45%,#0f2238 100%);color:#e8f0ff;}
  h1,h2{margin:0 0 10px 0;font-weight:700;letter-spacing:-0.01em;}
  p{margin:6px 0 14px 0;color:var(--muted);}
  .shell{max-width:1080px;margin:0 auto;}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px;align-items:start;}
  .card{background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:16px;box-shadow:0 18px 40px rgba(0,0,0,0.35);}
  label{display:block;font-size:13px;color:var(--muted);margin-bottom:4px;}
  input,select,button,textarea{width:100%;border-radius:10px;border:1px solid var(--border);background:var(--card);color:#e8f0ff;font-size:14px;padding:10px;}
  button{background:var(--accent);border-color:transparent;font-weight:600;cursor:pointer;transition:transform .08s ease, box-shadow .12s ease;}
  button:hover{transform:translateY(-1px);box-shadow:0 10px 25px rgba(244,63,94,0.35);}
  .row{display:flex;gap:8px;}
  .row > *{flex:1;}
  .list{display:flex;flex-direction:column;gap:10px;}
  .item{padding:12px;border:1px solid var(--border);border-radius:12px;background:var(--card);}
  .pill{display:inline-flex;align-items:center;padding:3px 8px;border-radius:999px;border:1px solid var(--border);font-size:12px;color:var(--muted);}
  .slots{display:flex;flex-wrap:wrap;gap:8px;}
  .slot{padding:10px 12px;border-radius:10px;border:1px solid var(--border);background:var(--card);cursor:pointer;transition:all .1s ease;}
  .slot:hover{border-color:var(--accent);color:#fff;}
  .muted{color:var(--muted);}
  pre{white-space:pre-wrap;word-break:break-word;}
  @media(max-width:900px){ .grid{grid-template-columns:1fr;} body{padding:14px;} }
</style>
</head><body>
<div class="shell">
  <div style="display:flex;align-items:center;gap:12px;margin-bottom:16px;">
    <div style="width:38px;height:38px;border-radius:10px;background:rgba(244,63,94,0.12);border:1px solid rgba(244,63,94,0.3);display:grid;place-items:center;font-weight:700;color:#fff;">DR</div>
    <div>
      <h1 style="margin:0;">Doctors</h1>
      <p style="margin:0;">Search, pick a slot, book, reschedule or cancel — Doctolib-style.</p>
    </div>
    <div style="flex:1;"></div>
    <button style="width:auto;padding:10px 14px;" onclick="health()">Health</button>
  </div>

  <div class="grid">
    <div class="card">
      <h2>Search doctors</h2>
      <div class="row">
        <div>
          <label>Name</label>
          <input id="q" placeholder="e.g. Müller" />
        </div>
        <div>
          <label>Speciality</label>
          <input id="speciality" placeholder="e.g. Allgemeinmedizin" />
        </div>
      </div>
      <div class="row">
        <div>
          <label>City</label>
          <input id="city" placeholder="e.g. Berlin" />
        </div>
        <div style="align-self:flex-end;">
          <button onclick="loadDoctors()">Search</button>
        </div>
      </div>
      <div id="doctors" class="list" style="margin-top:10px;"></div>
    </div>

    <div class="card">
      <h2>Book appointment</h2>
      <label>Selected doctor</label>
      <div id="selectedDoctor" class="pill">None</div>
      <div style="margin-top:10px;">
        <label>Slot</label>
        <div id="slots" class="slots"></div>
      </div>
      <div class="row" style="margin-top:10px;">
        <div><label>Patient name</label><input id="pname" /></div>
        <div><label>Phone</label><input id="pphone" /></div>
      </div>
      <div class="row">
        <div><label>Email</label><input id="pemail" /></div>
        <div><label>Reason</label><input id="preason" placeholder="optional" /></div>
      </div>
      <div class="row">
        <div><label>Duration (min)</label><input id="pduration" type="number" value="20" /></div>
        <div style="align-self:flex-end;"><button onclick="book()">Book</button></div>
      </div>
      <div id="bookResult" class="muted" style="margin-top:10px;"></div>
    </div>
  </div>

  <div class="card" style="margin-top:16px;">
    <h2>Manage existing appointment</h2>
    <div class="row">
      <div><label>Appointment ID</label><input id="apptId" placeholder="hex id returned on booking" /></div>
      <div><label>New slot (ISO)</label><input id="rescheduleTs" placeholder="2024-10-01T09:20:00+02:00" /></div>
      <div><label>New duration (min)</label><input id="rescheduleDur" type="number" /></div>
    </div>
    <div class="row" style="margin-top:8px;">
      <button onclick="reschedule()">Reschedule</button>
      <button onclick="cancelAppt()" style="background:#0f2238;border:1px solid var(--border);">Cancel</button>
    </div>
    <div id="apptResult" class="muted" style="margin-top:10px;"></div>
  </div>

  <div class="card" style="margin-top:16px;">
    <h2>Raw output</h2>
    <pre id="out">Ready</pre>
  </div>
</div>

<script>
let currentDoctor=null;
async function health(){ try{ const r=await fetch('/doctors/health'); document.getElementById('out').textContent=await r.text(); }catch(e){ document.getElementById('out').textContent='Error: '+e; } }

function renderDoctors(list){
  const el=document.getElementById('doctors'); el.innerHTML='';
  if(!list.length){ el.innerHTML='<div class="muted">No doctors found.</div>'; return; }
  list.forEach(d=>{
    const div=document.createElement('div'); div.className='item';
    div.innerHTML=`
      <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;">
        <div>
          <div style="font-weight:700">\\${d.name}</div>
          <div class="muted">\\${d.speciality||'—'} · \\${d.city||'—'} · \\${d.timezone}</div>
        </div>
        <button style="width:auto;padding:8px 12px;" onclick='selectDoctor(\\${d.id}, "\\${d.name.replace(/\"/g,'')}" )'>Select</button>
      </div>`;
    el.appendChild(div);
  });
}

async function loadDoctors(){
  const q=document.getElementById('q').value.trim();
  const city=document.getElementById('city').value.trim();
  const sp=document.getElementById('speciality').value.trim();
  const params=new URLSearchParams({limit:50});
  if(q) params.set('q',q);
  if(city) params.set('city',city);
  if(sp) params.set('speciality',sp);
  try{
    const r=await fetch('/doctors/doctors?'+params.toString());
    const data=await r.json();
    renderDoctors(data);
    document.getElementById('out').textContent=JSON.stringify(data,null,2);
  }catch(e){ document.getElementById('out').textContent='Error: '+e; }
}

async function selectDoctor(id,name){
  currentDoctor=id;
  document.getElementById('selectedDoctor').textContent=name+' (#'+id+')';
  document.getElementById('slots').innerHTML='<div class="muted">Loading slots…</div>';
  try{
    const r=await fetch('/doctors/slots?doctor_id='+id+'&days=7');
    const slots=await r.json();
    renderSlots(slots);
    document.getElementById('out').textContent=JSON.stringify(slots,null,2);
  }catch(e){ document.getElementById('slots').innerHTML='<div class="muted">Error loading slots</div>'; }
}

function renderSlots(slots){
  const el=document.getElementById('slots'); el.innerHTML='';
  if(!slots.length){ el.innerHTML='<div class="muted">No upcoming slots</div>'; return; }
  slots.slice(0,60).forEach(s=>{
    const div=document.createElement('div'); div.className='slot';
    const t=new Date(s.ts_iso);
    div.textContent=t.toLocaleString(undefined,{weekday:'short', month:'short', day:'numeric', hour:'2-digit', minute:'2-digit'});
    div.onclick=()=>{ document.getElementById('slots').querySelectorAll('.slot').forEach(n=>n.style.borderColor='var(--border)'); div.style.borderColor='var(--accent)'; div.dataset.selected='1'; document.getElementById('bookResult').textContent='Selected '+s.ts_iso; document.getElementById('bookResult').dataset.ts=s.ts_iso; document.getElementById('pduration').value=s.duration_minutes; };
    el.appendChild(div);
  });
}

async function book(){
  if(!currentDoctor){ document.getElementById('bookResult').textContent='Select a doctor first'; return; }
  const ts=document.getElementById('bookResult').dataset.ts;
  if(!ts){ document.getElementById('bookResult').textContent='Select a slot first'; return; }
  const body={
    doctor_id: currentDoctor,
    patient_name: document.getElementById('pname').value || null,
    patient_phone: document.getElementById('pphone').value || null,
    patient_email: document.getElementById('pemail').value || null,
    reason: document.getElementById('preason').value || null,
    ts_iso: ts,
    duration_minutes: parseInt(document.getElementById('pduration').value||'20',10)
  };
  try{
    const r=await fetch('/doctors/appointments',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(body)});
    const data=await r.json();
    document.getElementById('bookResult').textContent='Booked: '+data.id;
    document.getElementById('apptId').value=data.id;
    document.getElementById('out').textContent=JSON.stringify(data,null,2);
  }catch(e){ document.getElementById('bookResult').textContent='Error '+e; }
}

async function cancelAppt(){
  const id=document.getElementById('apptId').value.trim();
  if(!id){ document.getElementById('apptResult').textContent='Enter appointment id'; return; }
  try{
    const r=await fetch('/doctors/appointments/'+id+'/cancel',{method:'POST'});
    const data=await r.json();
    document.getElementById('apptResult').textContent='Canceled';
    document.getElementById('out').textContent=JSON.stringify(data,null,2);
  }catch(e){ document.getElementById('apptResult').textContent='Error '+e; }
}

async function reschedule(){
  const id=document.getElementById('apptId').value.trim();
  if(!id){ document.getElementById('apptResult').textContent='Enter appointment id'; return; }
  const ts=document.getElementById('rescheduleTs').value.trim();
  if(!ts){ document.getElementById('apptResult').textContent='Enter new ts_iso'; return; }
  const dur=document.getElementById('rescheduleDur').value.trim();
  const body={ ts_iso: ts };
  if(dur){ body.duration_minutes=parseInt(dur,10); }
  try{
    const r=await fetch('/doctors/appointments/'+id+'/reschedule',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(body)});
    const data=await r.json();
    document.getElementById('apptResult').textContent='Rescheduled';
    document.getElementById('out').textContent=JSON.stringify(data,null,2);
  }catch(e){ document.getElementById('apptResult').textContent='Error '+e; }
}

loadDoctors();
</script>
</body></html>
"""
    return HTMLResponse(content=html)


@app.get("/flights", response_class=HTMLResponse)
def flights_page(request: Request):
    if not _auth_phone(request):
        return RedirectResponse(url="/login", status_code=303)
    html = """
<!doctype html>
<html><head><meta name=viewport content="width=device-width, initial-scale=1" />
<title>Flights Operator</title>
<link rel="icon" href="/icons/flights.svg" />
<link rel="manifest" href="/flights/manifest.json" />
<style>
  body{font-family:sans-serif;margin:20px;max-width:820px;background:#ffffff;color:#000000;}
  input,button{font-size:14px;padding:6px;margin:4px 0}
  input{background:#ffffff;border:1px solid #cccccc;border-radius:4px;color:#000000}
  button{border:1px solid #cccccc;background:#f3f4f6;border-radius:4px;color:#000000;box-shadow:none}
  pre{background:#f5f5f5;padding:8px;white-space:pre-wrap;border-radius:4px;border:1px solid #dddddd}
</style>
</head><body>
<div style="position:sticky;top:0;z-index:10;background:#ffffff;padding:8px 10px;border-bottom:1px solid #dddddd;margin:0 0 12px 0;display:flex;align-items:center;gap:8px"><div style="flex:1;font-weight:600">Flights (Operator)</div></div>
<p>Stub dashboard. Planned modules: flights, quotes, bookings, tickets.</p>
<div>
  <button onclick="health()">Check Health</button>
  <pre id=out></pre>
</div>
<script>
async function health(){ try{ const r=await fetch('/flights/health'); document.getElementById('out').textContent=await r.text(); }catch(e){ document.getElementById('out').textContent='Error: '+e; } }
</script>
</body></html>
"""
    return HTMLResponse(content=html)


@app.get("/jobs", response_class=HTMLResponse)
def jobs_page(request: Request):
    if not _auth_phone(request):
        return RedirectResponse(url="/login", status_code=303)
    html = """
<!doctype html>
<html><head><meta name=viewport content="width=device-width, initial-scale=1" />
<title>Jobs Operator</title>
<link rel="icon" href="/icons/jobs.svg" />
<link rel="manifest" href="/jobs/manifest.json" />
<style>
  body{font-family:sans-serif;margin:20px;max-width:820px;background:#ffffff;color:#000000;}
  input,button{font-size:14px;padding:6px;margin:4px 0}
  input{background:#ffffff;border:1px solid #cccccc;border-radius:4px;color:#000000}
  button{border:1px solid #cccccc;background:#f3f4f6;border-radius:4px;color:#000000;box-shadow:none}
  pre{background:#f5f5f5;padding:8px;white-space:pre-wrap;border-radius:4px;border:1px solid #dddddd}
</style>
</head><body>
<div style="position:sticky;top:0;z-index:10;background:#ffffff;padding:8px 10px;border-bottom:1px solid #dddddd;margin:0 0 12px 0;display:flex;align-items:center;gap:8px"><div style="flex:1;font-weight:600">Jobs (Operator)</div></div>
<p>Stub dashboard. Planned modules: jobs, candidates, applications.</p>
<div>
  <button onclick="health()">Check Health</button>
  <pre id=out></pre>
</div>
<script>
async function health(){ try{ const r=await fetch('/jobs/health'); document.getElementById('out').textContent=await r.text(); }catch(e){ document.getElementById('out').textContent='Error: '+e; } }
</script>
</body></html>
"""
    return HTMLResponse(content=html)


@app.get("/livestock", response_class=HTMLResponse)
def livestock_page(request: Request):
    if not _auth_phone(request):
        return RedirectResponse(url="/login", status_code=303)
    html = """
<!doctype html>
<html><head><meta name=viewport content="width=device-width, initial-scale=1" />
<title>Livestock Operator</title>
<link rel="icon" href="/icons/livestock.svg" />
<link rel="manifest" href="/livestock/manifest.json" />
<style>
  body{font-family:sans-serif;margin:20px;max-width:820px;background:#ffffff;color:#000000;}
  input,button{font-size:14px;padding:6px;margin:4px 0}
  input{background:#ffffff;border:1px solid #cccccc;border-radius:4px;color:#000000}
  button{border:1px solid #cccccc;background:#f3f4f6;border-radius:4px;color:#000000;box-shadow:none}
  pre{background:#f5f5f5;padding:8px;white-space:pre-wrap;border-radius:4px;border:1px solid #dddddd}
</style>
</head><body>
<div style="position:sticky;top:0;z-index:10;background:#ffffff;padding:8px 10px;border-bottom:1px solid #dddddd;margin:0 0 12px 0;display:flex;align-items:center;gap:8px"><div style="flex:1;font-weight:600">Livestock (Operator)</div></div>
<p>Stub dashboard. Planned modules: listings, quotes, shipments.</p>
<div>
  <button onclick="health()">Check Health</button>
  <pre id=out></pre>
</div>
<script>
async function health(){ try{ const r=await fetch('/livestock/health'); document.getElementById('out').textContent=await r.text(); }catch(e){ document.getElementById('out').textContent='Error: '+e; } }
</script>
</body></html>
"""
    return HTMLResponse(content=html)


@app.get("/chat", response_class=HTMLResponse)
def chat_page():
    return _legacy_console_removed_page("Shamell · Chat")
    html = """
<!doctype html>
<html><head><meta name=viewport content="width=device-width, initial-scale=1" />
<title>Chat (E2E)</title>
<script src="https://cdn.jsdelivr.net/npm/tweetnacl/nacl-fast.min.js"></script>
<style>body{font-family:sans-serif;margin:20px;max-width:800px} input,button,textarea{font-size:14px;padding:6px;margin:4px 0} textarea{width:100%;height:80px} pre{background:#f4f4f4;padding:8px;white-space:pre-wrap}</style>
</head><body>
<h1>Chat (Threema‑style E2E)</h1>
<section>
  <h2>Your Identity</h2>
  <div>
    <button onclick="gen()">Generate Keys</button>
    <input id=myid placeholder="Your ID (e.g. 8-12 chars)" />
    <input id=myname placeholder="Display name" />
    <button onclick="registerDev()">Register</button>
    <pre id=me></pre>
  </div>
  <div>
    <h3>Share</h3>
    <pre id=share></pre>
    <div id=qr></div>
    <div>
      <small>My fingerprint: <code id=myfp></code></small>
    </div>
    <button onclick="scanStart()">Scan Peer QR</button>
    <div id=scanner style="width:260px;height:220px"></div>
  </div>
</section>
<section>
  <h2>Contact</h2>
  <input id=peerid placeholder="Peer ID" />
  <button onclick="resolvePeer()">Fetch peer key</button>
  <pre id=peer></pre>
  <div>
    <small>Peer fingerprint: <code id=peerfp></code> · Verified: <span id=verif>no</span></small>
    <div><button onclick="markVerified()">Mark verified</button></div>
  </div>
</section>
<section>
  <h2>Send message</h2>
  <textarea id=plain placeholder="Message..."></textarea>
  <button onclick="sendMsg()">Send</button>
  <pre id=sendout></pre>
</section>
<section>
  <h2>Inbox</h2>
  <button onclick="poll()">Poll</button>
  <small>WS: <span id=live>disconnected</span></small>
  <pre id=inbox></pre>
</section>
<script src="https://unpkg.com/html5-qrcode@2.3.10/html5-qrcode.min.js"></script>
<script>
let my = {pk:null, sk:null, id:null, name:null};
let peers = {}; // id -> pk (base64)
let ws = null;

function b64(u8){ return btoa(String.fromCharCode.apply(null, Array.from(u8))); }
function unb64(s){ return new Uint8Array(atob(s).split('').map(c=>c.charCodeAt(0))); }

function gen(){
  const kp = nacl.box.keyPair();
  my.pk = kp.publicKey; my.sk = kp.secretKey;
  document.getElementById('me').textContent = 'PublicKey(b64)=' + b64(my.pk);
  const id = (Math.random().toString(36).slice(2,10));
  document.getElementById('myid').value = id; my.id = id;
  const payload = 'CHAT|id='+id+'|pk='+b64(my.pk);
  document.getElementById('share').textContent = payload;
  makeQR(payload);
  updateMyFp();
  connectWS();
}

async function registerDev(){
  const id = (document.getElementById('myid').value||'').trim(); my.id=id;
  const name = (document.getElementById('myname').value||'').trim(); my.name=name;
  if(!my.pk){ alert('Generate keys'); return; }
  const body = {device_id:id, public_key_b64:b64(my.pk), name:name||null};
  const r = await fetch('/chat/devices/register',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)});
  document.getElementById('me').textContent = await r.text();
  // connect WS after registration
  connectWS();
}

async function resolvePeer(){
  const id = (document.getElementById('peerid').value||'').trim();
  const r = await fetch('/chat/devices/'+encodeURIComponent(id));
  const j = await r.json(); peers[id] = j.public_key_b64; document.getElementById('peer').textContent = JSON.stringify(j,null,2);
  updatePeerFp();
}

async function sendMsg(){
  const id = (document.getElementById('peerid').value||'').trim(); const pkb64 = peers[id]; if(!pkb64){ alert('resolve peer first'); return; }
  const msg = (document.getElementById('plain').value||'');
  const nonce = nacl.randomBytes(24);
  const peerPk = unb64(pkb64);
  const box = nacl.box(new TextEncoder().encode(msg), nonce, peerPk, my.sk);
  const body = {sender_id: my.id, recipient_id: id, sender_pubkey_b64: b64(my.pk), nonce_b64: b64(nonce), box_b64: b64(box)};
  const r = await fetch('/chat/messages/send',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)});
  document.getElementById('sendout').textContent = await r.text();
}

async function poll(){
  const r = await fetch('/chat/messages/inbox?device_id='+encodeURIComponent(my.id)+'&limit=20');
  const arr = await r.json();
  const out=[];
  for(const m of arr.reverse()){
    try{
      const nonce = unb64(m.nonce_b64); const box = unb64(m.box_b64); const spk = unb64(m.sender_pubkey_b64);
      const plain = nacl.box.open(box, nonce, spk, my.sk);
      out.push({from:m.sender_id, text:(plain? new TextDecoder().decode(plain):'<decrypt failed>')});
      try{ await fetch('/chat/messages/'+encodeURIComponent(m.id)+'/read',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({read:true})}); }catch(_){ }
    }catch(e){ out.push({from:m.sender_id, text:'<error>'}); }
  }
  document.getElementById('inbox').textContent = JSON.stringify(out,null,2);
}
// Graphical QR (same mini generator used on Merchant page)
/* eslint-disable */
!function(o){function r(o){this.mode=n.MODE_8BIT_BYTE,this.data=o,this.parsedData=[];for(var r=0,l=this.data.length;r<l;r++){var t=[],h=this.data.charCodeAt(r);h>65536?(t[0]=240|(1835008&h)>>>18,t[1]=128|(258048&h)>>>12,t[2]=128|(4032&h)>>>6,t[3]=128|63&h):h>2048?(t[0]=224|(61440&h)>>>12,t[1]=128|(4032&h)>>>6,t[2]=128|63&h):h>128?(t[0]=192|(1984&h)>>>6,t[1]=128|63&h):t[0]=h,this.parsedData.push(t)}this.parsedData=Array.prototype.concat.apply([],this.parsedData),this.parsedData.length!=this.data.length&&(this.parsedData.unshift(191),this.parsedData.unshift(187),this.parsedData.unshift(239))}function l(o,r){this.typeNumber=o,this.errorCorrectLevel=r,this.modules=null,this.moduleCount=0,this.dataCache=null,this.dataList=[]}var n={PAD0:236,PAD1:17,MODE_8BIT_BYTE:4};r.prototype={getLength:function(){return this.parsedData.length},write:function(o){for(var r=0,l=this.parsedData.length;r<l;r++)o.put(this.parsedData[r],8)}},l.prototype={addData:function(o){this.dataList.push(new r(o)),this.dataCache=null},isDark:function(o,r){if(o<0||this.moduleCount<=o||r<0||this.moduleCount<=r)throw new Error(o+","+r);return this.modules[o][r]},getModuleCount:function(){return this.moduleCount},make:function(){this.makeImpl(!1,this.getBestMaskPattern())},makeImpl:function(o,r){this.moduleCount=21,this.modules=new Array(this.moduleCount);for(var l=0;l<this.moduleCount;l++){this.modules[l]=new Array(this.moduleCount);for(var n=0;n<this.moduleCount;n++)this.modules[l][n]=null}this.setupPositionProbePattern(0,0),this.setupPositionProbePattern(this.moduleCount-7,0),this.setupPositionProbePattern(0,this.moduleCount-7),this.mapData(this.createData(this.typeNumber,this.errorCorrectLevel,r),r)},setupPositionProbePattern:function(o,r){for(var l=-1;l<=7;l++)if(!(o+l<=-1||this.moduleCount<=o+l))for(var n=-1;n<=7;n++)r+n<=-1||this.moduleCount<=r+n||(this.modules[o+l][r+n]=l>=0&&l<=6&&(0==n||6==n)||n>=0&&n<=6&&(0==l||6==l)||l>=2&&l<=4&&n>=2&&n<=4)},getBestMaskPattern:function(){return 0},createData:function(o,r){for(var l=[],n=0;n<this.dataList.length;n++){var t=this.dataList[n];l.push(4),l.push(t.getLength()),l=l.concat(t.parsedData)}for(l.push(236),l.push(17),l.push(236),l.push(17);l.length<19;)l.push(0);return l.slice(0,19)},mapData:function(o,r){for(var l=0;l<this.moduleCount;l++)for(var n=0;n<this.moduleCount;n++)if(null===this.modules[l][n]){var t=!((l+n)%3);this.modules[l][n]=t}},createImgTag:function(o,r){o=o||2,r=r||0;var l=this.getModuleCount()*o+2*r,n=l,t='<img src="'+this.createDataURL(o,r)+'" width="'+l+'" height="'+n+'"/>';return t},createDataURL:function(o,r){o=o||2,r=r||0;var l=this.getModuleCount()*o+2*r,n=l,t=o,h=r,e=h,i=Math.round(255);for(var a="GIF89a",u=String.fromCharCode,d=a+u(0)+u(0)+u(0)+u(0)+"\x00\x00\xF7\x00\x00",s=0;s<16;s++){var c=s?0:i;d+=u(c)+u(c)+u(c)}d+="\x2C\x00\x00\x00\x00"+u(0)+u(0)+"\x00\x00\x00\x00\x02";for(var f=1;f<l;f++){var g="";for(var p=0;p<n;p++){var m=this.isDark(Math.floor((p-r)/o),Math.floor((f-h)/o))?0:1;g+=m?"\x01":"\x00"}d+=u(g.length)+g}return 'data:image/gif;base64,'+btoa(d)}};
function makeQR(text){ const qr = new l(1,0); qr.addData(text); qr.make(); const el=document.getElementById('qr'); el.innerHTML=qr.createImgTag(4,2); }
/* eslint-enable */
async function scanStart(){
  try{
    const el = document.getElementById('scanner');
    const html5QrCode = new Html5Qrcode(el.id);
    await html5QrCode.start({ facingMode: "environment" }, { fps: 10, qrbox: 200 }, (decodedText)=>{
      try{
        if(decodedText && decodedText.startsWith('CHAT|')){
          const parts = decodedText.split('|');
          const map={}; for(const p of parts.slice(1)){ const kv=p.split('='); if(kv.length==2) map[kv[0]]=kv[1]; }
          if(map['id'] && map['pk']){ peers[map['id']] = map['pk']; document.getElementById('peerid').value = map['id']; document.getElementById('peer').textContent = JSON.stringify({device_id:map['id'], public_key_b64:map['pk']},null,2); updatePeerFp(); html5QrCode.stop(); }
        }
      }catch(_){ }
    });
  }catch(e){ alert('scan error: '+e); }
}

// Fingerprints and verification
async function sha256(b){
  try{ const d = await crypto.subtle.digest('SHA-256', (b instanceof Uint8Array)? b : new TextEncoder().encode(b)); return new Uint8Array(d); }catch(_){ return null; }
}
function toHex(u8){ return Array.from(u8).map(x=>x.toString(16).padStart(2,'0')).join(''); }
async function computeFpB64(pkB64){ try{ const u = unb64(pkB64); const d = await sha256(u); if(d){ return toHex(d).slice(0,16); } }catch(_){ } return (pkB64||'').slice(0,16); }
async function updateMyFp(){ try{ const fp = await computeFpB64(b64(my.pk)); document.getElementById('myfp').textContent = fp; }catch(_){ } }
async function updatePeerFp(){ try{ const pid=(document.getElementById('peerid').value||'').trim(); const pkb64=peers[pid]; if(!pkb64){ return; } const fp=await computeFpB64(pkb64); document.getElementById('peerfp').textContent = fp; document.getElementById('verif').textContent = (isVerified(pid,fp)?'yes':'no'); }catch(_){ } }
function isVerified(pid, fp){ try{ return localStorage.getItem('verified_peer_'+pid) === fp; }catch(_){ return false; } }
async function markVerified(){ const pid=(document.getElementById('peerid').value||'').trim(); const pkb64=peers[pid]; if(!pid||!pkb64){ alert('resolve/scan peer first'); return; } const fp=await computeFpB64(pkb64); try{ localStorage.setItem('verified_peer_'+pid, fp); document.getElementById('verif').textContent='yes'; }catch(_){ } }

// WebSocket live inbox
function connectWS(){ try{ if(!my.id){ return; } if(ws && (ws.readyState===1||ws.readyState===0)){ return; }
  const base = (location.protocol==='https:'?'wss://':'ws://')+location.host;
  ws = new WebSocket(base+'/ws/chat/inbox?device_id='+encodeURIComponent(my.id));
  const live = document.getElementById('live');
  ws.onopen = ()=>{ if(live) live.textContent='connected'; };
  ws.onclose = ()=>{ if(live) live.textContent='disconnected'; };
  ws.onerror = ()=>{ if(live) live.textContent='error'; };
  ws.onmessage = async (ev)=>{
    try{
      const msg = JSON.parse(ev.data);
      if(msg && msg.type==='inbox' && Array.isArray(msg.messages)){
        const outEl = document.getElementById('inbox');
        const out = [];
        for(const m of msg.messages){
          try{
            const nonce = unb64(m.nonce_b64); const box = unb64(m.box_b64); const spk = unb64(m.sender_pubkey_b64);
            const plain = nacl.box.open(box, nonce, spk, my.sk);
            out.push({from:m.sender_id, text:(plain? new TextDecoder().decode(plain):'<decrypt failed>')});
            try{ await fetch('/chat/messages/'+encodeURIComponent(m.id)+'/read',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({read:true})}); }catch(_){ }
          }catch(e){ out.push({from:m.sender_id, text:'<error>'}); }
        }
        // append to existing
        try{ const prev = outEl.textContent? JSON.parse(outEl.textContent):[]; outEl.textContent = JSON.stringify(prev.concat(out), null, 2); }catch(_){ outEl.textContent = JSON.stringify(out, null, 2); }
      }
    }catch(_){ }
  };
}catch(_){ }
}
</script>
</body></html>
"""
    return HTMLResponse(content=html)


@app.get("/web/mirsaal", response_class=HTMLResponse)
def web_mirsaal_readonly(request: Request) -> HTMLResponse:
    """
    Sehr leichtgewichtige Web-Shell für Mirsaal (read-only Stub).

    Dient primär als Einstiegspunkt für zukünftige Multi-Device/Web
    Features und verknüpft den bestehenden OTP-Login via sa_session.
    """
    base = request.base_url._url.rstrip("/")  # type: ignore[attr-defined]
    html = """
<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Mirsaal · Web (read‑only)</title>
    <style>
      body {{ font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif; margin: 20px; max-width: 960px; color:#0f172a; background:#ffffff; }}
      h1 {{ margin-bottom: 4px; }}
      h2 {{ margin-top: 20px; margin-bottom: 6px; }}
      p {{ margin: 4px 0; }}
      code {{ background:#f3f4f6; padding:2px 4px; border-radius:3px; font-size:12px; }}
      .muted {{ color:#6b7280; font-size:13px; }}
      ul {{ padding-left:20px; }}
    </style>
  </head>
  <body>
    <h1>Mirsaal · Web (read‑only preview)</h1>
    <p class="muted">
      Dies ist eine erste Vorschau für Mirsaal im Browser – der Fokus liegt
      aktuell auf OTP‑Login und Multi‑Device‑Sessions. Der eigentliche Chat‑Feed
      bleibt in dieser Version noch in der mobilen App.
    </p>

    <h2>Login</h2>
    <p>
      Öffne die Shamell App, melde dich per OTP an und öffne dann
      <code>{base}/web/mirsaal?sa_session=&lt;SESSION&gt;</code> im Browser.
      Die Session‑ID wird von <code>/auth/verify</code> auch im JSON‑Body
      zurückgegeben (<code>session</code> Feld) und kann so an Web‑Clients
      weitergegeben werden.
    </p>

    <h2>Moments‑Feed (read‑only)</h2>
    <p class="muted">
      Unten siehst du eine vereinfachte Moments‑Liste auf Basis des
      JSON‑Feeds <code>/moments/feed</code>. Inhalte sind read‑only, das
      Posten erfolgt weiterhin in der mobilen App.
    </p>
    <div id="moments">
      <p class="muted">Lade Moments…</p>
    </div>

    <script>
      async function loadMoments(){
        const out = document.getElementById('moments');
        if(!out) return;
        out.innerHTML = '<p class="muted">Lade Moments…</p>';
        let headers = {};
        try{
          const params = new URLSearchParams(window.location.search || '');
          const sess = params.get('sa_session') || '';
          if(sess){
            headers['sa_cookie'] = 'sa_session=' + sess;
          }
        }catch(e){}
        try{
          const r = await fetch('/moments/feed?limit=30', {headers});
          if(!r.ok){
            out.innerHTML = '<p class="muted">Fehler beim Laden: ' + r.status + '</p>';
            return;
          }
          const j = await r.json();
          const items = Array.isArray(j) ? j : (Array.isArray(j.items)? j.items : []);
          if(!items.length){
            out.innerHTML = '<p class="muted">Noch keine Moments vorhanden.</p>';
            return;
          }
          const parts = [];
          parts.push('<ul>');
          for(const m of items){
            const txt = (m.text||'').toString();
            const ts = (m.ts||'').toString();
            const author = (m.author_name||'') || '';
            const likes = Number(m.likes||0);
            const comments = Number(m.comments||0);
            let meta = [];
            if(author) meta.push(author);
            if(ts) meta.push(ts);
            meta.push('♥ ' + likes);
            meta.push('💬 ' + comments);
            parts.push('<li><div><strong>' +
              (txt.length>120 ? txt.slice(0,117)+'…' : txt.replace(/</g,'&lt;').replace(/>/g,'&gt;')) +
              '</strong></div><div class="muted">' +
              meta.join(' · ') +
              '</div></li>');
          }
          parts.push('</ul>');
          out.innerHTML = parts.join('');
        }catch(e){
          out.innerHTML = '<p class="muted">Fehler: ' + e + '</p>';
        }
      }
      loadMoments();
    </script>
  </body>
</html>
"""
    html = html.format(base=base)
    return HTMLResponse(content=html)


@app.get("/taxi/driver", response_class=HTMLResponse)
def taxi_driver_page(request: Request):
    if not _auth_phone(request):
        return RedirectResponse(url="/login", status_code=303)
    html = """
<!doctype html>
<html><head><meta name=viewport content="width=device-width, initial-scale=1" />
<title>Taxi Driver Console</title>
<link rel="icon" href="/icons/taxi.svg" />
<style>
  body{font-family:sans-serif;margin:20px;max-width:760px;background:#ffffff;color:#000000;}
  input,button{font-size:14px;padding:6px;margin:4px 0}
  input{background:#ffffff;border:1px solid #cccccc;border-radius:4px;color:#000000}
  button{border:1px solid #cccccc;background:#f3f4f6;border-radius:4px;color:#000000;box-shadow:none}
  pre{background:#f5f5f5;padding:8px;white-space:pre-wrap;border-radius:4px;border:1px solid #dddddd}
</style>
</head><body>
<div style="position:sticky;top:0;z-index:10;background:#ffffff;padding:8px 10px;border-bottom:1px solid #dddddd;margin:0 0 12px 0;display:flex;align-items:center;gap:8px"><div style="flex:1;font-weight:600">Taxi Driver</div><small style="opacity:.8">Standalone</small></div>
<div>
  <h3>Register</h3>
  <input id=name placeholder="Name" />
  <input id=phone placeholder="Phone" />
  <input id=make placeholder="Vehicle make" />
  <input id=plate placeholder="Plate" />
  <button onclick="register()">Register</button>
  <pre id=regout></pre>
</div>
<div>
  <h3>Driver</h3>
  <input id=driver placeholder="driver_id" />
  <button onclick="saveDriver()">Save</button>
  <div>
    <input id=dwallet placeholder="driver wallet id" />
    <button onclick="setWallet()">Set wallet</button>
  </div>
  <button onclick="online()">Go online</button>
  <button onclick="offline()">Go offline</button>
  <pre id=dout></pre>
</div>
<div>
  <h3>Location</h3>
  <input id=lat placeholder="lat" />
  <input id=lon placeholder="lon" />
  <button onclick="updateLoc()">Update</button>
  <pre id=lout></pre>
</div>
<div>
  <h3>Active rides</h3>
  <button onclick="loadRides()">Refresh</button>
  <div>Live events: <span id=live>disconnected</span></div>
  <pre id=rides></pre>
</div>
<div>
  <h3>Ride Actions</h3>
  <input id=ride placeholder="ride_id" />
  <button onclick="accept()">Accept</button>
  <button onclick="start()">Start</button>
  <button onclick="complete()">Complete</button>
  <pre id=rout></pre>
</div>
<script>
function _did(){ let v=document.getElementById('driver').value; if(!v){ v=localStorage.getItem('driver_id')||''; document.getElementById('driver').value=v; } return v; }
function saveDriver(){ const v=document.getElementById('driver').value; localStorage.setItem('driver_id', v); }
async function register(){
  const body={name:gi('name'), phone:gi('phone'), vehicle_make:gi('make'), vehicle_plate:gi('plate')};
  const r=await fetch('/taxi/drivers',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); const j=await r.json(); document.getElementById('regout').textContent=JSON.stringify(j,null,2); document.getElementById('driver').value=j.id; saveDriver(); }
async function online(){ const id=_did(); const r=await fetch('/taxi/drivers/'+id+'/online',{method:'POST'}); document.getElementById('dout').textContent=await r.text(); }
async function setWallet(){ const id=_did(); const w=gi('dwallet'); const r=await fetch('/taxi/drivers/'+id+'/wallet',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({wallet_id:w})}); document.getElementById('dout').textContent=await r.text(); }
async function offline(){ const id=_did(); const r=await fetch('/taxi/drivers/'+id+'/offline',{method:'POST'}); document.getElementById('dout').textContent=await r.text(); }
async function updateLoc(){ const id=_did(); const body={lat:parseFloat(gi('lat')),lon:parseFloat(gi('lon'))}; const r=await fetch('/taxi/drivers/'+id+'/location',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); document.getElementById('lout').textContent=await r.text(); }
async function loadRides(){ const id=_did(); const r=await fetch('/taxi/drivers/'+id+'/rides?limit=10'); const j=await r.json(); document.getElementById('rides').textContent=JSON.stringify(j,null,2); }
async function accept(){ const id=_did(); const ride=gi('ride'); const r=await fetch('/taxi/rides/'+ride+'/accept?driver_id='+encodeURIComponent(id),{method:'POST'}); document.getElementById('rout').textContent=await r.text(); }
async function start(){ const id=_did(); const ride=gi('ride'); const r=await fetch('/taxi/rides/'+ride+'/start?driver_id='+encodeURIComponent(id),{method:'POST'}); document.getElementById('rout').textContent=await r.text(); }
async function complete(){ const id=_did(); const ride=gi('ride'); const r=await fetch('/taxi/rides/'+ride+'/complete?driver_id='+encodeURIComponent(id),{method:'POST'}); document.getElementById('rout').textContent=await r.text(); }
function gi(id){ return (document.getElementById(id).value||'').trim(); }
document.getElementById('driver').value=localStorage.getItem('driver_id')||'';
try{
  const drv = localStorage.getItem('driver_id')||'';
  if(drv){
    const es = new EventSource('/taxi/driver/events?driver_id='+encodeURIComponent(drv));
    es.onopen = ()=>{ document.getElementById('live').textContent='connected'; };
    es.onmessage = (ev)=>{
      try{ const j=JSON.parse(ev.data||'{}'); if(j.type==='rides'){ document.getElementById('rides').textContent = JSON.stringify(j.rides,null,2); } }catch(_){ }
    };
    es.onerror = ()=>{ document.getElementById('live').textContent='reconnecting'; };
  }
}catch(_){ }
</script>
</body></html>
"""
    return HTMLResponse(content=html)


@app.get("/taxi/rider", response_class=HTMLResponse)
def taxi_rider_page(request: Request):
    if not _auth_phone(request):
        return RedirectResponse(url="/login", status_code=303)
    html = """
<!doctype html>
<html><head><meta name=viewport content="width=device-width, initial-scale=1" />
<title>Taxi Rider Console</title>
<link rel="icon" href="/icons/taxi.svg" />
<style>
  body{font-family:sans-serif;margin:20px;max-width:760px;background:#ffffff;color:#000000;}
  input,button{font-size:14px;padding:6px;margin:4px 0}
  input{background:#ffffff;border:1px solid #cccccc;border-radius:4px;color:#000000}
  button{border:1px solid #cccccc;background:#f3f4f6;border-radius:4px;color:#000000;box-shadow:none}
  pre{background:#f5f5f5;padding:8px;white-space:pre-wrap;border-radius:4px;border:1px solid #dddddd}
</style>
</head><body>
<div style="position:sticky;top:-12px;z-index:10;backdrop-filter:blur(12px);background:rgba(255,255,255,.08);padding:8px 10px;border-radius:14px;border:1px solid rgba(255,255,255,.2);margin:-8px 0 12px 0;display:flex;align-items:center;gap:8px"><div style="flex:1;font-weight:600">Taxi Rider</div><small style="opacity:.8">Standalone</small></div>
<div>
  <h3>Request ride</h3>
  <input id=phone placeholder="Phone (optional)" />
  <input id=rwallet placeholder="Rider wallet id (optional)" />
  <input id=plat placeholder="pickup lat" />
  <input id=plon placeholder="pickup lon" />
  <input id=dlat placeholder="drop lat" />
  <input id=dlon placeholder="drop lon" />
  <div>
    <button onclick="quoteRide()">Quote (fare/ETA)</button>
    <pre id=qout></pre>
  </div>
  <button onclick="req()">Request</button>
  <button onclick="bookpay()">Book & Pay</button>
  <pre id=reqout></pre>
</div>
<div>
  <h3>Ride status</h3>
  <input id=ride placeholder="ride_id" />
  <button onclick="status()">Status</button>
  <button onclick="cancel()">Cancel</button>
  <pre id=rout></pre>
</div>
<script>
async function req(){
  const body={rider_phone:gi('phone')||null, rider_wallet_id:gi('rwallet')||null, pickup_lat:parseFloat(gi('plat')), pickup_lon:parseFloat(gi('plon')), dropoff_lat:parseFloat(gi('dlat')), dropoff_lon:parseFloat(gi('dlon'))};
  const r=await fetch('/taxi/rides/request',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)}); const j=await r.json(); document.getElementById('reqout').textContent=JSON.stringify(j,null,2); document.getElementById('ride').value=j.id; }
async function quoteRide(){
  const body={pickup_lat:parseFloat(gi('plat')), pickup_lon:parseFloat(gi('plon')), dropoff_lat:parseFloat(gi('dlat')), dropoff_lon:parseFloat(gi('dlon'))};
  const r=await fetch('/taxi/rides/quote',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)});
  document.getElementById('qout').textContent=await r.text();
}
async function bookpay(){
  const body={rider_phone:gi('phone')||null, rider_wallet_id:gi('rwallet')||null, pickup_lat:parseFloat(gi('plat')), pickup_lon:parseFloat(gi('plon')), dropoff_lat:parseFloat(gi('dlat')), dropoff_lon:parseFloat(gi('dlon'))};
  const r=await fetch('/taxi/rides/book_pay',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify(body)});
  const t=await r.text(); document.getElementById('reqout').textContent=t; try{ const j=JSON.parse(t); document.getElementById('ride').value=j.id; }catch(_){ }
}
async function status(){ const id=gi('ride'); const r=await fetch('/taxi/rides/'+id); document.getElementById('rout').textContent=await r.text(); }
async function cancel(){ const id=gi('ride'); const r=await fetch('/taxi/rides/'+id+'/cancel',{method:'POST'}); document.getElementById('rout').textContent=await r.text(); }
function gi(id){ return (document.getElementById(id).value||'').trim(); }
</script>
</body></html>
"""
    return HTMLResponse(content=html)


@app.post("/taxi/rides/quote")
async def taxi_quote(req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_taxi_internal():
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                req_model = _TaxiPreQuoteReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            return _call_taxi(
                _taxi_pre_quote,
                need_session=False,
                request_body=None,
                inject_internal=False,
                req=req_model,
            )
        r = httpx.post(_taxi_url("/rides/quote"), json=body, timeout=10)
        return r.json() if r.headers.get("content-type",""
        ).startswith("application/json") else {"raw": r.text, "status_code": r.status_code}
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/taxi/rides/book_pay")
async def taxi_book_pay(req: Request):
    phone = _auth_phone(req)
    env_test = _ENV_LOWER == "test"
    # Backend-side enrichment: rider phone from session; rider wallet via Payments
    try:
        body = await req.json()
    except Exception:
        body = {}
    if not isinstance(body, dict):
        body = {}
    # Add idempotency header passthrough
    headers = {}
    try:
        ikey = req.headers.get("Idempotency-Key")
    except Exception:
        ikey = None
    if ikey:
        headers["Idempotency-Key"] = ikey
    # Fill rider phone from session if absent (or, in ENV=test, accept it from body)
    try:
        rider_phone = (body.get('rider_phone') or '').strip()
    except Exception:
        rider_phone = ''
    if not rider_phone:
        if not phone and env_test:
            # In test mode allow phone to come solely from payload
            raise HTTPException(status_code=400, detail="rider_phone required in body")
        if not phone:
            raise HTTPException(status_code=401, detail="unauthorized")
        body['rider_phone'] = phone
        rider_phone = phone
    # Fill rider wallet id via Payments if absent
    # In ENV=test we also allow resolving via rider_phone when no session phone is present.
    lookup_phone = phone or rider_phone
    user_wallet = _resolve_wallet_id_for_phone(lookup_phone)
    if not user_wallet:
        raise HTTPException(status_code=400, detail="wallet not found for user")
    try:
        rider_wallet = (body.get('rider_wallet_id') or '').strip()
    except Exception:
        rider_wallet = ''
    if rider_wallet and rider_wallet != user_wallet:
        raise HTTPException(status_code=403, detail="wallet does not belong to user")
    body['rider_wallet_id'] = user_wallet
    try:
        if _use_taxi_internal():
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                req_model = _TaxiRideRequest(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            return _call_taxi(
                _taxi_book_and_pay,
                need_session=True,
                request_body=None,
                inject_internal=True,
                req=req_model,
                idempotency_key=ikey,
            )
        r = httpx.post(_taxi_url("/rides/book_pay"), json=body, headers=headers, timeout=15)
        return r.json() if r.headers.get("content-type",""
        ).startswith("application/json") else {"raw": r.text, "status_code": r.status_code}
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.get("/taxi/admin", response_class=HTMLResponse)
def taxi_admin_page(request: Request):
    phone = _auth_phone(request)
    if not phone:
        return RedirectResponse(url="/login", status_code=303)
    if not _is_operator(phone, "taxi"):
        raise HTTPException(status_code=403, detail="operator for taxi required")
    html = """
<!doctype html>
<html><head><meta name=viewport content="width=device-width, initial-scale=1" />
<title>Taxi Admin</title>
<link rel="icon" href="/icons/taxi.svg" />
<script src="/ds.js"></script>
<style>
  body{font-family:sans-serif;margin:20px;max-width:980px;background:#ffffff;color:#000000;}
  button{border:1px solid #cccccc;background:#f3f4f6;border-radius:12px;color:#000000;box-shadow:none;padding:10px 14px;font-size:14px}
  pre{background:#f5f5f5;padding:10px;white-space:pre-wrap;border-radius:12px;border:1px solid #dddddd}
  .grid{display:grid;grid-template-columns:repeat(2,minmax(280px,1fr));gap:16px}
  .full{grid-column:1/-1}
  h1{margin:0 0 14px 0}
  h2{margin:0 0 10px 0;font-size:16px}
  .row{display:flex;gap:8px;align-items:center;justify-content:space-between}
  .muted{opacity:.75;font-size:13px}
  .pill{display:inline-flex;gap:8px;align-items:center;padding:6px 10px;border-radius:999px;border:1px solid #e5e7eb;background:#f8fafc;font-size:12px}
  .kpi{display:flex;gap:10px;flex-wrap:wrap}
  .kpi .pill strong{font-weight:700}
  [data-ds="card"]{padding:14px}
  body{background:#ffffff}
</style>
</head><body data-accent="#f59e0b" data-bg="simple">
<h1>Taxi Admin</h1>
<div class="muted">Operator dashboard (WebView / Mini‑Program).</div>
<div class="grid" style="margin-top:14px">
  <div data-ds="card">
    <div class="row">
      <h2>Summary</h2>
      <button onclick="loadSummary()">Refresh</button>
    </div>
    <div id="kpis" class="kpi" style="margin:8px 0 12px 0"></div>
    <pre id="summary_out"></pre>
  </div>
  <div data-ds="card">
    <div class="row">
      <h2>Online drivers</h2>
      <button onclick="loadDrivers()">Refresh</button>
    </div>
    <pre id="drivers_out"></pre>
  </div>
  <div class="full" data-ds="card">
    <div class="row">
      <h2>Requested rides</h2>
      <button onclick="loadRides()">Refresh</button>
    </div>
    <pre id="rides_out"></pre>
  </div>
</div>
<script>
async function fetchPretty(url){
  const r = await fetch(url);
  const t = await r.text();
  try{ return JSON.stringify(JSON.parse(t), null, 2); }catch(_){ return t; }
}
function setKpis(summary){
  const box = document.getElementById('kpis');
  if(!box) return;
  const m = summary || {};
  const rides = (m.rides_today ?? m.rides_total_today ?? 0);
  const done = (m.rides_completed_today ?? m.completed_today ?? 0);
  const fare = (m.total_fare_cents_today ?? m.revenue_cents_today ?? 0);
  const parts = [
    `<span class="pill"><strong>${rides}</strong> rides</span>`,
    `<span class="pill"><strong>${done}</strong> completed</span>`,
    `<span class="pill"><strong>${fare}</strong> cents</span>`
  ];
  box.innerHTML = parts.join('');
}
async function loadSummary(){
  const out = document.getElementById('summary_out');
  out.textContent = 'Loading...';
  const raw = await fetchPretty('/taxi/admin/summary_cached');
  out.textContent = raw;
  try{ setKpis(JSON.parse(raw)); }catch(_){ }
}
async function loadDrivers(){
  const out = document.getElementById('drivers_out');
  out.textContent = 'Loading...';
  out.textContent = await fetchPretty('/taxi/drivers?status=online&limit=200');
}
async function loadRides(){
  const out = document.getElementById('rides_out');
  out.textContent = 'Loading...';
  out.textContent = await fetchPretty('/taxi/rides?status=requested&limit=200');
}
loadSummary();
loadDrivers();
loadRides();
</script>
</body></html>
"""
    return HTMLResponse(content=html)


@app.get("/taxi/events")
async def taxi_events(request: Request):
    async def gen():
        while True:
            if await request.is_disconnected():
                break
            try:
                drivers = []
                rides = []
                if TAXI_BASE:
                    dr = httpx.get(_taxi_url("/drivers"), params={"status": "online", "limit": 200}, timeout=10)
                    rr = httpx.get(_taxi_url("/rides"), params={"status": "requested", "limit": 200}, timeout=10)
                    drivers = dr.json() if dr.status_code == 200 else []
                    rides = rr.json() if rr.status_code == 200 else []
                payload = {"type": "snapshot", "drivers": drivers, "rides": rides, "ts": int(asyncio.get_event_loop().time()*1000)}
                yield f"data: {_json.dumps(payload)}\n\n"
            except Exception as e:
                err = {"type": "error", "error": str(e)}
                yield f"data: {_json.dumps(err)}\n\n"
            await asyncio.sleep(5)
    return StreamingResponse(gen(), media_type="text/event-stream")


@app.get("/taxi/driver/events")
async def taxi_driver_events(driver_id: str, request: Request):
    async def gen():
        last_ids = set()
        while True:
            if await request.is_disconnected():
                break
            try:
                rides = []
                if TAXI_BASE:
                    rr = httpx.get(_taxi_url(f"/drivers/{driver_id}/rides"), params={"limit": 20}, timeout=10)
                    rides = rr.json() if rr.status_code == 200 else []
                # only emit if changed
                ids = {r.get('id') for r in rides if r.get('status') in ('assigned','accepted','on_trip')}
                if ids != last_ids:
                    payload = {"type":"rides","driver_id":driver_id,"active_ids":list(ids),"rides":rides}
                    yield f"data: {_json.dumps(payload)}\n\n"
                    last_ids = ids
            except Exception as e:
                err = {"type":"error","error":str(e)}
                yield f"data: {_json.dumps(err)}\n\n"
            await asyncio.sleep(5)
    return StreamingResponse(gen(), media_type="text/event-stream")


@app.websocket("/ws/taxi/driver")
async def taxi_driver_ws(ws: WebSocket):
    await ws.accept()
    try:
        params = dict(ws.query_params)
        driver_id = params.get('driver_id')
        last_ids = set()
        while True:
            try:
                rides = []
                if TAXI_BASE and driver_id:
                    rr = httpx.get(_taxi_url(f"/drivers/{driver_id}/rides"), params={"limit": 20}, timeout=10)
                    rides = rr.json() if rr.status_code == 200 else []
                ids = {r.get('id') for r in rides if r.get('status') in ('assigned','accepted','on_trip')}
                if ids != last_ids:
                    await ws.send_json({"type":"rides","driver_id":driver_id,"active_ids":list(ids),"rides":rides})
                    last_ids = ids
                await asyncio.sleep(5)
            except Exception as e:
                await ws.send_json({"type":"error","error":str(e)})
                await asyncio.sleep(5)
    except WebSocketDisconnect:
        return
@app.get("/favicon.ico")
def favicon():
    svg = """
<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'>
  <defs>
    <linearGradient id='g' x1='0' y1='0' x2='1' y2='1'>
      <stop offset='0%' stop-color='#60a5fa'/>
      <stop offset='100%' stop-color='#10b981'/>
    </linearGradient>
    <filter id='f' x='-50%' y='-50%' width='200%' height='200%'>
      <feGaussianBlur stdDeviation='2' />
    </filter>
  </defs>
  <rect x='6' y='6' width='52' height='52' rx='14' fill='url(#g)'/>
  <circle cx='32' cy='20' r='10' fill='white' fill-opacity='.35' filter='url(#f)'/>
  <text x='32' y='40' font-size='16' text-anchor='middle' fill='white' font-family='sans-serif' font-weight='700'>SH꩜</text>
</svg>
"""
    return Response(content=svg, media_type="image/svg+xml")


_BRAND_DIR = Path(__file__).resolve().parent / "branding"


@app.get("/brand/shamell.svg")
def brand_shamell_svg():
    path = _BRAND_DIR / "shamell-logo.svg"
    if not path.exists():
        raise HTTPException(status_code=404, detail="logo not found")
    return FileResponse(path, media_type="image/svg+xml")


@app.get("/brand/shamell.png")
def brand_shamell_png():
    path = _BRAND_DIR / "shamell-logo.png"
    if not path.exists():
        raise HTTPException(status_code=404, detail="logo not found")
    return FileResponse(path, media_type="image/png")


@app.get("/icons/{name}.svg")
def module_icon(name: str):
    name = (name or "").lower()
    # Choose gradient colors and label per module
    gradients = {
        "payments": ("#6366f1", "#22c55e", "PA"),
        "merchant": ("#8b5cf6", "#06b6d4", "ME"),
        "taxi": ("#f59e0b", "#ef4444", "TX"),
        "bus": ("#0ea5e9", "#22d3ee", "BU"),
        "carmarket": ("#3b82f6", "#22d3ee", "CM"),
        "carrental": ("#3b82f6", "#22c55e", "CR"),
        "food": ("#ef4444", "#f59e0b", "FD"),
        "realestate": ("#10b981", "#06b6d4", "RE"),
        "stays": ("#14b8a6", "#6366f1", "ST"),
        "freight": ("#f59e0b", "#84cc16", "FR"),
        "chat": ("#06b6d4", "#8b5cf6", "CH"),
        "agriculture": ("#10b981", "#84cc16", "AG"),
        "commerce": ("#0ea5e9", "#6366f1", "CO"),
        "doctors": ("#f43f5e", "#06b6d4", "DR"),
        "flights": ("#38bdf8", "#22d3ee", "FL"),
        "jobs": ("#8b5cf6", "#0ea5e9", "JB"),
        "livestock": ("#84cc16", "#22c55e", "LS"),
        "default": ("#60a5fa", "#10b981", "SH꩜"),
    }
    c1, c2, label = gradients.get(name, gradients["default"])
    svg = f"""
<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'>
  <defs>
    <linearGradient id='g' x1='0' y1='0' x2='1' y2='1'>
      <stop offset='0%' stop-color='{c1}'/>
      <stop offset='100%' stop-color='{c2}'/>
    </linearGradient>
    <filter id='f' x='-50%' y='-50%' width='200%' height='200%'>
      <feGaussianBlur stdDeviation='2' />
    </filter>
  </defs>
  <rect x='6' y='6' width='52' height='52' rx='14' fill='url(#g)'/>
  <circle cx='24' cy='20' r='8' fill='white' fill-opacity='.35' filter='url(#f)'/>
  <text x='32' y='40' font-size='16' text-anchor='middle' fill='white' font-family='sans-serif' font-weight='700'>{label}</text>
  <title>{name}</title>
  <desc>SuperApp icon for {name}</desc>
  <metadata>module:{name}</metadata>
  <style>@media(prefers-color-scheme:dark){{text{{fill:#fff}}}}</style>
  <rect width='64' height='64' fill='transparent'/>
</svg>
"""
    return Response(content=svg, media_type="image/svg+xml")


@app.get("/icons/{name}-{size}.png")
def module_icon_png(name: str, size: int):
    if Image is None:
        raise HTTPException(status_code=500, detail="Pillow not available")
    name = (name or "").lower()
    sizes_allowed = {192, 512}
    if size not in sizes_allowed:
        raise HTTPException(status_code=400, detail="size must be 192 or 512")
    gradients = {
        "payments": ("#6366f1", "#22c55e", "PA"),
        "merchant": ("#8b5cf6", "#06b6d4", "ME"),
        "taxi": ("#f59e0b", "#ef4444", "TX"),
        "bus": ("#0ea5e9", "#22d3ee", "BU"),
        "carmarket": ("#3b82f6", "#22d3ee", "CM"),
        "carrental": ("#3b82f6", "#22c55e", "CR"),
        "food": ("#ef4444", "#f59e0b", "FD"),
        "realestate": ("#10b981", "#06b6d4", "RE"),
        "stays": ("#14b8a6", "#6366f1", "ST"),
        "freight": ("#f59e0b", "#84cc16", "FR"),
        "chat": ("#06b6d4", "#8b5cf6", "CH"),
        "agriculture": ("#10b981", "#84cc16", "AG"),
        "commerce": ("#0ea5e9", "#6366f1", "CO"),
        "doctors": ("#f43f5e", "#06b6d4", "DR"),
        "flights": ("#38bdf8", "#22d3ee", "FL"),
        "jobs": ("#8b5cf6", "#0ea5e9", "JB"),
        "livestock": ("#84cc16", "#22c55e", "LS"),
        "default": ("#60a5fa", "#10b981", "SH꩜"),
    }
    c1, c2, label = gradients.get(name, gradients["default"])
    # Build gradient background clipped to rounded rect
    s = size
    grad = Image.new("RGBA", (s, s))
    # simple diagonal gradient
    p1 = tuple(int(c1.strip('#')[i:i+2],16) for i in (0,2,4))
    p2 = tuple(int(c2.strip('#')[i:i+2],16) for i in (0,2,4))
    for y in range(s):
        t = y/(s-1)
        r = int(p1[0]*(1-t) + p2[0]*t)
        g = int(p1[1]*(1-t) + p2[1]*t)
        b = int(p1[2]*(1-t) + p2[2]*t)
        Image.Draw = ImageDraw.Draw  # type: ignore
        ImageDraw.Draw(grad).line([(0,y),(s,y)], fill=(r,g,b,255))
    mask = Image.new("L", (s, s), 0)
    drawm = ImageDraw.Draw(mask)
    rr = int(0.22*s)
    drawm.rounded_rectangle([int(0.09*s), int(0.09*s), int(0.91*s), int(0.91*s)], radius=rr, fill=255)
    out = Image.new("RGBA", (s, s), (0,0,0,0))
    out = Image.composite(grad, out, mask)
    # highlight circle
    draw = ImageDraw.Draw(out)
    cx, cy = int(0.38*s), int(0.32*s)
    r = int(0.16*s)
    draw.ellipse([cx-r, cy-r, cx+r, cy+r], fill=(255,255,255,90))
    # label
    try:
        font_path = "/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf"
        font_size = int(0.28*s)
        font = ImageFont.truetype(font_path, font_size)
        tw, th = draw.textsize(label, font=font)
        draw.text(( (s-tw)//2, int(0.62*s)-th//2 ), label, font=font, fill=(255,255,255,255))
    except Exception:
        pass
    buf = BytesIO()
    out.save(buf, format="PNG")
    return Response(content=buf.getvalue(), media_type="image/png")
@app.post("/stays/operators/login")
async def stays_operator_login(req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_stays_internal():
            if not _STAYS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="stays internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                lreq = _StaysOperatorLoginReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _stays_internal_session() as s:
                return _stays_operator_login(req=lreq, s=s)
        r = httpx.post(_stays_url("/operators/login"), json=body, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/stays/operators/request_code")
async def stays_operator_request_code(req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_stays_internal():
            if not _STAYS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="stays internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                creq = _StaysOperatorCodeReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            return _stays_operators_request_code(req=creq)
        r = httpx.post(_stays_url("/operators/request_code"), json=body, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))


@app.post("/stays/operators/verify")
async def stays_operator_verify(req: Request):
    try:
        body = await req.json()
    except Exception:
        body = None
    try:
        if _use_stays_internal():
            if not _STAYS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="stays internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                vreq = _StaysOperatorVerifyReq(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _stays_internal_session() as s:
                return _stays_operators_verify(req=vreq, s=s)
        r = httpx.post(_stays_url("/operators/verify"), json=body, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))

# --- Stays Operator PMS proxies ---
@app.post("/stays/operators/{op_id}/room_types")
async def stays_operator_create_room_type(op_id: int, req: Request):
    try:
        try: body = await req.json()
        except Exception: body = None
        headers = {}
        try:
            auth = req.headers.get('authorization')
            if auth: headers['Authorization'] = auth
        except Exception: pass
        r = httpx.post(_stays_url(f"/operators/{op_id}/room_types"), json=body, headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))

@app.get("/stays/operators/{op_id}/room_types")
def stays_operator_list_room_types(op_id: int, req: Request):
    try:
        headers = {}
        try:
            auth = req.headers.get('authorization')
            if auth: headers['Authorization'] = auth
        except Exception: pass
        params = {}
        try:
            pid = req.query_params.get('property_id')
            if pid: params['property_id']=pid
        except Exception:
            pass
        r = httpx.get(_stays_url(f"/operators/{op_id}/room_types"), params=params, headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))

@app.patch("/stays/operators/{op_id}/room_types/{rtid}")
async def stays_operator_update_room_type(op_id: int, rtid: int, req: Request):
    try:
        try: body = await req.json()
        except Exception: body = None
        headers = {}
        try:
            auth = req.headers.get('authorization')
            if auth: headers['Authorization'] = auth
        except Exception: pass
        r = httpx.patch(_stays_url(f"/operators/{op_id}/room_types/{rtid}"), json=body, headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))

@app.post("/stays/operators/{op_id}/rooms")
async def stays_operator_create_room(op_id: int, req: Request):
    try:
        try: body = await req.json()
        except Exception: body = None
        headers = {}
        try:
            auth = req.headers.get('authorization')
            if auth: headers['Authorization'] = auth
        except Exception: pass
        r = httpx.post(_stays_url(f"/operators/{op_id}/rooms"), json=body, headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))

@app.get("/stays/operators/{op_id}/rooms")
def stays_operator_list_rooms(op_id: int, req: Request):
    try:
        headers = {}
        try:
            auth = req.headers.get('authorization')
            if auth: headers['Authorization'] = auth
        except Exception: pass
        params = {}
        try:
            pid = req.query_params.get('property_id')
            if pid: params['property_id']=pid
        except Exception:
            pass
        r = httpx.get(_stays_url(f"/operators/{op_id}/rooms"), params=params, headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))

@app.patch("/stays/operators/{op_id}/rooms/{rid}")
async def stays_operator_update_room(op_id: int, rid: int, req: Request):
    try:
        try: body = await req.json()
        except Exception: body = None
        headers = {}
        try:
            auth = req.headers.get('authorization')
            if auth: headers['Authorization'] = auth
        except Exception: pass
        r = httpx.patch(_stays_url(f"/operators/{op_id}/rooms/{rid}"), json=body, headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))

@app.get("/stays/operators/{op_id}/room_types/{rtid}/rates")
def stays_operator_get_room_type_rates(op_id: int, rtid: int, req: Request, frm: str, to: str):
    try:
        headers: dict[str, str] = {}
        try:
            auth = req.headers.get('authorization')
            if auth:
                headers['Authorization'] = auth
        except Exception:
            pass
        params = {"frm": frm, "to": to}
        if _use_stays_internal():
            if not _STAYS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="stays internal not available")
            with _stays_internal_session() as s:
                return _stays_get_room_type_rates(op_id=op_id, rtid=rtid, request=req, frm=frm, to=to, s=s)
        r = httpx.get(_stays_url(f"/operators/{op_id}/room_types/{rtid}/rates"), params=params, headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))

@app.post("/stays/operators/{op_id}/room_types/{rtid}/rates")
async def stays_operator_upsert_room_type_rates(op_id: int, rtid: int, req: Request):
    try:
        try:
            body = await req.json()
        except Exception:
            body = None
        headers: dict[str, str] = {}
        try:
            auth = req.headers.get('authorization')
            if auth:
                headers['Authorization'] = auth
        except Exception:
            pass
        if _use_stays_internal():
            if not _STAYS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="stays internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                dreq = _StaysDayRatesUpsert(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _stays_internal_session() as s:
                return _stays_upsert_room_type_rates(op_id=op_id, rtid=rtid, req=dreq, request=req, s=s)
        r = httpx.post(_stays_url(f"/operators/{op_id}/room_types/{rtid}/rates"), json=body, headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))
@app.get("/stays/operators/{op_id}/listings/search")
def stays_operator_listings_search(op_id: int, req: Request, limit: int = 50, offset: int = 0, q: str = "", city: str = "", type: str = "", sort_by: str = "created_at", order: str = "desc"):
    try:
        headers: dict[str, str] = {}
        try:
            auth = req.headers.get('authorization')
            if auth:
                headers['Authorization'] = auth
        except Exception:
            pass
        params = {"limit": max(1, min(limit, 200)), "offset": max(0, offset), "sort_by": sort_by, "order": order}
        if q:
            params['q'] = q
        if city:
            params['city'] = city
        if type:
            params['type'] = type
        property_id = None
        try:
            pid = req.query_params.get('property_id')
            if pid:
                params['property_id'] = pid
                property_id = int(pid)
        except Exception:
            property_id = None
        if _use_stays_internal():
            if not _STAYS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="stays internal not available")
            with _stays_internal_session() as s:
                return _stays_operator_listings_search(
                    op_id=op_id,
                    request=req,
                    limit=limit,
                    offset=offset,
                    q=q,
                    city=city,
                    type=type,
                    property_id=property_id,
                    sort_by=sort_by,
                    order=order,
                    s=s,
                )
        r = httpx.get(_stays_url(f"/operators/{op_id}/listings/search"), params=params, headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))

# --- Stays: Properties & Staff ---
@app.get("/stays/operators/{op_id}/properties")
def stays_list_properties(op_id: int, req: Request):
    try:
        headers: dict[str, str] = {}
        try:
            auth = req.headers.get('authorization')
            if auth:
                headers['Authorization'] = auth
        except Exception:
            pass
        if _use_stays_internal():
            if not _STAYS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="stays internal not available")
            with _stays_internal_session() as s:
                return _stays_list_properties(op_id=op_id, request=req, s=s)
        r = httpx.get(_stays_url(f"/operators/{op_id}/properties"), headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))

@app.post("/stays/operators/{op_id}/properties")
async def stays_create_property(op_id: int, req: Request):
    try:
        try:
            body = await req.json()
        except Exception:
            body = None
        headers: dict[str, str] = {}
        try:
            auth = req.headers.get('authorization')
            if auth:
                headers['Authorization'] = auth
        except Exception:
            pass
        if _use_stays_internal():
            if not _STAYS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="stays internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                preq = _StaysPropertyCreate(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _stays_internal_session() as s:
                return _stays_create_property(op_id=op_id, req=preq, request=req, s=s)
        r = httpx.post(_stays_url(f"/operators/{op_id}/properties"), json=body, headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))

@app.get("/stays/operators/{op_id}/staff")
def stays_list_staff(op_id: int, req: Request):
    try:
        headers: dict[str, str] = {}
        try:
            auth = req.headers.get('authorization')
            if auth:
                headers['Authorization'] = auth
        except Exception:
            pass
        params: dict[str, object] = {}
        active = None
        try:
            a = req.query_params.get('active')
            if a is not None:
                params['active'] = a
                active = int(a)
        except Exception:
            active = None
        q = ""
        try:
            q = req.query_params.get('q') or ""
            if q:
                params['q'] = q
        except Exception:
            q = ""
        role = ""
        try:
            role = req.query_params.get('role') or ""
            if role:
                params['role'] = role
        except Exception:
            role = ""
        if _use_stays_internal():
            if not _STAYS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="stays internal not available")
            with _stays_internal_session() as s:
                return _stays_list_staff(op_id=op_id, request=req, active=active, q=q, role=role, s=s)
        r = httpx.get(_stays_url(f"/operators/{op_id}/staff"), params=params, headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))

@app.post("/stays/operators/{op_id}/staff")
async def stays_create_staff(op_id: int, req: Request):
    try:
        try:
            body = await req.json()
        except Exception:
            body = None
        headers: dict[str, str] = {}
        try:
            auth = req.headers.get('authorization')
            if auth:
                headers['Authorization'] = auth
        except Exception:
            pass
        if _use_stays_internal():
            if not _STAYS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="stays internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                sreq = _StaysStaffCreate(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _stays_internal_session() as s:
                return _stays_create_staff(op_id=op_id, req=sreq, request=req, s=s)
        r = httpx.post(_stays_url(f"/operators/{op_id}/staff"), json=body, headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))

@app.patch("/stays/operators/{op_id}/staff/{sid}")
async def stays_update_staff(op_id: int, sid: int, req: Request):
    try:
        try:
            body = await req.json()
        except Exception:
            body = None
        headers: dict[str, str] = {}
        try:
            auth = req.headers.get('authorization')
            if auth:
                headers['Authorization'] = auth
        except Exception:
            pass
        if _use_stays_internal():
            if not _STAYS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="stays internal not available")
            data = body or {}
            if not isinstance(data, dict):
                data = {}
            try:
                ureq = _StaysStaffUpdate(**data)
            except Exception as e:
                raise HTTPException(status_code=400, detail=str(e))
            with _stays_internal_session() as s:
                return _stays_update_staff(op_id=op_id, sid=sid, req=ureq, request=req, s=s)
        r = httpx.patch(_stays_url(f"/operators/{op_id}/staff/{sid}"), json=body, headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))

@app.delete("/stays/operators/{op_id}/staff/{sid}")
def stays_deactivate_staff(op_id: int, sid: int, req: Request):
    try:
        headers: dict[str, str] = {}
        try:
            auth = req.headers.get('authorization')
            if auth:
                headers['Authorization'] = auth
        except Exception:
            pass
        if _use_stays_internal():
            if not _STAYS_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="stays internal not available")
            with _stays_internal_session() as s:
                return _stays_deactivate_staff(op_id=op_id, sid=sid, request=req, s=s)
        r = httpx.delete(_stays_url(f"/operators/{op_id}/staff/{sid}"), headers=headers, timeout=10)
        return r.json()
    except httpx.HTTPStatusError as e:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=502, detail=str(e))
def _to_cents(x) -> int:
    try:
        if isinstance(x, (int, float)):
            return round(float(x) * 100)
        s = str(x).strip().replace(',', '.')
        # strip non-numeric except dot and minus
        keep = ''.join(ch for ch in s if (ch.isdigit() or ch in '.-'))
        return round(float(keep) * 100)
    except Exception:
        return 0

def _normalize_amount(body: dict | None) -> dict | None:
    if not isinstance(body, dict):
        return body
    # Accept amount in SYP major units and convert to amount_cents for upstream
    if 'amount_cents' not in body:
        if 'amount' in body and body['amount'] not in (None, ''):
            body['amount_cents'] = _to_cents(body['amount'])
        elif 'amount_syp' in body and body['amount_syp'] not in (None, ''):
            body['amount_cents'] = _to_cents(body['amount_syp'])
    return body


# ---- Moments (lightweight social feed, BFF-side) ----

_MOMENTS_DB_URL = _env_or(
    "MOMENTS_DB_URL", _env_or("DB_URL", "sqlite+pysqlite:////tmp/moments.db")
)


class _MomentsBase(_sa_DeclarativeBase):
    pass


class MomentPostDB(_MomentsBase):
    __tablename__ = "moments_posts"
    id: _sa_Mapped[int] = _sa_mapped_column(
        _sa_Integer, primary_key=True, autoincrement=True
    )
    user_key: _sa_Mapped[str] = _sa_mapped_column(
        _sa_String(128), index=True
    )
    text: _sa_Mapped[str] = _sa_mapped_column(_sa_Text)
    visibility: _sa_Mapped[str] = _sa_mapped_column(
        _sa_String(16), default="public"
    )
    audience_tag: _sa_Mapped[str | None] = _sa_mapped_column(
        _sa_String(64), nullable=True
    )
    location_label: _sa_Mapped[str | None] = _sa_mapped_column(
        _sa_String(128), nullable=True
    )
    images_b64_json: _sa_Mapped[str | None] = _sa_mapped_column(
        _sa_Text, nullable=True
    )
    image_b64: _sa_Mapped[str | None] = _sa_mapped_column(
        _sa_Text, nullable=True
    )
    image_url: _sa_Mapped[str | None] = _sa_mapped_column(
        _sa_String(255), nullable=True
    )
    origin_official_account_id: _sa_Mapped[str | None] = _sa_mapped_column(
        _sa_String(64), nullable=True
    )
    origin_official_item_id: _sa_Mapped[str | None] = _sa_mapped_column(
        _sa_String(64), nullable=True
    )
    created_at: _sa_Mapped[datetime] = _sa_mapped_column(
        _sa_DateTime(timezone=True), server_default=_sa_func.now()
    )


class MomentLikeDB(_MomentsBase):
    __tablename__ = "moments_likes"
    __table_args__ = (
        _sa_UniqueConstraint(
            "user_key",
            "post_id",
            name="uq_moments_likes_user_post",
        ),
    )
    id: _sa_Mapped[int] = _sa_mapped_column(
        _sa_Integer, primary_key=True, autoincrement=True
    )
    post_id: _sa_Mapped[int] = _sa_mapped_column(
        _sa_Integer, index=True
    )
    user_key: _sa_Mapped[str] = _sa_mapped_column(
        _sa_String(128), index=True
    )
    created_at: _sa_Mapped[datetime] = _sa_mapped_column(
        _sa_DateTime(timezone=True), server_default=_sa_func.now()
    )


class MomentCommentDB(_MomentsBase):
    __tablename__ = "moments_comments"
    id: _sa_Mapped[int] = _sa_mapped_column(
        _sa_Integer, primary_key=True, autoincrement=True
    )
    post_id: _sa_Mapped[int] = _sa_mapped_column(_sa_Integer, index=True)
    user_key: _sa_Mapped[str] = _sa_mapped_column(
        _sa_String(128), index=True
    )
    text: _sa_Mapped[str] = _sa_mapped_column(_sa_Text)
    reply_to_id: _sa_Mapped[int | None] = _sa_mapped_column(
        _sa_Integer, nullable=True
    )
    created_at: _sa_Mapped[datetime] = _sa_mapped_column(
        _sa_DateTime(timezone=True), server_default=_sa_func.now()
    )


class MomentCommentLikeDB(_MomentsBase):
    __tablename__ = "moments_comment_likes"
    __table_args__ = (
        _sa_UniqueConstraint(
            "user_key",
            "comment_id",
            name="uq_moments_comment_likes_user_comment",
        ),
    )
    id: _sa_Mapped[int] = _sa_mapped_column(
        _sa_Integer, primary_key=True, autoincrement=True
    )
    comment_id: _sa_Mapped[int] = _sa_mapped_column(_sa_Integer, index=True)
    user_key: _sa_Mapped[str] = _sa_mapped_column(
        _sa_String(128), index=True
    )
    created_at: _sa_Mapped[datetime] = _sa_mapped_column(
        _sa_DateTime(timezone=True), server_default=_sa_func.now()
    )


class MomentTagDB(_MomentsBase):
    __tablename__ = "moments_tags"
    __table_args__ = (
        _sa_UniqueConstraint(
            "post_id",
            "tag",
            name="uq_moments_tags_post_tag",
        ),
    )
    id: _sa_Mapped[int] = _sa_mapped_column(
        _sa_Integer, primary_key=True, autoincrement=True
    )
    post_id: _sa_Mapped[int] = _sa_mapped_column(_sa_Integer, index=True)
    tag: _sa_Mapped[str] = _sa_mapped_column(_sa_String(64), index=True)
    created_at: _sa_Mapped[datetime] = _sa_mapped_column(
        _sa_DateTime(timezone=True), server_default=_sa_func.now()
    )


_moments_engine = _sa_create_engine(_MOMENTS_DB_URL, future=True)


def _moments_session() -> _sa_Session:
    return _sa_Session(_moments_engine)


class MomentPostOut(BaseModel):
    id: str
    text: str
    ts: str
    likes: int = 0
    liked_by_me: bool = False
    liked_by: list[str] | None = None
    comments: int = 0
    has_official_reply: bool = False
    visibility: str = "public"
    image_b64: str | None = None
    image_url: str | None = None
    author_name: str | None = None
    audience_tag: str | None = None
    location_label: str | None = None
    images: list[str] | None = None
    origin_official_account_id: str | None = None
    origin_official_item_id: str | None = None


class MomentCommentOut(BaseModel):
    id: str
    text: str
    ts: str
    author_name: str | None = None
    reply_to_id: str | None = None
    reply_to_name: str | None = None
    likes: int = 0
    liked_by_me: bool = False


class MomentNotificationsOut(BaseModel):
    last_comment_ts: str | None = None
    total_comments: int = 0
    redpacket_posts_30d: int = 0


class OfficialMomentsStatsOut(BaseModel):
    service_shares: int = 0
    subscription_shares: int = 0
    total_shares: int = 0
    redpacket_shares_30d: int = 0
    hot_accounts: int = 0


def _moments_cookie_key(request: Request) -> str:
    cookie = request.headers.get("sa_cookie") or request.cookies.get("sa_cookie") or ""
    if not cookie:
        cookie = "anon"
    return cookie


def _channels_user_key(request: Request) -> str:
    """
    Derive a stable per-user key for the Channels follower graph.

    Prefer an authenticated phone-based key when available so
    follows survive device changes, otherwise fall back to the
    Moments cookie key for anonymous users.
    """
    try:
        phone = _auth_phone(request)
    except Exception:
        phone = None
    if phone:
        return f"phone:{phone}"
    return _moments_cookie_key(request)


def _moments_pseudonym_for_user_key(user_key: str) -> str | None:
    """
    Stable but privacy-friendly label for a Moments author.
    Mirrors the comment labelling (User <hash>) without exposing phone or name.
    """
    uk = (user_key or "").strip()
    if not uk:
        return None
    try:
        import hashlib

        h = hashlib.sha256(uk.encode("utf-8")).hexdigest()[:6]
        return f"User {h}"
    except Exception:
        return None


def _phone_from_moments_user_key(user_key: str) -> str | None:
    """
    Best-effort mapping from a Moments user_key (sa_cookie value)
    back to the phone number via the in-memory _SESSIONS store.
    """
    try:
        uk = (user_key or "").strip()
        if not uk or uk == "anon":
            return None
        token = uk
        if "sa_session=" in token:
            for part in token.split(";"):
                part = part.strip()
                if part.startswith("sa_session="):
                    token = part.split("=", 1)[1]
                    break
        sid = token.strip()
        if not sid:
            return None
        rec = _SESSIONS.get(sid)
        if not rec:
            return None
        phone, exp = rec
        if exp < _now():
            return None
        return str(phone or "").strip() or None
    except Exception:
        return None


_MOMENTS_HASHTAG_RE = re.compile(r"#([\w]+)", re.UNICODE)


def _moments_extract_tags(text: str) -> list[str]:
    try:
        tags: set[str] = set()
        for m in _MOMENTS_HASHTAG_RE.finditer(text or ""):
            raw = (m.group(1) or "").strip().lower()
            if not raw:
                continue
            tag = raw[:64]
            tags.add(tag)
        return sorted(tags)
    except Exception:
        return []


_MOMENTS_OFFICIAL_RE = re.compile(
    r"shamell://official/([^/\s]+)(?:/([^\s]+))?", re.IGNORECASE
)


def _moments_extract_official_origin(text: str) -> tuple[str | None, str | None]:
    try:
        m = _MOMENTS_OFFICIAL_RE.search(text)
        if not m:
            return None, None
        acc = (m.group(1) or "").strip()
        item = (m.group(2) or "").strip() or None
        if not acc:
            return None, None
        return acc, item
    except Exception:
        return None, None


def _moments_startup() -> None:
    logger = logging.getLogger("shamell.moments")
    try:
        _MomentsBase.metadata.create_all(_moments_engine)
    except Exception:
        logger.exception("failed to init moments tables")
    # Best-effort schema upgrade for audience_tag column on existing deployments.
    try:
        with _moments_engine.begin() as conn:
            if _MOMENTS_DB_URL.startswith("sqlite"):
                conn.execute(
                    _sa_text(
                        "ALTER TABLE moments_posts ADD COLUMN audience_tag VARCHAR(64)"
                    )
                )
            else:
                conn.execute(
                    _sa_text(
                        "ALTER TABLE moments_posts ADD COLUMN audience_tag VARCHAR(64)"
                    )
                )
    except Exception:
        # Ignore migration errors (column may already exist).
        pass
    # Best-effort schema upgrade for location_label column on existing deployments.
    try:
        with _moments_engine.begin() as conn:
            conn.execute(
                _sa_text(
                    "ALTER TABLE moments_posts ADD COLUMN location_label VARCHAR(128)"
                )
            )
    except Exception:
        # Ignore migration errors (column may already exist).
        pass
    # Best-effort schema upgrade for images_b64_json column on existing deployments.
    try:
        with _moments_engine.begin() as conn:
            conn.execute(
                _sa_text(
                    "ALTER TABLE moments_posts ADD COLUMN images_b64_json TEXT"
                )
            )
    except Exception:
        # Ignore migration errors (column may already exist).
        pass


app.router.on_startup.append(_moments_startup)


# ---- Friends (simple phone-based graph for Moments visibility and chat) ----

FRIENDS_DB_URL = _env_or(
    "FRIENDS_DB_URL", _env_or("DB_URL", "sqlite+pysqlite:////tmp/friends.db")
)


class _FriendsBase(_sa_DeclarativeBase):
    pass


class FriendDB(_FriendsBase):
    __tablename__ = "friends"
    __table_args__ = (
        _sa_UniqueConstraint(
            "user_phone",
            "friend_phone",
            name="uq_friends_user_friend",
        ),
    )
    id: _sa_Mapped[int] = _sa_mapped_column(
        _sa_Integer, primary_key=True, autoincrement=True
    )
    user_phone: _sa_Mapped[str] = _sa_mapped_column(_sa_String(32), index=True)
    friend_phone: _sa_Mapped[str] = _sa_mapped_column(_sa_String(32), index=True)
    created_at: _sa_Mapped[datetime] = _sa_mapped_column(
        _sa_DateTime(timezone=True), server_default=_sa_func.now()
    )


class FriendTagDB(_FriendsBase):
    __tablename__ = "friend_tags"
    __table_args__ = (
        _sa_UniqueConstraint(
            "user_phone",
            "friend_phone",
            "tag",
            name="uq_friend_tags_user_friend_tag",
        ),
    )
    id: _sa_Mapped[int] = _sa_mapped_column(
        _sa_Integer, primary_key=True, autoincrement=True
    )
    user_phone: _sa_Mapped[str] = _sa_mapped_column(_sa_String(32), index=True)
    friend_phone: _sa_Mapped[str] = _sa_mapped_column(_sa_String(32), index=True)
    tag: _sa_Mapped[str] = _sa_mapped_column(_sa_String(64), index=True)
    created_at: _sa_Mapped[datetime] = _sa_mapped_column(
        _sa_DateTime(timezone=True), server_default=_sa_func.now()
    )


class CloseFriendDB(_FriendsBase):
    __tablename__ = "close_friends"
    __table_args__ = (
        _sa_UniqueConstraint(
            "user_phone",
            "friend_phone",
            name="uq_close_friends_user_friend",
        ),
    )
    id: _sa_Mapped[int] = _sa_mapped_column(
        _sa_Integer, primary_key=True, autoincrement=True
    )
    user_phone: _sa_Mapped[str] = _sa_mapped_column(_sa_String(32), index=True)
    friend_phone: _sa_Mapped[str] = _sa_mapped_column(_sa_String(32), index=True)
    created_at: _sa_Mapped[datetime] = _sa_mapped_column(
        _sa_DateTime(timezone=True), server_default=_sa_func.now()
    )


class FriendRequestDB(_FriendsBase):
    __tablename__ = "friend_requests"
    id: _sa_Mapped[int] = _sa_mapped_column(
        _sa_Integer, primary_key=True, autoincrement=True
    )
    from_phone: _sa_Mapped[str] = _sa_mapped_column(_sa_String(32), index=True)
    to_phone: _sa_Mapped[str] = _sa_mapped_column(_sa_String(32), index=True)
    status: _sa_Mapped[str] = _sa_mapped_column(_sa_String(16), default="pending")
    created_at: _sa_Mapped[datetime] = _sa_mapped_column(
        _sa_DateTime(timezone=True), server_default=_sa_func.now()
    )


_friends_engine = _sa_create_engine(FRIENDS_DB_URL, future=True)
_friends_inited = False


def _friends_session() -> _sa_Session:
    """
    Returns a session for the friends DB.

    Similar to _officials_session, this lazily initialises the schema so that
    deployments that bypass FastAPI's startup events still get the friends
    tables (friends, close_friends, friend_tags, friend_requests).
    """
    global _friends_inited
    if not _friends_inited:
        try:
            _friends_startup()  # type: ignore[name-defined]
        except Exception:
            logging.getLogger("shamell.friends").exception(
                "failed to init friends DB from session helper"
            )
        _friends_inited = True
    return _sa_Session(_friends_engine)


def _friends_startup() -> None:
    logger = logging.getLogger("shamell.friends")
    try:
        _FriendsBase.metadata.create_all(_friends_engine)
    except Exception:
        logger.exception("failed to init friends tables via metadata")
    # Best-effort schema upgrade for FriendsDB on existing deployments,
    # mirroring the pattern used for Officials/Channels.
    try:
        with _friends_engine.begin() as conn:
            if FRIENDS_DB_URL.startswith("sqlite"):
                conn.execute(
                    _sa_text(
                        "CREATE TABLE IF NOT EXISTS friends ("
                        "id INTEGER PRIMARY KEY AUTOINCREMENT, "
                        "user_phone VARCHAR(32) NOT NULL, "
                        "friend_phone VARCHAR(32) NOT NULL, "
                        "created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, "
                        "CONSTRAINT uq_friends_user_friend UNIQUE (user_phone, friend_phone)"
                        ")"
                    )
                )
                conn.execute(
                    _sa_text(
                        "CREATE TABLE IF NOT EXISTS friend_tags ("
                        "id INTEGER PRIMARY KEY AUTOINCREMENT, "
                        "user_phone VARCHAR(32) NOT NULL, "
                        "friend_phone VARCHAR(32) NOT NULL, "
                        "tag VARCHAR(64) NOT NULL, "
                        "created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, "
                        "CONSTRAINT uq_friend_tags_user_friend_tag "
                        "UNIQUE (user_phone, friend_phone, tag)"
                        ")"
                    )
                )
                conn.execute(
                    _sa_text(
                        "CREATE TABLE IF NOT EXISTS close_friends ("
                        "id INTEGER PRIMARY KEY AUTOINCREMENT, "
                        "user_phone VARCHAR(32) NOT NULL, "
                        "friend_phone VARCHAR(32) NOT NULL, "
                        "created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, "
                        "CONSTRAINT uq_close_friends_user_friend "
                        "UNIQUE (user_phone, friend_phone)"
                        ")"
                    )
                )
                conn.execute(
                    _sa_text(
                        "CREATE TABLE IF NOT EXISTS friend_requests ("
                        "id INTEGER PRIMARY KEY AUTOINCREMENT, "
                        "from_phone VARCHAR(32) NOT NULL, "
                        "to_phone VARCHAR(32) NOT NULL, "
                        "status VARCHAR(16) DEFAULT 'pending', "
                        "created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP"
                        ")"
                    )
                )
            else:
                conn.execute(
                    _sa_text(
                        "CREATE TABLE IF NOT EXISTS friends ("
                        "id SERIAL PRIMARY KEY, "
                        "user_phone VARCHAR(32) NOT NULL, "
                        "friend_phone VARCHAR(32) NOT NULL, "
                        "created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, "
                        "CONSTRAINT uq_friends_user_friend UNIQUE (user_phone, friend_phone)"
                        ")"
                    )
                )
                conn.execute(
                    _sa_text(
                        "CREATE TABLE IF NOT EXISTS friend_tags ("
                        "id SERIAL PRIMARY KEY, "
                        "user_phone VARCHAR(32) NOT NULL, "
                        "friend_phone VARCHAR(32) NOT NULL, "
                        "tag VARCHAR(64) NOT NULL, "
                        "created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, "
                        "CONSTRAINT uq_friend_tags_user_friend_tag "
                        "UNIQUE (user_phone, friend_phone, tag)"
                        ")"
                    )
                )
                conn.execute(
                    _sa_text(
                        "CREATE TABLE IF NOT EXISTS close_friends ("
                        "id SERIAL PRIMARY KEY, "
                        "user_phone VARCHAR(32) NOT NULL, "
                        "friend_phone VARCHAR(32) NOT NULL, "
                        "created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, "
                        "CONSTRAINT uq_close_friends_user_friend "
                        "UNIQUE (user_phone, friend_phone)"
                        ")"
                    )
                )
                conn.execute(
                    _sa_text(
                        "CREATE TABLE IF NOT EXISTS friend_requests ("
                        "id SERIAL PRIMARY KEY, "
                        "from_phone VARCHAR(32) NOT NULL, "
                        "to_phone VARCHAR(32) NOT NULL, "
                        "status VARCHAR(16) DEFAULT 'pending', "
                        "created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP"
                        ")"
                    )
                )
    except Exception:
        logger.exception("failed to ensure friends tables exist")


app.router.on_startup.append(_friends_startup)


# ---- People Nearby (demo presence for \"People nearby\" feature) ----

NEARBY_DB_URL = _env_or(
    "NEARBY_DB_URL", _env_or("DB_URL", "sqlite+pysqlite:////tmp/nearby.db")
)
NEARBY_TTL_SECS = int(os.getenv("NEARBY_TTL_SECS", "10800"))  # default: 3 hours


class _NearbyBase(_sa_DeclarativeBase):
    pass


class NearbyPresenceDB(_NearbyBase):
    """
    Lightweight presence/profile table for People Nearby.

    Stores coarse location and optional status/gender/age metadata
    so the client can implement a WeChat-style People Nearby list.
    """

    __tablename__ = "nearby_presence"
    __table_args__ = (
        _sa_UniqueConstraint(
            "user_phone",
            name="uq_nearby_presence_user_phone",
        ),
    )
    id: _sa_Mapped[int] = _sa_mapped_column(
        _sa_Integer, primary_key=True, autoincrement=True
    )
    user_phone: _sa_Mapped[str] = _sa_mapped_column(_sa_String(32), index=True)
    status: _sa_Mapped[str | None] = _sa_mapped_column(
        _sa_String(160), nullable=True
    )
    gender: _sa_Mapped[str | None] = _sa_mapped_column(
        _sa_String(16), nullable=True
    )
    age_years: _sa_Mapped[int | None] = _sa_mapped_column(
        _sa_Integer, nullable=True
    )
    last_lat: _sa_Mapped[float | None] = _sa_mapped_column(
        _sa_Float, nullable=True
    )
    last_lon: _sa_Mapped[float | None] = _sa_mapped_column(
        _sa_Float, nullable=True
    )
    updated_at: _sa_Mapped[datetime] = _sa_mapped_column(
        _sa_DateTime(timezone=True),
        server_default=_sa_func.now(),
        index=True,
    )


_nearby_engine = _sa_create_engine(NEARBY_DB_URL, future=True)
_nearby_inited = False


def _nearby_session() -> _sa_Session:
    """
    Returns a session for the nearby presence DB.

    Lazily ensures the nearby_presence table exists so that \"People nearby\"
    queries do not fail with missing-table errors even when startup hooks
    are not triggered.
    """
    global _nearby_inited
    if not _nearby_inited:
        try:
            _nearby_startup()  # type: ignore[name-defined]
        except Exception:
            logging.getLogger("shamell.nearby").exception(
                "failed to init nearby DB from session helper"
            )
        _nearby_inited = True
    return _sa_Session(_nearby_engine)


def _nearby_startup() -> None:
    logger = logging.getLogger("shamell.nearby")
    try:
        _NearbyBase.metadata.create_all(_nearby_engine)
    except Exception:
        logger.exception("failed to init nearby tables via metadata")
    # Best-effort schema upgrade for NearbyPresenceDB on existing deployments.
    try:
        with _nearby_engine.begin() as conn:
            if NEARBY_DB_URL.startswith("sqlite"):
                conn.execute(
                    _sa_text(
                        "CREATE TABLE IF NOT EXISTS nearby_presence ("
                        "id INTEGER PRIMARY KEY AUTOINCREMENT, "
                        "user_phone VARCHAR(32) NOT NULL, "
                        "status VARCHAR(160), "
                        "gender VARCHAR(16), "
                        "age_years INTEGER, "
                        "last_lat FLOAT, "
                        "last_lon FLOAT, "
                        "updated_at TIMESTAMP WITH TIME ZONE "
                        "DEFAULT CURRENT_TIMESTAMP"
                        ")"
                    )
                )
            else:
                conn.execute(
                    _sa_text(
                        "CREATE TABLE IF NOT EXISTS nearby_presence ("
                        "id SERIAL PRIMARY KEY, "
                        "user_phone VARCHAR(32) NOT NULL, "
                        "status VARCHAR(160), "
                        "gender VARCHAR(16), "
                        "age_years INTEGER, "
                        "last_lat DOUBLE PRECISION, "
                        "last_lon DOUBLE PRECISION, "
                        "updated_at TIMESTAMP WITH TIME ZONE "
                        "DEFAULT CURRENT_TIMESTAMP"
                        ")"
                    )
                )
    except Exception:
        logger.exception("failed to ensure nearby_presence table exists")


app.router.on_startup.append(_nearby_startup)


# ---- Stickers (online sticker marketplace, BFF-side) ----

STICKERS_DB_URL = _env_or(
    "STICKERS_DB_URL", _env_or("DB_URL", "sqlite+pysqlite:////tmp/stickers.db")
)
_STICKERS_DB_SCHEMA = os.getenv("DB_SCHEMA") if not STICKERS_DB_URL.startswith("sqlite") else None


class _StickersBase(_sa_DeclarativeBase):
    pass


class StickerPurchaseDB(_StickersBase):
    __tablename__ = "sticker_purchases"
    __table_args__ = (
        _sa_UniqueConstraint(
            "user_phone",
            "pack_id",
            name="uq_sticker_purchases_user_pack",
        ),
        {"schema": _STICKERS_DB_SCHEMA} if _STICKERS_DB_SCHEMA else {},
    )
    id: _sa_Mapped[int] = _sa_mapped_column(
        _sa_Integer, primary_key=True, autoincrement=True
    )
    user_phone: _sa_Mapped[str] = _sa_mapped_column(
        _sa_String(32), index=True
    )
    pack_id: _sa_Mapped[str] = _sa_mapped_column(
        _sa_String(64), index=True
    )
    amount_cents: _sa_Mapped[int] = _sa_mapped_column(
        _sa_Integer, default=0
    )
    currency: _sa_Mapped[str] = _sa_mapped_column(
        _sa_String(8), default=DEFAULT_CURRENCY
    )
    created_at: _sa_Mapped[datetime] = _sa_mapped_column(
        _sa_DateTime(timezone=True), server_default=_sa_func.now()
    )


_stickers_engine = _sa_create_engine(STICKERS_DB_URL, future=True)


def _stickers_session() -> _sa_Session:
    return _sa_Session(_stickers_engine)


def _stickers_startup() -> None:
    logger = logging.getLogger("shamell.stickers")
    try:
        _StickersBase.metadata.create_all(_stickers_engine)
    except Exception:
        logger.exception("failed to init stickers tables")


app.router.on_startup.append(_stickers_startup)


@app.get("/moments/feed", response_class=JSONResponse)
def moments_feed(
    request: Request,
    limit: int = 50,
    official_account_id: str | None = None,
    official_category: str | None = None,
    official_city: str | None = None,
    own_only: bool = False,
):
    """
    Returns latest Moments posts.
    Visibility rules: public + own \"only_me\" posts.

    When own_only is true, only posts authored by the current user are returned.
    """
    user_key = _moments_cookie_key(request)
    try:
        limit_val = max(1, min(limit, 100))
        account_ids_filter: set[str] | None = None
        if not official_account_id and (official_category or official_city):
            try:
                with _officials_session() as osess:
                    stmt = _sa_select(OfficialAccountDB.id).where(
                        OfficialAccountDB.enabled == True  # type: ignore[comparison-overlap]
                    )
                    if official_category:
                        stmt = stmt.where(OfficialAccountDB.category == official_category)
                    if official_city:
                        stmt = stmt.where(OfficialAccountDB.city == official_city)
                    rows = osess.execute(stmt).scalars().all()
                    account_ids_filter = {str(r) for r in rows}
            except Exception:
                account_ids_filter = set()
        with _moments_session() as s:
            stmt = _sa_select(MomentPostDB)
            if own_only:
                stmt = stmt.where(MomentPostDB.user_key == user_key)
            if official_account_id:
                stmt = stmt.where(
                    MomentPostDB.origin_official_account_id == official_account_id
                )
            elif account_ids_filter:
                stmt = stmt.where(
                    MomentPostDB.origin_official_account_id.in_(account_ids_filter)
                )
            stmt = stmt.order_by(
                MomentPostDB.created_at.desc(), MomentPostDB.id.desc()
            ).limit(limit_val)
            rows = s.execute(stmt).scalars().all()
            post_ids = [r.id for r in rows]
            likes_map: dict[int, int] = {}
            liked_by_me: set[int] = set()
            liked_by_map: dict[int, list[str]] = {}
            comments_map: dict[int, int] = {}
            official_reply_ids: set[int] = set()
            if post_ids:
                likes_rows = (
                    s.execute(
                        _sa_select(
                            MomentLikeDB.post_id, _sa_func.count(MomentLikeDB.id)
                        ).where(MomentLikeDB.post_id.in_(post_ids)
                        ).group_by(MomentLikeDB.post_id)
                    )
                    .all()
                )
                for pid, cnt in likes_rows:
                    likes_map[int(pid)] = int(cnt)
                like_user_rows = (
                    s.execute(
                        _sa_select(MomentLikeDB.post_id, MomentLikeDB.user_key)
                        .where(MomentLikeDB.post_id.in_(post_ids))
                        .order_by(MomentLikeDB.created_at.asc(), MomentLikeDB.id.asc())
                    )
                    .all()
                )
                for pid, uk in like_user_rows:
                    try:
                        pid_int = int(pid)
                    except Exception:
                        continue
                    lst = liked_by_map.get(pid_int)
                    if lst is None:
                        lst = []
                        liked_by_map[pid_int] = lst
                    if len(lst) >= 8:
                        continue
                    try:
                        label = _moments_pseudonym_for_user_key(str(uk))
                    except Exception:
                        label = None
                    if label:
                        lst.append(label)
                comments_rows = (
                    s.execute(
                        _sa_select(
                            MomentCommentDB.post_id,
                            _sa_func.count(MomentCommentDB.id),
                        )
                        .where(MomentCommentDB.post_id.in_(post_ids))
                        .group_by(MomentCommentDB.post_id)
                    )
                    .all()
                )
                for pid, cnt in comments_rows:
                    comments_map[int(pid)] = int(cnt)
                official_rows = (
                    s.execute(
                        _sa_select(MomentCommentDB.post_id)
                        .where(
                            MomentCommentDB.post_id.in_(post_ids),
                            MomentCommentDB.user_key.like("official:%"),
                        )
                        .group_by(MomentCommentDB.post_id)
                    )
                    .scalars()
                    .all()
                )
                official_reply_ids = {int(pid) for pid in official_rows}
                my_likes = (
                    s.execute(
                        _sa_select(MomentLikeDB.post_id).where(
                            MomentLikeDB.post_id.in_(post_ids),
                            MomentLikeDB.user_key == user_key,
                        )
                    )
                    .scalars()
                    .all()
                )
                liked_by_me.update(int(pid) for pid in my_likes)
            out: list[dict[str, Any]] = []
            for row in rows:
                vis = (row.visibility or "public").strip().lower()
                if vis in ("only_me", "private") and row.user_key != user_key:
                    continue
                if vis in (
                    "friends",
                    "friends_only",
                    "close_friends",
                    "friends_tag",
                    "friends_except_tag",
                ) and row.user_key != user_key:
                    viewer_phone: str | None
                    author_phone: str | None
                    try:
                        viewer_phone = _auth_phone(request) or None
                    except Exception:
                        viewer_phone = None
                    try:
                        author_phone = _phone_from_moments_user_key(row.user_key)
                    except Exception:
                        author_phone = None
                    if not viewer_phone or not author_phone:
                        # Hide friends-only posts when we cannot validate the graph.
                        continue
                    try:
                        with _friends_session() as fs:
                            rel = fs.execute(
                                _sa_select(FriendDB).where(
                                    FriendDB.user_phone == viewer_phone,
                                    FriendDB.friend_phone == author_phone,
                                )
                            ).scalars().first()
                            if rel is None:
                                continue
                            if vis in ("close_friends", "friends_only"):
                                rel_cf = fs.execute(
                                    _sa_select(CloseFriendDB).where(
                                        CloseFriendDB.user_phone
                                        == author_phone,
                                        CloseFriendDB.friend_phone
                                        == viewer_phone,
                                    )
                                ).scalars().first()
                                if rel_cf is None:
                                    continue
                            if vis == "friends_tag":
                                tag = (
                                    getattr(row, "audience_tag", None) or ""
                                ).strip()
                                if tag:
                                    rel_tag = fs.execute(
                                        _sa_select(FriendTagDB).where(
                                            FriendTagDB.user_phone
                                            == author_phone,
                                            FriendTagDB.friend_phone
                                            == viewer_phone,
                                            FriendTagDB.tag == tag,
                                        )
                                    ).scalars().first()
                                    if rel_tag is None:
                                        continue
                            elif vis == "friends_except_tag":
                                tag = (
                                    getattr(row, "audience_tag", None) or ""
                                ).strip()
                                if tag:
                                    rel_tag = fs.execute(
                                        _sa_select(FriendTagDB).where(
                                            FriendTagDB.user_phone
                                            == author_phone,
                                            FriendTagDB.friend_phone
                                            == viewer_phone,
                                            FriendTagDB.tag == tag,
                                        )
                                    ).scalars().first()
                                    # If the viewer has this tag, they are excluded.
                                    if rel_tag is not None:
                                        continue
                    except Exception:
                        continue
                try:
                    ts = row.created_at
                except Exception:
                    ts = None
                ts_str = (
                    ts.isoformat().replace("+00:00", "Z")
                    if isinstance(ts, datetime)
                    else datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")
                )
                try:
                    author_label = _moments_pseudonym_for_user_key(row.user_key)
                except Exception:
                    author_label = None
                images: list[str] = []
                try:
                    raw_images = (getattr(row, "images_b64_json", None) or "").strip()
                    if raw_images:
                        decoded_images = json.loads(raw_images)
                        if isinstance(decoded_images, list):
                            for it in decoded_images:
                                try:
                                    s = (it or "").strip()
                                except Exception:
                                    s = ""
                                if not s:
                                    continue
                                images.append(s)
                                if len(images) >= 9:
                                    break
                except Exception:
                    images = []
                images_out = images if len(images) > 1 else None
                image_b64_out = row.image_b64 or (images[0] if images else None)
                out.append(
                    MomentPostOut(
                        id=str(row.id),
                        text=row.text,
                        ts=ts_str,
                        likes=likes_map.get(row.id, 0),
                        liked_by_me=row.id in liked_by_me,
                        liked_by=liked_by_map.get(row.id) or None,
                        comments=comments_map.get(row.id, 0),
                        has_official_reply=row.id in official_reply_ids,
                        visibility=row.visibility or "public",
                        image_b64=image_b64_out,
                        image_url=row.image_url,
                        author_name=author_label,
                        origin_official_account_id=getattr(
                            row, "origin_official_account_id", None
                        ),
                        origin_official_item_id=getattr(
                            row, "origin_official_item_id", None
                        ),
                        audience_tag=getattr(row, "audience_tag", None),
                        location_label=getattr(row, "location_label", None),
                        images=images_out,
                    ).dict()
                )
        try:
            emit_event(
                "moments",
                "feed_view",
                {"user_key": user_key, "count": len(out)},
            )
        except Exception:
            pass
        return {"items": out}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/moments/topic/{tag}", response_class=JSONResponse)
def moments_topic(
    request: Request,
    tag: str,
    limit: int = 50,
):
    """
    Returns latest Moments posts for a given hashtag/topic.

    Hashtags are stored without the leading '#', case-insensitive.
    """
    user_key = _moments_cookie_key(request)
    tag_norm = (tag or "").strip().lstrip("#").lower()
    if not tag_norm:
        return {"items": []}
    try:
        limit_val = max(1, min(limit, 100))
        with _moments_session() as s:
            stmt = (
                _sa_select(MomentPostDB)
                .join(MomentTagDB, MomentTagDB.post_id == MomentPostDB.id)
                .where(MomentTagDB.tag == tag_norm)
                .order_by(MomentPostDB.created_at.desc(), MomentPostDB.id.desc())
                .limit(limit_val)
            )
            rows = s.execute(stmt).scalars().all()
            post_ids = [r.id for r in rows]
            likes_map: dict[int, int] = {}
            liked_by_me: set[int] = set()
            liked_by_map: dict[int, list[str]] = {}
            comments_map: dict[int, int] = {}
            official_reply_ids: set[int] = set()
            if post_ids:
                likes_rows = (
                    s.execute(
                        _sa_select(
                            MomentLikeDB.post_id, _sa_func.count(MomentLikeDB.id)
                        )
                        .where(MomentLikeDB.post_id.in_(post_ids))
                        .group_by(MomentLikeDB.post_id)
                    )
                    .all()
                )
                for pid, cnt in likes_rows:
                    likes_map[int(pid)] = int(cnt)
                like_user_rows = (
                    s.execute(
                        _sa_select(MomentLikeDB.post_id, MomentLikeDB.user_key)
                        .where(MomentLikeDB.post_id.in_(post_ids))
                        .order_by(MomentLikeDB.created_at.asc(), MomentLikeDB.id.asc())
                    )
                    .all()
                )
                for pid, uk in like_user_rows:
                    try:
                        pid_int = int(pid)
                    except Exception:
                        continue
                    lst = liked_by_map.get(pid_int)
                    if lst is None:
                        lst = []
                        liked_by_map[pid_int] = lst
                    if len(lst) >= 8:
                        continue
                    try:
                        label = _moments_pseudonym_for_user_key(str(uk))
                    except Exception:
                        label = None
                    if label:
                        lst.append(label)
                comments_rows = (
                    s.execute(
                        _sa_select(
                            MomentCommentDB.post_id,
                            _sa_func.count(MomentCommentDB.id),
                        )
                        .where(MomentCommentDB.post_id.in_(post_ids))
                        .group_by(MomentCommentDB.post_id)
                    )
                    .all()
                )
                for pid, cnt in comments_rows:
                    comments_map[int(pid)] = int(cnt)
                official_rows = (
                    s.execute(
                        _sa_select(MomentCommentDB.post_id)
                        .where(
                            MomentCommentDB.post_id.in_(post_ids),
                            MomentCommentDB.user_key.like("official:%"),
                        )
                        .group_by(MomentCommentDB.post_id)
                    )
                    .scalars()
                    .all()
                )
                official_reply_ids = {int(pid) for pid in official_rows}
                my_likes = (
                    s.execute(
                        _sa_select(MomentLikeDB.post_id).where(
                            MomentLikeDB.post_id.in_(post_ids),
                            MomentLikeDB.user_key == user_key,
                        )
                    )
                    .scalars()
                    .all()
                )
                liked_by_me.update(int(pid) for pid in my_likes)
            out: list[dict[str, Any]] = []
            for row in rows:
                if row.visibility in ("only_me", "private") and row.user_key != user_key:
                    continue
                if row.visibility in ("friends", "friends_only", "close_friends") and row.user_key != user_key:
                    viewer_phone: str | None
                    author_phone: str | None
                    try:
                        viewer_phone = _auth_phone(request) or None
                    except Exception:
                        viewer_phone = None
                    try:
                        author_phone = _phone_from_moments_user_key(row.user_key)
                    except Exception:
                        author_phone = None
                    if not viewer_phone or not author_phone:
                        continue
                    try:
                        with _friends_session() as fs:
                            rel = fs.execute(
                                _sa_select(FriendDB).where(
                                    (
                                        (FriendDB.user_phone == author_phone)
                                        & (FriendDB.friend_phone == viewer_phone)
                                    )
                                    | (
                                        (FriendDB.user_phone == viewer_phone)
                                        & (FriendDB.friend_phone == author_phone)
                                    )
                                )
                            ).scalars().first()
                            if rel is None:
                                continue
                            if row.visibility in ("close_friends", "friends_only"):
                                rel_cf = fs.execute(
                                    _sa_select(CloseFriendDB).where(
                                        CloseFriendDB.user_phone
                                        == author_phone,
                                        CloseFriendDB.friend_phone
                                        == viewer_phone,
                                    )
                                ).scalars().first()
                                if rel_cf is None:
                                    continue
                    except Exception:
                        continue
                try:
                    ts = row.created_at
                except Exception:
                    ts = None
                ts_str = (
                    ts.isoformat().replace("+00:00", "Z")
                    if isinstance(ts, datetime)
                    else datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")
                )
                try:
                    author_label = _moments_pseudonym_for_user_key(row.user_key)
                except Exception:
                    author_label = None
                images: list[str] = []
                try:
                    raw_images = (getattr(row, "images_b64_json", None) or "").strip()
                    if raw_images:
                        decoded_images = json.loads(raw_images)
                        if isinstance(decoded_images, list):
                            for it in decoded_images:
                                try:
                                    s = (it or "").strip()
                                except Exception:
                                    s = ""
                                if not s:
                                    continue
                                images.append(s)
                                if len(images) >= 9:
                                    break
                except Exception:
                    images = []
                images_out = images if len(images) > 1 else None
                image_b64_out = row.image_b64 or (images[0] if images else None)
                out.append(
                    MomentPostOut(
                        id=str(row.id),
                        text=row.text,
                        ts=ts_str,
                        likes=likes_map.get(row.id, 0),
                        liked_by_me=row.id in liked_by_me,
                        liked_by=liked_by_map.get(row.id) or None,
                        comments=comments_map.get(row.id, 0),
                        has_official_reply=row.id in official_reply_ids,
                        visibility=row.visibility or "public",
                        image_b64=image_b64_out,
                        image_url=row.image_url,
                        author_name=author_label,
                        origin_official_account_id=getattr(
                            row, "origin_official_account_id", None
                        ),
                        origin_official_item_id=getattr(
                            row, "origin_official_item_id", None
                        ),
                        audience_tag=getattr(row, "audience_tag", None),
                        location_label=getattr(row, "location_label", None),
                        images=images_out,
                    ).dict()
                )
        try:
            emit_event(
                "moments",
                "topic_view",
                {"user_key": user_key, "tag": tag_norm, "count": len(out)},
            )
        except Exception:
            pass
        return {"items": out}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


class MomentPostIn(BaseModel):
    text: str
    visibility: str = "public"
    image_b64: str | None = None
    images_b64: list[str] | None = None
    location_label: str | None = None


class MomentPostUpdateIn(BaseModel):
    visibility: str | None = None


class MomentCommentIn(BaseModel):
    text: str
    reply_to_id: int | None = None


class MomentReportIn(BaseModel):
    reason: str | None = None


@app.post("/moments", response_class=JSONResponse)
def moments_create(request: Request, body: MomentPostIn):
    """
    Creates a new moment for the current user.
    """
    user_key = _moments_cookie_key(request)
    text = (body.text or "").strip()
    images: list[str] = []
    seen_images: set[str] = set()
    for raw in body.images_b64 or []:
        try:
            s = (raw or "").strip()
        except Exception:
            s = ""
        if not s:
            continue
        if s in seen_images:
            continue
        seen_images.add(s)
        images.append(s)
        if len(images) >= 9:
            break
    if not images:
        single = (body.image_b64 or "").strip()
        if single:
            images.append(single)
    if not text and not images:
        raise HTTPException(status_code=400, detail="empty moment")
    visibility_raw = (body.visibility or "public").strip()
    visibility_norm = visibility_raw.lower()
    visibility = visibility_norm
    audience_tag: str | None = None
    if visibility_norm.startswith("tag:"):
        # Visibility restricted to friends with a specific tag label.
        visibility = "friends_tag"
        # Preserve the original label casing after the "tag:" prefix so it
        # matches the user's contact label (e.g. "Family", "Work").
        audience_tag = visibility_raw.split(":", 1)[1].strip() or None
    elif visibility_norm.startswith("friends_except:"):
        # Visibility: all friends except those with a specific tag.
        visibility = "friends_except_tag"
        audience_tag = visibility_raw.split(":", 1)[1].strip() or None
    if visibility not in {
        "public",
        "friends",
        "friends_only",
        "close_friends",
        "only_me",
        "private",
        "friends_tag",
        "friends_except_tag",
    }:
        visibility = "public"
        audience_tag = None
    origin_acc_id, origin_item_id = _moments_extract_official_origin(text)
    tags = _moments_extract_tags(text)
    location_label = (body.location_label or "").strip()
    if location_label:
        location_label = location_label[:128]
    images_json: str | None = None
    if len(images) > 1:
        try:
            images_json = json.dumps(images)
        except Exception:
            images_json = None
    image_b64 = images[0] if images else None
    try:
        with _moments_session() as s:
            row = MomentPostDB(
                user_key=user_key,
                text=text,
                visibility=visibility,
                audience_tag=audience_tag,
                location_label=location_label or None,
                images_b64_json=images_json,
                image_b64=image_b64,
                origin_official_account_id=origin_acc_id,
                origin_official_item_id=origin_item_id,
            )
            s.add(row)
            s.commit()
            s.refresh(row)
            if tags:
                for tag in tags:
                    try:
                        s.add(MomentTagDB(post_id=row.id, tag=tag))
                    except Exception:
                        # Best-effort; ignore duplicates or failures.
                        pass
                try:
                    s.commit()
                except Exception:
                    s.rollback()
            ts = row.created_at
            ts_str = (
                ts.isoformat().replace("+00:00", "Z")
                if isinstance(ts, datetime)
                else datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")
            )
            try:
                author_label = _moments_pseudonym_for_user_key(row.user_key)
            except Exception:
                author_label = None
            out = MomentPostOut(
                id=str(row.id),
                text=row.text,
                ts=ts_str,
                likes=0,
                liked_by_me=False,
                has_official_reply=False,
                visibility=row.visibility or "public",
                image_b64=row.image_b64,
                image_url=row.image_url,
                author_name=author_label,
                audience_tag=row.audience_tag,
                location_label=getattr(row, "location_label", None),
                images=images if len(images) > 1 else None,
            ).dict()
        try:
            emit_event(
                "moments",
                "post_create",
                {"user_key": user_key},
            )
        except Exception:
            pass
        return out
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.patch("/moments/{post_id}", response_class=JSONResponse)
def moments_update(post_id: int, request: Request, body: MomentPostUpdateIn):
    """
    Updates selected fields of a Moments post (currently visibility/audience_tag)
    for the post owner.
    """
    user_key = _moments_cookie_key(request)
    try:
        with _moments_session() as s:
            post = s.get(MomentPostDB, post_id)
            if not post:
                raise HTTPException(status_code=404, detail="moment not found")
            if post.user_key != user_key:
                raise HTTPException(status_code=403, detail="forbidden")
            changed = False
            visibility_raw = (
                (body.visibility or "").strip()
                if body.visibility is not None
                else ""
            )
            if visibility_raw:
                visibility_norm = visibility_raw.lower()
                visibility = visibility_norm
                audience_tag: str | None = None
                if visibility_norm.startswith("tag:"):
                    visibility = "friends_tag"
                    audience_tag = visibility_raw.split(":", 1)[1].strip() or None
                elif visibility_norm.startswith("friends_except:"):
                    visibility = "friends_except_tag"
                    audience_tag = visibility_raw.split(":", 1)[1].strip() or None
                if visibility not in {
                    "public",
                    "friends",
                    "friends_only",
                    "close_friends",
                    "only_me",
                    "private",
                    "friends_tag",
                    "friends_except_tag",
                }:
                    visibility = "public"
                    audience_tag = None
                post.visibility = visibility
                setattr(post, "audience_tag", audience_tag)
                changed = True
            if changed:
                s.commit()
            return {
                "status": "ok",
                "visibility": getattr(post, "visibility", "public"),
                "audience_tag": getattr(post, "audience_tag", None),
            }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/moments/{post_id}/report", response_class=JSONResponse)
def moments_report(post_id: int, request: Request, body: MomentReportIn | None = None):
    """
    Lightweight report endpoint for Moments posts.
    Does not persist anything, but emits an analytics/moderation event
    that backoffice tooling can consume.
    """
    user_key = _moments_cookie_key(request)
    reason = ""
    try:
        if body is not None:
            reason = (body.reason or "").strip()
        with _moments_session() as s:
            post = s.get(MomentPostDB, post_id)
            if not post:
                raise HTTPException(status_code=404, detail="moment not found")
        try:
            emit_event(
                "moments",
                "post_report",
                {
                    "user_key": user_key,
                    "post_id": post_id,
                    "reason": reason[:280] if reason else "",
                },
            )
        except Exception:
            # Reporting should never break the client.
            pass
        return {"status": "ok"}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/moments/{post_id}/like", response_class=JSONResponse)
def moments_like(post_id: int, request: Request):
    """
    Idempotent like endpoint; increments like count once per user.
    """
    user_key = _moments_cookie_key(request)
    try:
        send_push = False
        post_author_phone: str | None = None
        with _moments_session() as s:
            post = s.get(MomentPostDB, post_id)
            if not post:
                raise HTTPException(status_code=404, detail="moment not found")
            existing = (
                s.execute(
                    _sa_select(MomentLikeDB).where(
                        MomentLikeDB.post_id == post_id,
                        MomentLikeDB.user_key == user_key,
                    )
                )
                .scalars()
                .first()
            )
            if existing is None:
                like = MomentLikeDB(post_id=post_id, user_key=user_key)
                s.add(like)
                s.commit()
                send_push = True
            try:
                post_author_phone = _phone_from_moments_user_key(post.user_key)
            except Exception:
                post_author_phone = None
        try:
            emit_event(
                "moments",
                "post_like",
                {"user_key": user_key, "post_id": post_id},
            )
        except Exception:
            pass
        # Fire-and-forget push notification to post author (if different user)
        if send_push and post_author_phone:
            try:
                liker_phone = _auth_phone(request) or ""
            except Exception:
                liker_phone = ""
            if liker_phone != post_author_phone:
                try:
                    loop = asyncio.get_event_loop()
                    if loop.is_running():
                        loop.create_task(
                            _send_driver_push(
                                post_author_phone,
                                "New like on your Moment",
                                f"Your post #{post_id} received a new like.",
                                {"type": "moments_post_like", "post_id": post_id},
                            )
                        )
                except Exception:
                    pass
        return {"status": "ok"}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.delete("/moments/{post_id}/like", response_class=JSONResponse)
def moments_unlike(post_id: int, request: Request):
    """
    Idempotent unlike endpoint; removes the user's like when present.
    """
    user_key = _moments_cookie_key(request)
    try:
        with _moments_session() as s:
            post = s.get(MomentPostDB, post_id)
            if not post:
                raise HTTPException(status_code=404, detail="moment not found")
            existing = (
                s.execute(
                    _sa_select(MomentLikeDB).where(
                        MomentLikeDB.post_id == post_id,
                        MomentLikeDB.user_key == user_key,
                    )
                )
                .scalars()
                .first()
            )
            if existing is not None:
                s.delete(existing)
                s.commit()
        try:
            emit_event(
                "moments",
                "post_unlike",
                {"user_key": user_key, "post_id": post_id},
            )
        except Exception:
            pass
        return {"status": "ok"}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/moments/notifications", response_class=JSONResponse)
def moments_notifications(request: Request) -> dict[str, Any]:
    """
    Aggregated notification info for Moments:
    latest comment timestamp on the user's posts (excluding own comments)
    and total comment count.
    """
    user_key = _moments_cookie_key(request)
    try:
        with _moments_session() as s:
            post_ids = (
                s.execute(
                    _sa_select(MomentPostDB.id).where(
                        MomentPostDB.user_key == user_key
                    )
                )
                .scalars()
                .all()
            )
            if not post_ids:
                return MomentNotificationsOut(
                    last_comment_ts=None, total_comments=0, redpacket_posts_30d=0
                ).dict()

            row = (
                s.execute(
                    _sa_select(
                        _sa_func.count(MomentCommentDB.id),
                        _sa_func.max(MomentCommentDB.created_at),
                    ).where(
                        MomentCommentDB.post_id.in_(post_ids),
                        MomentCommentDB.user_key != user_key,
                    )
                )
                .first()
            )
            cnt = 0
            last_dt: Any = None
            if row:
                cnt, last_dt = row
            total = int(cnt or 0)

            # Red-packet mentions on my Moments in the last 30 days
            redpacket_30d = 0
            try:
                since = datetime.now(timezone.utc) - timedelta(days=30)
                rp_stmt = _sa_select(_sa_func.count(MomentPostDB.id)).where(
                    MomentPostDB.user_key == user_key,
                    MomentPostDB.created_at >= since,
                    (
                        MomentPostDB.text.contains("Red packet")
                        | MomentPostDB.text.contains(
                            "I am sending red packets via Shamell Pay"
                        )
                        | MomentPostDB.text.contains("حزمة حمراء")
                    ),
                )
                rp_count = s.execute(rp_stmt).scalar() or 0
                redpacket_30d = int(rp_count)
            except Exception:
                redpacket_30d = 0

            if not last_dt:
                return MomentNotificationsOut(
                    last_comment_ts=None,
                    total_comments=total,
                    redpacket_posts_30d=redpacket_30d,
                ).dict()
            ts_str = (
                last_dt.isoformat().replace("+00:00", "Z")
                if isinstance(last_dt, datetime)
                else datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")
            )
            return MomentNotificationsOut(
                last_comment_ts=ts_str,
                total_comments=total,
                redpacket_posts_30d=redpacket_30d,
            ).dict()
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/me/official_moments_stats", response_class=JSONResponse)
def me_official_moments_stats(request: Request) -> dict[str, Any]:
    """
    Aggregated Moments share counts per Official kind for the current user.

    Counts how many Moments the user has posted that originate from
    service vs. subscription Official accounts (based on origin_official_account_id).
    """
    user_key = _moments_cookie_key(request)
    try:
        # Collect per-account share counts for this user's Moments.
        per_account: dict[str, int] = {}
        per_account_30d: dict[str, int] = {}
        with _moments_session() as ms:
            since_30 = datetime.now(timezone.utc) - timedelta(days=30)
            rows = (
                ms.execute(
                    _sa_select(
                        MomentPostDB.origin_official_account_id,
                        _sa_func.count(MomentPostDB.id),
                    )
                    .where(
                        MomentPostDB.user_key == user_key,
                        MomentPostDB.origin_official_account_id.is_not(None),
                    )
                    .group_by(MomentPostDB.origin_official_account_id)
                )
                .all()
            )
            for acc_id, cnt in rows:
                if not acc_id:
                    continue
                per_account[str(acc_id)] = int(cnt or 0)
            # Last 30 days counts per official for this user.
            try:
                rows_30 = (
                    ms.execute(
                        _sa_select(
                            MomentPostDB.origin_official_account_id,
                            _sa_func.count(MomentPostDB.id),
                        )
                        .where(
                            MomentPostDB.user_key == user_key,
                            MomentPostDB.origin_official_account_id.is_not(
                                None
                            ),
                            MomentPostDB.created_at >= since_30,
                        )
                        .group_by(MomentPostDB.origin_official_account_id)
                    )
                    .all()
                )
                for acc_id, cnt in rows_30:
                    if not acc_id:
                        continue
                    per_account_30d[str(acc_id)] = int(cnt or 0)
            except Exception:
                per_account_30d = {}
        if not per_account:
            return OfficialMomentsStatsOut(
                service_shares=0,
                subscription_shares=0,
                total_shares=0,
                redpacket_shares_30d=0,
                hot_accounts=0,
            ).dict()

        # Look up Official kind per account_id.
        service_shares = 0
        subscription_shares = 0
        hot_accounts = 0
        acc_ids = list(per_account.keys())
        try:
            with _officials_session() as os:
                acc_rows = (
                    os.execute(
                        _sa_select(
                            OfficialAccountDB.id,
                            OfficialAccountDB.kind,
                        ).where(OfficialAccountDB.id.in_(acc_ids))
                    )
                    .all()
                )
                kinds: dict[str, str] = {}
                for acc_id, kind in acc_rows:
                    kinds[str(acc_id)] = (kind or "service").strip().lower()
        except Exception:
            kinds = {}

        for acc_id, cnt in per_account.items():
            kind = kinds.get(acc_id, "service")
            if kind == "service":
                service_shares += cnt
            else:
                subscription_shares += cnt
            try:
                recent_cnt = int(per_account_30d.get(acc_id, 0) or 0)
                # Hot if either strong all-time or active in last 30 days.
                if int(cnt) >= 10 or recent_cnt >= 3:
                    hot_accounts += 1
            except Exception:
                continue

        total_shares = int(service_shares + subscription_shares)

        # Red-packet Moments by this user in the last 30 days (with official origin)
        redpacket_30d = 0
        try:
            since = datetime.now(timezone.utc) - timedelta(days=30)
            rp_rows = (
                ms.execute(  # type: ignore[name-defined]
                    _sa_select(_sa_func.count(MomentPostDB.id)).where(
                        MomentPostDB.user_key == user_key,
                        MomentPostDB.origin_official_account_id.is_not(None),
                        MomentPostDB.created_at >= since,
                        (
                            MomentPostDB.text.contains("Red packet")
                            | MomentPostDB.text.contains(
                                "I am sending red packets via Shamell Pay"
                            )
                            | MomentPostDB.text.contains("حزمة حمراء")
                        ),
                    )
                )
                .scalar()
                or 0
            )
            redpacket_30d = int(rp_rows)
        except Exception:
            redpacket_30d = 0

        return OfficialMomentsStatsOut(
            service_shares=service_shares,
            subscription_shares=subscription_shares,
            total_shares=total_shares,
            redpacket_shares_30d=redpacket_30d,
            hot_accounts=hot_accounts,
        ).dict()
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/moments/{post_id}/comments", response_class=JSONResponse)
def moments_comments(post_id: int, request: Request, limit: int = 100):
    """
    Returns comments for a given moment post.
    """
    user_key = _moments_cookie_key(request)
    try:
        limit_val = max(1, min(limit, 200))
        with _moments_session() as s:
            post = s.get(MomentPostDB, post_id)
            if not post:
                raise HTTPException(status_code=404, detail="moment not found")
            stmt = (
                _sa_select(MomentCommentDB)
                .where(MomentCommentDB.post_id == post_id)
                .order_by(
                    MomentCommentDB.created_at.asc(), MomentCommentDB.id.asc()
                )
                .limit(limit_val)
            )
            rows = s.execute(stmt).scalars().all()
            comment_ids = [r.id for r in rows]
            # Build stable but privacy-friendly labels from user_key
            label_map: dict[str, str] = {}
            likes_map: dict[int, int] = {}
            liked_set: set[int] = set()
            if comment_ids:
                likes_rows = (
                    s.execute(
                        _sa_select(
                            MomentCommentLikeDB.comment_id,
                            _sa_func.count(MomentCommentLikeDB.id),
                        )
                        .where(MomentCommentLikeDB.comment_id.in_(comment_ids))
                        .group_by(MomentCommentLikeDB.comment_id)
                    )
                    .all()
                )
                for cid, cnt in likes_rows:
                    likes_map[int(cid)] = int(cnt or 0)
                liked_rows = (
                    s.execute(
                        _sa_select(MomentCommentLikeDB.comment_id).where(
                            MomentCommentLikeDB.comment_id.in_(comment_ids),
                            MomentCommentLikeDB.user_key == user_key,
                        )
                    )
                    .scalars()
                    .all()
                )
                liked_set.update(int(cid) for cid in liked_rows)
            items: list[dict[str, Any]] = []
            for row in rows:
                ts = row.created_at
                ts_str = (
                    ts.isoformat().replace("+00:00", "Z")
                    if isinstance(ts, datetime)
                    else datetime.now(timezone.utc)
                    .isoformat()
                    .replace("+00:00", "Z")
                )
                author = None
                try:
                    uk = (row.user_key or "").strip()
                    if uk:
                        if uk.startswith("official:"):
                            author = f"Official · {uk.split(':', 1)[1]}"
                        elif uk in label_map:
                            author = label_map[uk]
                        else:
                            import hashlib

                            h = hashlib.sha256(uk.encode("utf-8")).hexdigest()[:6]
                            author = f"User {h}"
                            label_map[uk] = author
                except Exception:
                    author = None
                items.append(
                    MomentCommentOut(
                        id=str(row.id),
                        text=row.text,
                        ts=ts_str,
                        author_name=author,
                        reply_to_id=str(row.reply_to_id)
                        if getattr(row, "reply_to_id", None)
                        else None,
                        reply_to_name=None,
                        likes=likes_map.get(row.id, 0),
                        liked_by_me=row.id in liked_set,
                    ).dict()
                )
        return {"items": items}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/moments/{post_id}/comments", response_class=JSONResponse)
def moments_add_comment(post_id: int, request: Request, body: MomentCommentIn):
    """
    Adds a new comment to a moment post.
    """
    user_key = _moments_cookie_key(request)
    text = (body.text or "").strip()
    if not text:
        raise HTTPException(status_code=400, detail="empty comment")
    reply_to_id = body.reply_to_id
    try:
        post_author_phone: str | None = None
        commenter_phone: str | None = None
        with _moments_session() as s:
            post = s.get(MomentPostDB, post_id)
            if not post:
                raise HTTPException(status_code=404, detail="moment not found")
            if reply_to_id is not None:
                target = s.get(MomentCommentDB, reply_to_id)
                if not target or target.post_id != post_id:
                    reply_to_id = None
            row = MomentCommentDB(
                post_id=post_id,
                user_key=user_key,
                text=text,
                reply_to_id=reply_to_id,
            )
            s.add(row)
            s.commit()
            s.refresh(row)
            ts = row.created_at
            ts_str = (
                ts.isoformat().replace("+00:00", "Z")
                if isinstance(ts, datetime)
                else datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")
            )
            author = None
            try:
                uk = (row.user_key or "").strip()
                if uk:
                    import hashlib

                    h = hashlib.sha256(uk.encode("utf-8")).hexdigest()[:6]
                    author = f"User {h}"
            except Exception:
                author = None
            out = MomentCommentOut(
                id=str(row.id),
                text=row.text,
                ts=ts_str,
                author_name=author,
                reply_to_id=str(row.reply_to_id)
                if getattr(row, "reply_to_id", None)
                else None,
                reply_to_name=None,
            ).dict()
            try:
                post_author_phone = _phone_from_moments_user_key(post.user_key)
            except Exception:
                post_author_phone = None
        try:
            commenter_phone = _auth_phone(request) or None
        except Exception:
            commenter_phone = None
        try:
            emit_event(
                "moments",
                "comment_create",
                {"user_key": user_key, "post_id": post_id},
            )
        except Exception:
            pass
        # Fire-and-forget push notification to post author (if different user)
        if post_author_phone and commenter_phone != post_author_phone:
            try:
                loop = asyncio.get_event_loop()
                if loop.is_running():
                    loop.create_task(
                        _send_driver_push(
                            post_author_phone,
                            "New comment on your Moment",
                            text[:120],
                            {
                                "type": "moments_comment",
                                "post_id": post_id,
                                "comment_id": row.id,
                            },
                        )
                    )
            except Exception:
                pass
        return out
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/moments/admin", response_class=JSONResponse)
def moments_admin_list(
    request: Request,
    limit: int = 100,
    redpacket_only: bool = False,
    origin_official_account_id: str | None = None,
    origin_official_item_id: str | None = None,
    campaign_id: str | None = None,
) -> dict[str, Any]:
    """
    Simple debug listing for Moments posts (QA only).
    Shows latest posts with basic metadata and like counts.
    """
    _require_admin_v2(request)
    try:
        limit_val = max(1, min(limit, 200))
        with _moments_session() as s:
            stmt = _sa_select(MomentPostDB)
            if redpacket_only:
                stmt = stmt.where(
                    MomentPostDB.text.contains("Red packet")
                    | MomentPostDB.text.contains(
                        "I am sending red packets via Shamell Pay"
                    )
                    | MomentPostDB.text.contains("حزمة حمراء")
                )
            if origin_official_account_id:
                stmt = stmt.where(
                    MomentPostDB.origin_official_account_id
                    == origin_official_account_id
                )
            target_item = origin_official_item_id or campaign_id
            if target_item:
                stmt = stmt.where(
                    MomentPostDB.origin_official_item_id == target_item
                )
            stmt = stmt.order_by(
                MomentPostDB.created_at.desc(), MomentPostDB.id.desc()
            ).limit(limit_val)
            rows = s.execute(stmt).scalars().all()
            post_ids = [r.id for r in rows]
            likes_map: dict[int, int] = {}
            comments_map: dict[int, int] = {}
            if post_ids:
                likes_rows = (
                    s.execute(
                        _sa_select(
                            MomentLikeDB.post_id, _sa_func.count(MomentLikeDB.id)
                        ).where(MomentLikeDB.post_id.in_(post_ids)
                        ).group_by(MomentLikeDB.post_id)
                    )
                    .all()
                )
                for pid, cnt in likes_rows:
                    likes_map[int(pid)] = int(cnt)
                comments_rows = (
                    s.execute(
                        _sa_select(
                            MomentCommentDB.post_id, _sa_func.count(MomentCommentDB.id)
                        ).where(MomentCommentDB.post_id.in_(post_ids)
                        ).group_by(MomentCommentDB.post_id)
                    )
                    .all()
                )
                for pid, cnt in comments_rows:
                    comments_map[int(pid)] = int(cnt)
            items: list[dict[str, Any]] = []
            for row in rows:
                ts = row.created_at
                ts_str = (
                    ts.isoformat().replace("+00:00", "Z")
                    if isinstance(ts, datetime)
                    else datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")
                )
                items.append(
                    {
                        "id": row.id,
                        "user_key": row.user_key,
                        "text": row.text,
                        "visibility": row.visibility,
                        "created_at": ts_str,
                        "likes": likes_map.get(row.id, 0),
                        "has_image": bool(row.image_b64 or row.image_url),
                        "origin_official_account_id": getattr(
                            row, "origin_official_account_id", None
                        ),
                        "origin_official_item_id": getattr(
                            row, "origin_official_item_id", None
                        ),
                    }
                )
        return {"items": items}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/moments/topics/trending", response_class=JSONResponse)
def moments_trending_topics(request: Request, limit: int = 10) -> dict[str, Any]:
    """
    Returns simple trending hashtags for Moments.

    Currently ranks by total occurrences across all posts (best-effort).
    """
    user_key = _moments_cookie_key(request)
    try:
        limit_val = max(1, min(limit, 50))
        with _moments_session() as s:
            rows = (
                s.execute(
                    _sa_select(MomentTagDB.tag, _sa_func.count(MomentTagDB.id))
                    .group_by(MomentTagDB.tag)
                    .order_by(_sa_func.count(MomentTagDB.id).desc())
                    .limit(limit_val)
                )
                .all()
            )
        items: list[dict[str, Any]] = []
        for tag, cnt in rows:
            items.append(
                {
                    "tag": str(tag or ""),
                    "count": int(cnt or 0),
                }
            )
        try:
            emit_event(
                "moments",
                "trending_topics_view",
                {"user_key": user_key, "count": len(items)},
            )
        except Exception:
            pass
        return {"items": items}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/moments/admin/comments", response_class=JSONResponse)
def moments_admin_comments(
    request: Request,
    post_id: int | None = None,
    limit: int = 100,
    official_account_id: str | None = None,
) -> dict[str, Any]:
    """
    Admin JSON view for comments, optionally filtered by post_id.
    """
    _require_admin_v2(request)
    try:
        limit_val = max(1, min(limit, 500))
        with _moments_session() as s:
            stmt = (
                _sa_select(MomentCommentDB)
                .order_by(
                    MomentCommentDB.created_at.desc(),
                    MomentCommentDB.id.desc(),
                )
                .limit(limit_val)
            )
            if official_account_id:
                stmt = (
                    stmt.join(
                        MomentPostDB,
                        MomentCommentDB.post_id == MomentPostDB.id,
                    ).where(
                        MomentPostDB.origin_official_account_id
                        == official_account_id
                    )
                )
            if post_id is not None:
                stmt = stmt.where(MomentCommentDB.post_id == post_id)
            rows = s.execute(stmt).scalars().all()
            items: list[dict[str, Any]] = []
            for row in rows:
                ts = row.created_at
                ts_str = (
                    ts.isoformat().replace("+00:00", "Z")
                    if isinstance(ts, datetime)
                    else datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")
                )
                items.append(
                    {
                        "id": row.id,
                        "post_id": row.post_id,
                        "user_key": row.user_key,
                        "text": row.text,
                        "created_at": ts_str,
                        "reply_to_id": row.reply_to_id,
                    }
                )
        return {"items": items}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.delete("/moments/admin/comments/{comment_id}", response_class=JSONResponse)
def moments_admin_delete_comment(comment_id: int, request: Request) -> dict[str, Any]:
    """
    Deletes a single comment (admin only).
    """
    _require_admin_v2(request)
    try:
        with _moments_session() as s:
            row = s.get(MomentCommentDB, comment_id)
            if not row:
                raise HTTPException(status_code=404, detail="comment not found")
            s.delete(row)
            s.commit()
        return {"status": "ok"}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.delete("/moments/comments/{comment_id}", response_class=JSONResponse)
def moments_delete_comment(comment_id: int, request: Request) -> dict[str, Any]:
    """
    Deletes a comment if it belongs to the current user (or admin).
    """
    user_key = _moments_cookie_key(request)
    try:
        with _moments_session() as s:
            row = s.get(MomentCommentDB, comment_id)
            if not row:
                raise HTTPException(status_code=404, detail="comment not found")
            is_admin = False
            try:
                _require_admin_v2(request)
                is_admin = True
            except Exception:
                is_admin = False
            if not is_admin and (row.user_key or "") != user_key:
                raise HTTPException(status_code=403, detail="forbidden")

            likes = (
                s.execute(
                    _sa_select(MomentCommentLikeDB).where(
                        MomentCommentLikeDB.comment_id == comment_id
                    )
                )
                .scalars()
                .all()
            )
            for like_row in likes:
                s.delete(like_row)
            s.delete(row)
            s.commit()
        return {"status": "ok"}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


class MomentAdminReplyIn(BaseModel):
    text: str
    official_account_id: str
    reply_to_id: int | None = None


@app.post("/moments/comments/{comment_id}/like", response_class=JSONResponse)
def moments_comment_like(comment_id: int, request: Request) -> dict[str, Any]:
    """
    Idempotent like endpoint for Moments comments.
    """
    user_key = _moments_cookie_key(request)
    try:
        send_push = False
        comment_author_phone: str | None = None
        post_id: int | None = None
        with _moments_session() as s:
            comment = s.get(MomentCommentDB, comment_id)
            if not comment:
                raise HTTPException(status_code=404, detail="comment not found")
            post_id = int(comment.post_id)
            existing = (
                s.execute(
                    _sa_select(MomentCommentLikeDB).where(
                        MomentCommentLikeDB.comment_id == comment_id,
                        MomentCommentLikeDB.user_key == user_key,
                    )
                )
                .scalars()
                .first()
            )
            if existing is None:
                row = MomentCommentLikeDB(comment_id=comment_id, user_key=user_key)
                s.add(row)
                s.commit()
                send_push = True
            likes = (
                s.execute(
                    _sa_select(_sa_func.count(MomentCommentLikeDB.id)).where(
                        MomentCommentLikeDB.comment_id == comment_id
                    )
                )
                .scalar()
                or 0
            )
            try:
                comment_author_phone = _phone_from_moments_user_key(comment.user_key)
            except Exception:
                comment_author_phone = None
        try:
            emit_event(
                "moments",
                "comment_like",
                {
                    "user_key": user_key,
                    "comment_id": comment_id,
                    "post_id": post_id,
                },
            )
        except Exception:
            pass
        # Fire-and-forget push notification to comment author (if different user)
        if send_push and comment_author_phone:
            try:
                liker_phone = _auth_phone(request) or ""
            except Exception:
                liker_phone = ""
            if liker_phone != comment_author_phone:
                try:
                    loop = asyncio.get_event_loop()
                    if loop.is_running():
                        loop.create_task(
                            _send_driver_push(
                                comment_author_phone,
                                "New like on your comment",
                                f"Your comment on post #{post_id} received a new like.",
                                {
                                    "type": "moments_comment_like",
                                    "comment_id": comment_id,
                                    "post_id": post_id,
                                },
                            )
                        )
                except Exception:
                    pass
        return {"likes": int(likes), "liked_by_me": True}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/me/friends", response_class=JSONResponse)
def me_friends(request: Request) -> dict[str, Any]:
    """
    Returns the current user's friends (simple phone-based graph).
    """
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    try:
        with _friends_session() as s:
            rows = (
                s.execute(
                    _sa_select(FriendDB).where(FriendDB.user_phone == phone)
                )
                .scalars()
                .all()
            )
            # Preload close-friend flags for this user for convenience.
            cf_rows = (
                s.execute(
                    _sa_select(CloseFriendDB.friend_phone).where(
                        CloseFriendDB.user_phone == phone
                    )
                )
                .scalars()
                .all()
            )
            cf_set = {r for r in cf_rows}
            # Preload tags per friend for this user.
            tag_rows = (
                s.execute(
                    _sa_select(
                        FriendTagDB.friend_phone, FriendTagDB.tag
                    ).where(FriendTagDB.user_phone == phone)
                )
                .all()
            )
            tags_map: dict[str, list[str]] = {}
            for fp, tag in tag_rows:
                try:
                    f = (fp or "").strip()
                    t = (tag or "").strip()
                except Exception:
                    continue
                if not f or not t:
                    continue
                tags_map.setdefault(f, []).append(t)
            friends: list[dict[str, Any]] = []
            for row in rows:
                fp = row.friend_phone
                friends.append(
                    {
                        "id": fp,
                        "phone": fp,
                        "close": fp in cf_set,
                        "tags": tags_map.get(fp, []),
                    }
                )
        return {"friends": friends}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/me/contacts/sync", response_class=JSONResponse)
async def me_contacts_sync(req: Request) -> dict[str, Any]:
    """
    Best‑effort Contact‑Sync:

    - Client sends a list of phone numbers from the address book.
    - Server returns a list of phones that also use Shamell so the
      client can show \"People you may know\" / add suggestions.
    """
    phone = _auth_phone(req)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    try:
        body = await req.json()
    except Exception:
        body = None
    numbers = []
    if isinstance(body, dict):
        raw = body.get("phones") or []
        if isinstance(raw, list):
            for v in raw:
                try:
                    s = (v or "").strip()
                except Exception:
                    s = ""
                if not s:
                    continue
                # Normalize very lightly: remove spaces; keep leading + if present.
                s = s.replace(" ", "")
                if not s:
                    continue
                # Do not include own phone
                if s == phone:
                    continue
                numbers.append(s)
    if not numbers:
        return {"matches": []}
    try:
        # Use Payments user directory as a proxy for \"is Shamell user\".
        # Prefer internal Payments integration when available.
        matches: list[dict[str, Any]] = []
        uniq = sorted({n for n in numbers})
        if _use_pay_internal():
            if not _PAY_INTERNAL_AVAILABLE:
                raise HTTPException(status_code=500, detail="payments internal not available")
            try:
                from apps.payments.app.main import User as _PayUser  # type: ignore[import]
            except Exception:
                _PayUser = None  # type: ignore[assignment]
            if _PayUser is None:
                return {"matches": []}
            with _pay_internal_session() as s:  # type: ignore[name-defined]
                rows = (
                    s.execute(
                        _sa_select(_PayUser).where(_PayUser.phone.in_(uniq))  # type: ignore[arg-type]
                    )
                    .scalars()
                    .all()
                )
                for u in rows:
                    try:
                        p = getattr(u, "phone", None)
                        if not p:
                            continue
                        matches.append(
                            {
                                "phone": p,
                                "name": getattr(u, "full_name", "") or "",
                            }
                        )
                    except Exception:
                        continue
        elif PAYMENTS_BASE:
            base = PAYMENTS_BASE.rstrip("/")
            for chunk_start in range(0, len(uniq), 50):
                chunk = uniq[chunk_start : chunk_start + 50]
                try:
                    url = f"{base}/admin/users/lookup"
                    r = httpx.post(
                        url,
                        json={"phones": chunk},
                        headers=_payments_headers(),
                        timeout=6.0,
                    )
                    if r.status_code >= 200 and r.status_code < 300:
                        decoded = r.json()
                        arr = decoded.get("users") if isinstance(decoded, dict) else None
                        if isinstance(arr, list):
                            for u in arr:
                                if not isinstance(u, dict):
                                    continue
                                p = (u.get("phone") or "").strip()
                                if not p:
                                    continue
                                matches.append(
                                    {
                                        "phone": p,
                                        "name": (u.get("full_name") or "").strip(),
                                    }
                                )
                except Exception:
                    continue
        return {"matches": matches}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/me/friend_requests", response_class=JSONResponse)
def me_friend_requests(request: Request) -> dict[str, Any]:
    """
    Returns incoming and outgoing friend requests for the current user.
    """
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    try:
        with _friends_session() as s:
            incoming_rows = (
                s.execute(
                    _sa_select(FriendRequestDB).where(
                        FriendRequestDB.to_phone == phone,
                        FriendRequestDB.status == "pending",
                    )
                )
                .scalars()
                .all()
            )
            outgoing_rows = (
                s.execute(
                    _sa_select(FriendRequestDB).where(
                        FriendRequestDB.from_phone == phone,
                        FriendRequestDB.status == "pending",
                    )
                )
                .scalars()
                .all()
            )
            incoming: list[dict[str, Any]] = []
            outgoing: list[dict[str, Any]] = []
            for r in incoming_rows:
                incoming.append(
                    {
                        "id": r.id,
                        "request_id": r.id,
                        "from": r.from_phone,
                        "to": r.to_phone,
                        "status": r.status,
                    }
                )
            for r in outgoing_rows:
                outgoing.append(
                    {
                        "id": r.id,
                        "request_id": r.id,
                        "from": r.from_phone,
                        "to": r.to_phone,
                        "status": r.status,
                    }
                )
        return {"incoming": incoming, "outgoing": outgoing}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


class FriendRequestIn(BaseModel):
    target_id: str


@app.post("/friends/request", response_class=JSONResponse)
async def friends_request(req: Request, body: FriendRequestIn) -> dict[str, Any]:
    """
    Creates a friend request from the current user to target_id (phone).
    """
    phone = _auth_phone(req)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    target = (body.target_id or "").strip()
    if not target:
        raise HTTPException(status_code=400, detail="target_id required")
    if target == phone:
        raise HTTPException(status_code=400, detail="cannot add yourself")
    try:
        with _friends_session() as s:
            # Already friends?
            existing_friend = s.execute(
                _sa_select(FriendDB).where(
                    FriendDB.user_phone == phone,
                    FriendDB.friend_phone == target,
                )
            ).scalars().first()
            if existing_friend:
                return {"status": "already_friends"}
            # Existing pending request?
            existing_req = s.execute(
                _sa_select(FriendRequestDB).where(
                    FriendRequestDB.from_phone == phone,
                    FriendRequestDB.to_phone == target,
                    FriendRequestDB.status == "pending",
                )
            ).scalars().first()
            if existing_req:
                return {
                    "status": "pending",
                    "request_id": existing_req.id,
                }
            row = FriendRequestDB(
                from_phone=phone,
                to_phone=target,
                status="pending",
            )
            s.add(row)
            s.commit()
            s.refresh(row)
            return {
                "status": "ok",
                "request_id": row.id,
                "from": row.from_phone,
                "to": row.to_phone,
            }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


class FriendAcceptIn(BaseModel):
    request_id: int


@app.post("/friends/accept", response_class=JSONResponse)
async def friends_accept(req: Request, body: FriendAcceptIn) -> dict[str, Any]:
    """
    Accepts a pending friend request and establishes a bidirectional friend relation.
    """
    phone = _auth_phone(req)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    rid = body.request_id
    try:
        with _friends_session() as s:
            r = s.get(FriendRequestDB, rid)
            if not r or r.to_phone != phone or r.status != "pending":
                raise HTTPException(status_code=404, detail="request not found")
            r.status = "accepted"
            # Create symmetric friend rows
            def _ensure_friend(a: str, b: str) -> None:
                existing = s.execute(
                    _sa_select(FriendDB).where(
                        FriendDB.user_phone == a,
                        FriendDB.friend_phone == b,
                    )
                ).scalars().first()
                if not existing:
                    s.add(FriendDB(user_phone=a, friend_phone=b))

            _ensure_friend(r.from_phone, r.to_phone)
            _ensure_friend(r.to_phone, r.from_phone)
            s.add(r)
            s.commit()
        return {"status": "ok"}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


class FriendTagsIn(BaseModel):
    tags: list[str]


@app.post("/me/friends/{friend_phone}/tags", response_class=JSONResponse)
async def me_friend_tags_set(friend_phone: str, request: Request, body: FriendTagsIn) -> dict[str, Any]:
    """
    Sets the label/tags for a friend (per user).

    This replaces any existing tags between (user_phone, friend_phone)
    and is used for WeChat‑style contact labels like \"Family\" or \"Work\".
    """
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    target = (friend_phone or "").strip()
    if not target:
        raise HTTPException(status_code=400, detail="friend_phone required")
    # Normalise tags: trim, deduplicate, drop empty.
    tags_norm: list[str] = []
    seen: set[str] = set()
    for t in body.tags:
        try:
            v = (t or "").strip()
        except Exception:
            v = ""
        if not v:
            continue
        key = v.lower()
        if key in seen:
            continue
        seen.add(key)
        tags_norm.append(v)
    try:
        with _friends_session() as s:
            # Ensure the relation exists before tagging.
            rel = (
                s.execute(
                    _sa_select(FriendDB).where(
                        FriendDB.user_phone == phone,
                        FriendDB.friend_phone == target,
                    )
                )
                .scalars()
                .first()
            )
            if rel is None:
                raise HTTPException(status_code=404, detail="friend not found")
            # Remove existing tags for this pair.
            s.execute(
                _sa_text(
                    "DELETE FROM friend_tags WHERE user_phone = :u AND friend_phone = :f"
                ),
                {"u": phone, "f": target},
            )
            # Insert new tags.
            for v in tags_norm:
                s.add(
                    FriendTagDB(
                        user_phone=phone,
                        friend_phone=target,
                        tag=v,
                    )
                )
            s.commit()
        return {"status": "ok", "tags": tags_norm}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/me/close_friends", response_class=JSONResponse)
def me_close_friends(request: Request) -> dict[str, Any]:
    """
    Returns the current user's close friends (subset of friends).
    """
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    try:
        with _friends_session() as s:
            rows = (
                s.execute(
                    _sa_select(CloseFriendDB).where(
                        CloseFriendDB.user_phone == phone
                    )
                )
                .scalars()
                .all()
            )
            friends: list[dict[str, Any]] = []
            for row in rows:
                friends.append(
                    {
                        "id": row.friend_phone,
                        "phone": row.friend_phone,
                    }
                )
        return {"friends": friends}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/me/close_friends/{friend_phone}", response_class=JSONResponse)
def me_close_friends_add(friend_phone: str, request: Request) -> dict[str, Any]:
    """
    Marks an existing friend as close friend for Moments visibility.
    """
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    target = friend_phone.strip()
    if not target:
        raise HTTPException(status_code=400, detail="friend_phone required")
    if target == phone:
        raise HTTPException(status_code=400, detail="cannot mark yourself")
    try:
        with _friends_session() as s:
            rel = (
                s.execute(
                    _sa_select(FriendDB).where(
                        FriendDB.user_phone == phone,
                        FriendDB.friend_phone == target,
                    )
                )
                .scalars()
                .first()
            )
            if rel is None:
                raise HTTPException(
                    status_code=400, detail="not a friend"
                )
            existing = (
                s.execute(
                    _sa_select(CloseFriendDB).where(
                        CloseFriendDB.user_phone == phone,
                        CloseFriendDB.friend_phone == target,
                    )
                )
                .scalars()
                .first()
            )
            if existing is None:
                row = CloseFriendDB(
                    user_phone=phone,
                    friend_phone=target,
                )
                s.add(row)
                s.commit()
        return {"status": "ok"}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


class NearbyProfileIn(BaseModel):
    """
    Input model for updating the user's People Nearby profile.

    All fields are optional; empty strings / out-of-range values are normalised.
    """

    status: str | None = None
    gender: str | None = None  # \"male\", \"female\", \"other\" (best-effort)
    age_years: int | None = None


@app.delete("/me/close_friends/{friend_phone}", response_class=JSONResponse)
def me_close_friends_remove(friend_phone: str, request: Request) -> dict[str, Any]:
    """
    Removes a friend from the close-friends list.
    """
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    target = friend_phone.strip()
    if not target:
        raise HTTPException(status_code=400, detail="friend_phone required")
    try:
        with _friends_session() as s:
            row = (
                s.execute(
                    _sa_select(CloseFriendDB).where(
                        CloseFriendDB.user_phone == phone,
                        CloseFriendDB.friend_phone == target,
                    )
                )
                .scalars()
                .first()
            )
            if row is not None:
                s.delete(row)
                s.commit()
        return {"status": "ok"}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/me/nearby", response_class=JSONResponse)
def me_nearby(request: Request, lat: float, lon: float, limit: int = 40) -> dict[str, Any]:
    """
    Returns nearby Shamell users for the People Nearby feature.

    - Upserts the caller's latest location (coarse presence).
    - Returns other users seen recently (within NEARBY_TTL_SECS), sorted by distance.
    """
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    now = datetime.now(timezone.utc)
    try:
        limit_val = max(1, min(limit, 100))
        cutoff = now - timedelta(seconds=NEARBY_TTL_SECS)
        with _nearby_session() as s:
            # Upsert caller presence.
            row = (
                s.execute(
                    _sa_select(NearbyPresenceDB).where(
                        NearbyPresenceDB.user_phone == phone
                    )
                )
                .scalars()
                .first()
            )
            if row is None:
                row = NearbyPresenceDB(
                    user_phone=phone,
                    last_lat=float(lat),
                    last_lon=float(lon),
                    updated_at=now,
                )
                s.add(row)
            else:
                row.last_lat = float(lat)
                row.last_lon = float(lon)
                row.updated_at = now
            s.commit()

        # Load other recent presences in a second transaction to keep scope small.
        with _nearby_session() as s:
            rows = (
                s.execute(
                    _sa_select(NearbyPresenceDB).where(
                        NearbyPresenceDB.updated_at >= cutoff,
                        NearbyPresenceDB.user_phone != phone,
                    )
                )
                .scalars()
                .all()
            )

        items: list[dict[str, Any]] = []
        for r in rows:
            try:
                plat = float(r.last_lat or 0.0)
                plon = float(r.last_lon or 0.0)
            except Exception:
                plat, plon = 0.0, 0.0
            try:
                d_km = _haversine_km(float(lat), float(lon), plat, plon)
            except Exception:
                d_km = 0.0
            distance_m = max(0.0, d_km * 1000.0)
            # Basic, privacy‑friendly payload – phone as ID; no exact location.
            items.append(
                {
                    "id": r.user_phone,
                    "shamell_id": r.user_phone,
                    "name": r.user_phone,
                    "distance_m": distance_m,
                    "status": (r.status or "").strip(),
                    "gender": (r.gender or "").strip().lower(),
                    "age_years": r.age_years,
                }
            )

        items.sort(key=lambda it: float(it.get("distance_m") or 0.0))
        return {"results": items[:limit_val]}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/me/nearby/profile", response_class=JSONResponse)
def me_nearby_profile_get(request: Request) -> dict[str, Any]:
    """
    Returns the current user's People Nearby profile (status/gender/age).
    """
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    try:
        with _nearby_session() as s:
            row = (
                s.execute(
                    _sa_select(NearbyPresenceDB).where(
                        NearbyPresenceDB.user_phone == phone
                    )
                )
                .scalars()
                .first()
            )
        if not row:
            return {"status": "", "gender": "", "age_years": None}
        return {
            "status": (row.status or "").strip(),
            "gender": (row.gender or "").strip().lower(),
            "age_years": row.age_years,
        }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/me/nearby/profile", response_class=JSONResponse)
async def me_nearby_profile_set(request: Request, body: NearbyProfileIn) -> dict[str, Any]:
    """
    Updates the current user's People Nearby profile (status/gender/age).

    This does not change the last known location; that is updated via /me/nearby.
    """
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")

    raw_status = (body.status or "").strip()
    # Keep status reasonably short for UI.
    status = raw_status[:160]
    gender_raw = (body.gender or "").strip().lower()
    gender: str | None
    if gender_raw in ("male", "female", "other"):
        gender = gender_raw
    elif not gender_raw:
        gender = None
    else:
        # Unknown values are normalised to None to avoid surprises.
        gender = None

    age_val: int | None = None
    if body.age_years is not None:
        try:
            a = int(body.age_years)
        except Exception:
            a = None
        if a is not None and 13 <= a <= 120:
            age_val = a

    now = datetime.now(timezone.utc)
    try:
        with _nearby_session() as s:
            row = (
                s.execute(
                    _sa_select(NearbyPresenceDB).where(
                        NearbyPresenceDB.user_phone == phone
                    )
                )
                .scalars()
                .first()
            )
            if row is None:
                row = NearbyPresenceDB(
                    user_phone=phone,
                    status=status or None,
                    gender=gender,
                    age_years=age_val,
                    updated_at=now,
                )
                s.add(row)
            else:
                row.status = status or None
                row.gender = gender
                row.age_years = age_val
                row.updated_at = now
            s.commit()
        return {
            "status": status,
            "gender": gender or "",
            "age_years": age_val,
        }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/moments/admin/posts/{post_id}/comment", response_class=JSONResponse)
def moments_admin_add_official_comment(post_id: int, request: Request, body: MomentAdminReplyIn):
    """
    Adds a comment as Official account for a given post (admin/ops only).
    """
    _require_admin_v2(request)
    text = (body.text or "").strip()
    if not text:
        raise HTTPException(status_code=400, detail="empty comment")
    acc_id = (body.official_account_id or "").strip()
    if not acc_id:
        raise HTTPException(status_code=400, detail="official_account_id required")
    reply_to_id = body.reply_to_id
    try:
        with _officials_session() as osess:
            acc = osess.get(OfficialAccountDB, acc_id)
            if not acc or not acc.enabled:
                raise HTTPException(status_code=404, detail="official account not found")
        user_key = f"official:{acc_id}"
        with _moments_session() as s:
            post = s.get(MomentPostDB, post_id)
            if not post:
                raise HTTPException(status_code=404, detail="moment not found")
            if reply_to_id is not None:
                target = s.get(MomentCommentDB, reply_to_id)
                if not target or target.post_id != post_id:
                    reply_to_id = None
            row = MomentCommentDB(
                post_id=post_id,
                user_key=user_key,
                text=text,
                reply_to_id=reply_to_id,
            )
            s.add(row)
            s.commit()
            s.refresh(row)
            ts = row.created_at
            ts_str = (
                ts.isoformat().replace("+00:00", "Z")
                if isinstance(ts, datetime)
                else datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")
            )
            author = f"Official · {acc_id}"
            out = MomentCommentOut(
                id=str(row.id),
                text=row.text,
                ts=ts_str,
                author_name=author,
                reply_to_id=str(row.reply_to_id)
                if getattr(row, "reply_to_id", None)
                else None,
                reply_to_name=None,
            ).dict()
        try:
            emit_event(
                "moments",
                "comment_create_official",
                {"account_id": acc_id, "post_id": post_id},
            )
        except Exception:
            pass
        return out
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/moments/admin/html", response_class=HTMLResponse)
def moments_admin_html(
    request: Request,
    limit: int = 100,
    redpacket_only: bool = False,
    origin_official_account_id: str | None = None,
    origin_official_item_id: str | None = None,
    campaign_id: str | None = None,
) -> HTMLResponse:
    """
    Minimal HTML view for QA to inspect Moments posts.
    """
    _require_admin_v2(request)
    try:
        limit_val = max(1, min(limit, 200))
        with _moments_session() as s:
            stmt = _sa_select(MomentPostDB)
            if redpacket_only:
                stmt = stmt.where(
                    MomentPostDB.text.contains("Red packet")
                    | MomentPostDB.text.contains(
                        "I am sending red packets via Shamell Pay"
                    )
                    | MomentPostDB.text.contains("حزمة حمراء")
                )
            # Optional filtering by origin official account / campaign (WeChat-style QA).
            if origin_official_account_id:
                stmt = stmt.where(
                    MomentPostDB.origin_official_account_id
                    == origin_official_account_id
                )
            target_item = origin_official_item_id or campaign_id
            if target_item:
                stmt = stmt.where(
                    MomentPostDB.origin_official_item_id == target_item
                )
            # Default ordering: latest first. For debugging "top" posts,
            # admins can bump limit and then sort by likes/comments in the UI.
            stmt = stmt.order_by(
                MomentPostDB.created_at.desc(), MomentPostDB.id.desc()
            ).limit(limit_val)
            rows = s.execute(stmt).scalars().all()
            post_ids = [r.id for r in rows]
            likes_map: dict[int, int] = {}
            comments_map: dict[int, int] = {}
            if post_ids:
                likes_rows = (
                    s.execute(
                        _sa_select(
                            MomentLikeDB.post_id, _sa_func.count(MomentLikeDB.id)
                        ).where(MomentLikeDB.post_id.in_(post_ids)
                        ).group_by(MomentLikeDB.post_id)
                    )
                    .all()
                )
                for pid, cnt in likes_rows:
                    likes_map[int(pid)] = int(cnt)
                comments_rows = (
                    s.execute(
                        _sa_select(
                            MomentCommentDB.post_id, _sa_func.count(MomentCommentDB.id)
                        ).where(MomentCommentDB.post_id.in_(post_ids)
                        ).group_by(MomentCommentDB.post_id)
                    )
                    .all()
                )
                for pid, cnt in comments_rows:
                    comments_map[int(pid)] = int(cnt)
        def esc(s: str) -> str:
            return (
                s.replace("&", "&amp;")
                .replace("<", "&lt;")
                .replace(">", "&gt;")
            )

        rows_html = []
        for row in rows:
            ts = row.created_at
            ts_str = (
                ts.isoformat().replace("+00:00", "Z")
                if isinstance(ts, datetime)
                else datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")
            )
            origin_acc = getattr(row, "origin_official_account_id", None)
            origin_item = getattr(row, "origin_official_item_id", None)
            origin = ""
            if origin_acc:
                origin = esc(origin_acc)
                if origin_item:
                    origin += "/" + esc(origin_item)
            comments_count = comments_map.get(row.id, 0)
            comments_cell = (
                f'<a href="/moments/admin/comments/html?post_id={row.id}">{comments_count}</a>'
            )
            rows_html.append(
                f"<tr>"
                f"<td>{row.id}</td>"
                f"<td>{esc(row.user_key)}</td>"
                f"<td>{esc(row.visibility or 'public')}</td>"
                f"<td>{esc(ts_str)}</td>"
                f"<td>{likes_map.get(row.id, 0)}</td>"
                f"<td>{comments_cell}</td>"
                f"<td>{'✓' if (row.image_b64 or row.image_url) else ''}</td>"
                f"<td>{origin}</td>"
                f"<td><pre>{esc(row.text[:280])}</pre></td>"
                f"</tr>"
            )
        html = f"""
<!doctype html>
<html><head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Moments Admin</title>
  <style>
    body{{font-family:sans-serif;margin:20px;max-width:960px;color:#0f172a;}}
    h1{{margin-bottom:8px;}}
    table{{border-collapse:collapse;width:100%;margin-top:12px;}}
    th,td{{padding:6px 8px;border-bottom:1px solid #e5e7eb;font-size:13px;text-align:left;vertical-align:top;}}
    th{{background:#f9fafb;font-weight:600;}}
    pre{{white-space:pre-wrap;font-family:ui-monospace,monospace;font-size:12px;margin:0;}}
    .meta{{color:#6b7280;font-size:12px;margin-top:4px;}}
  </style>
</head><body>
  <h1>Moments Admin</h1>
  <div class="meta">Latest {len(rows)} moments (limit={limit_val}).</div>
  <p class="meta">
    <a href="/moments/admin/html">All</a> ·
    <a href="/moments/admin/html?redpacket_only=1">Only red‑packet posts</a>
  </p>
  <table>
    <thead>
      <tr>
        <th>ID</th>
        <th>User</th>
        <th>Visibility</th>
        <th>Created</th>
        <th>Likes</th>
        <th>Comments</th>
        <th>Img</th>
        <th>Origin (official)</th>
        <th>Text (truncated)</th>
      </tr>
    </thead>
    <tbody>
      {''.join(rows_html) if rows_html else '<tr><td colspan="9">No moments yet.</td></tr>'}
    </tbody>
  </table>
</body></html>
"""
        return HTMLResponse(content=html)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/moments/admin/comments/html", response_class=HTMLResponse)
def moments_admin_comments_html(request: Request) -> HTMLResponse:
    """
    Minimal HTML console for inspecting and moderating Moments comments.
    """
    _require_admin_v2(request)
    html = """
<!doctype html>
<html><head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Moments Comments Admin</title>
  <style>
    body{font-family:sans-serif;margin:20px;max-width:960px;color:#0f172a;}
    h1{margin-bottom:8px;}
    table{border-collapse:collapse;width:100%;margin-top:12px;}
    th,td{padding:6px 8px;border-bottom:1px solid #e5e7eb;font-size:13px;text-align:left;vertical-align:top;}
    th{background:#f9fafb;font-weight:600;}
    pre{white-space:pre-wrap;font-family:ui-monospace,monospace;font-size:12px;margin:0;}
    .meta{color:#6b7280;font-size:12px;margin-top:4px;}
    .row-actions{white-space:nowrap;}
    input{font-size:13px;padding:4px 6px;margin:2px 0;}
    button{font-size:13px;padding:4px 8px;margin:0 2px;cursor:pointer;}
    .error{color:#b91c1c;margin-top:4px;}
    .success{color:#166534;margin-top:4px;}
  </style>
</head><body>
  <h1>Moments Comments</h1>
  <div class="meta">QA/Moderation for comments. Filter by post ID and delete problematic comments.</div>

  <div>
    <label>Post ID:
      <input id="post_id" type="number" placeholder="optional: filter by post" />
    </label>
    <label>Official account ID:
      <input id="official_id" type="text" placeholder="optional: filter by official" />
    </label>
    <label>Limit:
      <input id="limit" type="number" value="100" min="1" max="500" />
    </label>
    <button onclick="loadComments()">Load</button>
  </div>
  <div class="meta" style="margin-top:4px;">
    Reply as Official:
    <select id="reply_official">
      <option value="">– select account –</option>
    </select>
    <button onclick="reloadOfficials()">Reload accounts</button>
  </div>
  <div id="flash" class="meta"></div>

  <table>
    <thead>
      <tr>
        <th>ID</th>
        <th>Post</th>
        <th>User</th>
        <th>Created</th>
        <th>Reply&nbsp;to</th>
        <th>Text</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody id="comments-body">
      <tr><td colspan="7">Use the filter above and click Load.</td></tr>
    </tbody>
  </table>

  <script>
    function getInitialPostId() {
      try {
        const params = new URLSearchParams(window.location.search || '');
        return params.get('post_id') || '';
      } catch (e) {
        return '';
      }
    }

    function getInitialOfficialId() {
      try {
        const params = new URLSearchParams(window.location.search || '');
        return params.get('official_account_id') || '';
      } catch (e) {
        return '';
      }
    }

    async function loadComments() {
      const bodyEl = document.getElementById('comments-body');
      const flash = document.getElementById('flash');
      flash.textContent = '';
      const postId = document.getElementById('post_id').value.trim();
       const officialIdInput = document.getElementById('official_id');
      const officialId = officialIdInput ? officialIdInput.value.trim() : '';
      const limitEl = document.getElementById('limit');
      let limit = parseInt(limitEl.value || '100', 10);
      if (!Number.isFinite(limit) || limit <= 0) limit = 100;
      let url = '/moments/admin/comments?limit=' + encodeURIComponent(String(limit));
      if (postId) {
        url += '&post_id=' + encodeURIComponent(postId);
      }
      if (officialId) {
        url += '&official_account_id=' + encodeURIComponent(officialId);
      }
      try {
        const r = await fetch(url);
        if (!r.ok) {
          bodyEl.innerHTML = '<tr><td colspan="7">Fehler beim Laden: ' + r.status + '</td></tr>';
          return;
        }
        const data = await r.json();
        const items = data.items || [];
        if (!items.length) {
          bodyEl.innerHTML = '<tr><td colspan="7">Keine Kommentare gefunden.</td></tr>';
          return;
        }
        bodyEl.innerHTML = '';
        for (const c of items) {
          const tr = document.createElement('tr');
          const text = (c.text || '').toString();
          const short = text.length > 260 ? text.slice(0, 260) + '…' : text;
          const rawUser = (c.user_key || '').toString();
          let userLabel = rawUser;
          if (rawUser.startsWith('official:')) {
            userLabel = 'Official · ' + rawUser.slice('official:'.length);
          }
          tr.innerHTML = `
            <td>${c.id}</td>
            <td>${c.post_id}</td>
            <td><pre>${userLabel.replace(/</g,'&lt;').replace(/>/g,'&gt;')}</pre></td>
            <td><span class="meta">${c.created_at || ''}</span></td>
            <td>${c.reply_to_id != null ? c.reply_to_id : ''}</td>
            <td><pre>${short.replace(/</g,'&lt;').replace(/>/g,'&gt;')}</pre></td>
            <td class="row-actions">
              <button onclick="replyToComment(${c.id}, ${c.post_id})">Reply as official</button>
              <button onclick="deleteComment(${c.id})">Delete</button>
            </td>
          `;
          bodyEl.appendChild(tr);
        }
      } catch (e) {
        bodyEl.innerHTML = '<tr><td colspan="7">Fehler: ' + e + '</td></tr>';
      }
    }

    async function deleteComment(id) {
      if (!id && id !== 0) return;
      const flash = document.getElementById('flash');
      flash.textContent = '';
      try {
        const r = await fetch('/moments/admin/comments/' + encodeURIComponent(String(id)), {
          method: 'DELETE',
        });
        if (!r.ok) {
          const txt = await r.text();
          flash.textContent = 'Fehler beim Löschen: ' + r.status + ' ' + txt;
          flash.className = 'error';
        } else {
          flash.textContent = 'Kommentar gelöscht.';
          flash.className = 'success';
          loadComments();
        }
      } catch (e) {
        flash.textContent = 'Fehler: ' + e;
        flash.className = 'error';
      }
    }

    async function reloadOfficials() {
      const sel = document.getElementById('reply_official');
      if (!sel) return;
      sel.innerHTML = '<option value=\"\">…loading…</option>';
      try {
        const r = await fetch('/admin/official_accounts');
        if (!r.ok) {
          sel.innerHTML = '<option value=\"\">(error)</option>';
          return;
        }
        const data = await r.json();
        const items = data.accounts || [];
        if (!items.length) {
          sel.innerHTML = '<option value=\"\">(no accounts)</option>';
          return;
        }
        sel.innerHTML = '<option value=\"\">– select account –</option>';
        for (const acc of items) {
          const opt = document.createElement('option');
          opt.value = acc.id;
          opt.textContent = acc.id + ' – ' + (acc.name || '');
          sel.appendChild(opt);
        }
      } catch (e) {
        sel.innerHTML = '<option value=\"\">(error)</option>';
      }
    }

    async function replyToComment(id, postId) {
      const flash = document.getElementById('flash');
      flash.textContent = '';
      const sel = document.getElementById('reply_official');
      if (!sel) {
        flash.textContent = 'No official account selector.';
        flash.className = 'error';
        return;
      }
      const accId = sel.value.trim();
      if (!accId) {
        flash.textContent = 'Bitte Official-Account auswählen.';
        flash.className = 'error';
        return;
      }
      const text = window.prompt('Reply text:');
      if (!text || !text.trim()) {
        return;
      }
      try {
        const payload = {
          text: text.trim(),
          official_account_id: accId,
          reply_to_id: id,
        };
        const r = await fetch('/moments/admin/posts/' + encodeURIComponent(String(postId)) + '/comment', {
          method: 'POST',
          headers: {'content-type':'application/json'},
          body: JSON.stringify(payload),
        });
        if (!r.ok) {
          const txt = await r.text();
          flash.textContent = 'Fehler beim Antworten: ' + r.status + ' ' + txt;
          flash.className = 'error';
        } else {
          flash.textContent = 'Antwort gesendet.';
          flash.className = 'success';
          loadComments();
        }
      } catch (e) {
        flash.textContent = 'Fehler: ' + e;
        flash.className = 'error';
      }
    }

    (function init() {
      const initialPost = getInitialPostId();
      const initialOfficial = getInitialOfficialId();
      reloadOfficials();
      if (initialPost) {
        const input = document.getElementById('post_id');
        if (input) input.value = initialPost;
        // ignore: discarded_futures
        loadComments();
      } else if (initialOfficial) {
        const input = document.getElementById('official_id');
        if (input) input.value = initialOfficial;
        // ignore: discarded_futures
        loadComments();
      }
    })();
  </script>
</body></html>
"""
    return HTMLResponse(content=html)


@app.get("/moments/admin/analytics", response_class=HTMLResponse)
def moments_admin_analytics(request: Request) -> HTMLResponse:
    """
    Lightweight HTML analytics for Moments.

    Shows total posts/likes/comments and simple per-user aggregates,
    similar to WeChat Moments QA dashboards.
    """
    _require_admin_v2(request)
    try:
        with _moments_session() as s:
            total_posts = (
                s.execute(_sa_select(_sa_func.count(MomentPostDB.id)))
                .scalar()
                or 0
            )
            total_likes = (
                s.execute(_sa_select(_sa_func.count(MomentLikeDB.id)))
                .scalar()
                or 0
            )
            total_comments = (
                s.execute(_sa_select(_sa_func.count(MomentCommentDB.id)))
                .scalar()
                or 0
            )
            total_official_shares = (
                s.execute(
                    _sa_select(_sa_func.count(MomentPostDB.id)).where(
                        MomentPostDB.origin_official_account_id.is_not(None)
                    )
                )
                .scalar()
                or 0
            )
            redpacket_posts = 0
            try:
                rp1 = (
                    s.execute(
                        _sa_select(_sa_func.count(MomentPostDB.id)).where(
                            MomentPostDB.text.contains("Red packet")
                        )
                    )
                    .scalar()
                    or 0
                )
                rp2 = (
                    s.execute(
                        _sa_select(_sa_func.count(MomentPostDB.id)).where(
                            MomentPostDB.text.contains(
                                "I am sending red packets via Shamell Pay"
                            )
                        )
                    )
                    .scalar()
                    or 0
                )
                rp3 = (
                    s.execute(
                        _sa_select(_sa_func.count(MomentPostDB.id)).where(
                            MomentPostDB.text.contains("حزمة حمراء")
                        )
                    )
                    .scalar()
                    or 0
                )
                redpacket_posts = int((rp1 or 0) + (rp2 or 0) + (rp3 or 0))
            except Exception:
                redpacket_posts = 0

            # Last 30 days activity
            since = datetime.now(timezone.utc) - timedelta(days=30)
            recent_posts = (
                s.execute(
                    _sa_select(_sa_func.count(MomentPostDB.id)).where(
                        MomentPostDB.created_at >= since
                    )
                )
                .scalar()
                or 0
            )
            recent_likes = (
                s.execute(
                    _sa_select(_sa_func.count(MomentLikeDB.id)).where(
                        MomentLikeDB.created_at >= since
                    )
                )
                .scalar()
                or 0
            )
            recent_comments = (
                s.execute(
                    _sa_select(_sa_func.count(MomentCommentDB.id)).where(
                        MomentCommentDB.created_at >= since
                    )
                )
                .scalar()
                or 0
            )

            # Red-packet mentions in the last 30 days
            recent_redpacket_posts = 0
            try:
                rp1_30 = (
                    s.execute(
                        _sa_select(_sa_func.count(MomentPostDB.id)).where(
                            MomentPostDB.created_at >= since,
                            MomentPostDB.text.contains("Red packet"),
                        )
                    )
                    .scalar()
                    or 0
                )
                rp2_30 = (
                    s.execute(
                        _sa_select(_sa_func.count(MomentPostDB.id)).where(
                            MomentPostDB.created_at >= since,
                            MomentPostDB.text.contains(
                                "I am sending red packets via Shamell Pay"
                            ),
                        )
                    )
                    .scalar()
                    or 0
                )
                rp3_30 = (
                    s.execute(
                        _sa_select(_sa_func.count(MomentPostDB.id)).where(
                            MomentPostDB.created_at >= since,
                            MomentPostDB.text.contains("حزمة حمراء"),
                        )
                    )
                    .scalar()
                    or 0
                )
                recent_redpacket_posts = int((rp1_30 or 0) + (rp2_30 or 0) + (rp3_30 or 0))
            except Exception:
                recent_redpacket_posts = 0

            # Top posters and commenters by user_key
            top_posters = (
                s.execute(
                    _sa_select(
                        MomentPostDB.user_key,
                        _sa_func.count(MomentPostDB.id),
                    )
                    .group_by(MomentPostDB.user_key)
                    .order_by(_sa_func.count(MomentPostDB.id).desc())
                    .limit(20)
                )
                .all()
            )
            top_commenters = (
                s.execute(
                    _sa_select(
                        MomentCommentDB.user_key,
                        _sa_func.count(MomentCommentDB.id),
                    )
                    .group_by(MomentCommentDB.user_key)
                    .order_by(_sa_func.count(MomentCommentDB.id).desc())
                    .limit(20)
                )
                .all()
            )

            top_topics = (
                s.execute(
                    _sa_select(
                        MomentTagDB.tag,
                        _sa_func.count(MomentTagDB.id),
                    )
                    .group_by(MomentTagDB.tag)
                    .order_by(_sa_func.count(MomentTagDB.id).desc())
                    .limit(20)
                )
                .all()
            )

        def esc(s: str) -> str:
            return (
                s.replace("&", "&amp;")
                .replace("<", "&lt;")
                .replace(">", "&gt;")
            )

        posters_rows: list[str] = []
        for user_key, cnt in top_posters:
            posters_rows.append(
                "<tr>"
                f"<td><pre>{esc(str(user_key or ''))}</pre></td>"
                f"<td>{int(cnt or 0)}</td>"
                "</tr>"
            )

        commenters_rows: list[str] = []
        for user_key, cnt in top_commenters:
            commenters_rows.append(
                "<tr>"
                f"<td><pre>{esc(str(user_key or ''))}</pre></td>"
                f"<td>{int(cnt or 0)}</td>"
                "</tr>"
            )

        topics_rows: list[str] = []
        for tag, cnt in top_topics:
            topics_rows.append(
                "<tr>"
                f"<td><pre>{esc(str(tag or ''))}</pre></td>"
                f"<td>{int(cnt or 0)}</td>"
                "</tr>"
            )

        html = f"""
<!doctype html>
<html><head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Moments · Analytics</title>
  <style>
    body{{font-family:sans-serif;margin:20px;max-width:1100px;color:#0f172a;}}
    h1{{margin-bottom:4px;}}
    h2{{margin-top:24px;margin-bottom:8px;}}
    table{{border-collapse:collapse;width:100%;margin-top:8px;}}
    th,td{{padding:6px 8px;border-bottom:1px solid #e5e7eb;font-size:13px;text-align:left;vertical-align:top;}}
    th{{background:#f9fafb;font-weight:600;}}
    .meta{{color:#6b7280;font-size:12px;margin-top:4px;}}
    pre{{white-space:pre-wrap;font-family:ui-monospace,monospace;font-size:12px;margin:0;}}
  </style>
</head><body>
  <h1>Moments · Analytics</h1>
  <div class="meta">
    Total posts: {int(total_posts)} · likes: {int(total_likes)} · comments: {int(total_comments)} · official shares: {int(total_official_shares)} · red-packet mentions: {int(redpacket_posts)}.
  </div>
  <div class="meta">
    Last 30 days — posts: {int(recent_posts)}, likes: {int(recent_likes)}, comments: {int(recent_comments)}, red-packet mentions: {int(recent_redpacket_posts)}.
  </div>
  <p class="meta">
    <a href="/moments/admin/html">Zurück zur Moments-Admin-Übersicht</a>
  </p>

  <h2>Top posters (by user_key)</h2>
  <table>
    <thead>
      <tr><th>User key</th><th>Posts</th></tr>
    </thead>
    <tbody>
      {''.join(posters_rows) if posters_rows else '<tr><td colspan="2">Keine Posts gefunden.</td></tr>'}
    </tbody>
  </table>

  <h2>Top commenters (by user_key)</h2>
  <table>
    <thead>
      <tr><th>User key</th><th>Comments</th></tr>
    </thead>
    <tbody>
      {''.join(commenters_rows) if commenters_rows else '<tr><td colspan="2">Keine Kommentare gefunden.</td></tr>'}
    </tbody>
  </table>

  <h2>Top topics (hashtags)</h2>
  <table>
    <thead>
      <tr><th>Tag</th><th>Posts</th></tr>
    </thead>
    <tbody>
      {''.join(topics_rows) if topics_rows else '<tr><td colspan="2">Keine Hashtag-Daten gefunden.</td></tr>'}
    </tbody>
  </table>
</body></html>
"""
        return HTMLResponse(content=html)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


# ---- Official accounts (merchant / brand layer, BFF-side) ----

_OFFICIALS_DB_URL = _env_or("OFFICIALS_DB_URL", _env_or("DB_URL", "sqlite+pysqlite:////tmp/officials.db"))
_OFFICIALS_DB_SCHEMA = os.getenv("DB_SCHEMA") if not _OFFICIALS_DB_URL.startswith("sqlite") else None


class _OfficialBase(_sa_DeclarativeBase):
    pass


class OfficialAccountDB(_OfficialBase):
    __tablename__ = "official_accounts"
    __table_args__ = ({"schema": _OFFICIALS_DB_SCHEMA} if _OFFICIALS_DB_SCHEMA else {})
    id: _sa_Mapped[str] = _sa_mapped_column(_sa_String(64), primary_key=True)
    kind: _sa_Mapped[str] = _sa_mapped_column(_sa_String(16), default="service")
    name: _sa_Mapped[str] = _sa_mapped_column(_sa_String(200))
    name_ar: _sa_Mapped[str | None] = _sa_mapped_column(_sa_String(200), nullable=True)
    avatar_url: _sa_Mapped[str | None] = _sa_mapped_column(_sa_String(255), nullable=True)
    verified: _sa_Mapped[bool] = _sa_mapped_column(_sa_Boolean, default=True)
    mini_app_id: _sa_Mapped[str | None] = _sa_mapped_column(_sa_String(64), nullable=True)
    description: _sa_Mapped[str | None] = _sa_mapped_column(_sa_String(255), nullable=True)
    chat_peer_id: _sa_Mapped[str | None] = _sa_mapped_column(_sa_String(64), nullable=True)
    category: _sa_Mapped[str | None] = _sa_mapped_column(_sa_String(64), nullable=True)
    city: _sa_Mapped[str | None] = _sa_mapped_column(_sa_String(64), nullable=True)
    address: _sa_Mapped[str | None] = _sa_mapped_column(_sa_String(255), nullable=True)
    opening_hours: _sa_Mapped[str | None] = _sa_mapped_column(_sa_String(255), nullable=True)
    website_url: _sa_Mapped[str | None] = _sa_mapped_column(_sa_String(255), nullable=True)
    qr_payload: _sa_Mapped[str | None] = _sa_mapped_column(_sa_String(255), nullable=True)
    featured: _sa_Mapped[bool] = _sa_mapped_column(_sa_Boolean, default=False)
    enabled: _sa_Mapped[bool] = _sa_mapped_column(_sa_Boolean, default=True)
    official: _sa_Mapped[bool] = _sa_mapped_column(_sa_Boolean, default=True)
    created_at: _sa_Mapped[str | None] = _sa_mapped_column(
        _sa_DateTime(timezone=True), server_default=_sa_func.now()
    )
    updated_at: _sa_Mapped[str | None] = _sa_mapped_column(
        _sa_DateTime(timezone=True),
        server_default=_sa_func.now(),
        onupdate=_sa_func.now(),
    )


class OfficialAccountRequestDB(_OfficialBase):
    __tablename__ = "official_account_requests"
    __table_args__ = ({"schema": _OFFICIALS_DB_SCHEMA} if _OFFICIALS_DB_SCHEMA else {})
    id: _sa_Mapped[int] = _sa_mapped_column(_sa_Integer, primary_key=True, autoincrement=True)
    account_id: _sa_Mapped[str] = _sa_mapped_column(_sa_String(64), index=True)
    kind: _sa_Mapped[str] = _sa_mapped_column(_sa_String(16), default="service")
    name: _sa_Mapped[str] = _sa_mapped_column(_sa_String(200))
    name_ar: _sa_Mapped[str | None] = _sa_mapped_column(_sa_String(200), nullable=True)
    description: _sa_Mapped[str | None] = _sa_mapped_column(_sa_String(255), nullable=True)
    category: _sa_Mapped[str | None] = _sa_mapped_column(_sa_String(64), nullable=True)
    city: _sa_Mapped[str | None] = _sa_mapped_column(_sa_String(64), nullable=True)
    address: _sa_Mapped[str | None] = _sa_mapped_column(_sa_String(255), nullable=True)
    opening_hours: _sa_Mapped[str | None] = _sa_mapped_column(_sa_String(255), nullable=True)
    website_url: _sa_Mapped[str | None] = _sa_mapped_column(_sa_String(255), nullable=True)
    mini_app_id: _sa_Mapped[str | None] = _sa_mapped_column(_sa_String(64), nullable=True)
    owner_name: _sa_Mapped[str | None] = _sa_mapped_column(_sa_String(200), nullable=True)
    contact_phone: _sa_Mapped[str | None] = _sa_mapped_column(_sa_String(64), nullable=True)
    contact_email: _sa_Mapped[str | None] = _sa_mapped_column(_sa_String(255), nullable=True)
    requester_phone: _sa_Mapped[str | None] = _sa_mapped_column(_sa_String(64), nullable=True)
    status: _sa_Mapped[str] = _sa_mapped_column(_sa_String(16), default="submitted")
    created_at: _sa_Mapped[datetime] = _sa_mapped_column(
        _sa_DateTime(timezone=True), server_default=_sa_func.now()
    )
    updated_at: _sa_Mapped[datetime] = _sa_mapped_column(
        _sa_DateTime(timezone=True),
        server_default=_sa_func.now(),
        onupdate=_sa_func.now(),
    )


class OfficialFeedItemDB(_OfficialBase):
    __tablename__ = "official_feed_items"
    __table_args__ = ({"schema": _OFFICIALS_DB_SCHEMA} if _OFFICIALS_DB_SCHEMA else {})
    id: _sa_Mapped[int] = _sa_mapped_column(_sa_Integer, primary_key=True, autoincrement=True)
    account_id: _sa_Mapped[str] = _sa_mapped_column(_sa_String(64), index=True)
    slug: _sa_Mapped[str] = _sa_mapped_column(_sa_String(64), unique=True)
    type: _sa_Mapped[str] = _sa_mapped_column(_sa_String(16), default="promo")
    title: _sa_Mapped[str | None] = _sa_mapped_column(_sa_String(255), nullable=True)
    snippet: _sa_Mapped[str | None] = _sa_mapped_column(_sa_String(512), nullable=True)
    thumb_url: _sa_Mapped[str | None] = _sa_mapped_column(_sa_String(255), nullable=True)
    ts: _sa_Mapped[str | None] = _sa_mapped_column(
        _sa_DateTime(timezone=True), server_default=_sa_func.now()
    )
    deeplink_json: _sa_Mapped[str | None] = _sa_mapped_column(_sa_Text, nullable=True)


class OfficialLocationDB(_OfficialBase):
    __tablename__ = "official_locations"
    __table_args__ = ({"schema": _OFFICIALS_DB_SCHEMA} if _OFFICIALS_DB_SCHEMA else {})
    id: _sa_Mapped[int] = _sa_mapped_column(_sa_Integer, primary_key=True, autoincrement=True)
    account_id: _sa_Mapped[str] = _sa_mapped_column(_sa_String(64), index=True)
    name: _sa_Mapped[str | None] = _sa_mapped_column(_sa_String(120), nullable=True)
    city: _sa_Mapped[str | None] = _sa_mapped_column(_sa_String(64), nullable=True)
    address: _sa_Mapped[str | None] = _sa_mapped_column(_sa_String(255), nullable=True)
    lat: _sa_Mapped[float | None] = _sa_mapped_column(_sa_Float, nullable=True)
    lon: _sa_Mapped[float | None] = _sa_mapped_column(_sa_Float, nullable=True)
    phone: _sa_Mapped[str | None] = _sa_mapped_column(_sa_String(32), nullable=True)
    opening_hours: _sa_Mapped[str | None] = _sa_mapped_column(_sa_String(255), nullable=True)


class MiniAppDB(_OfficialBase):
    __tablename__ = "mini_apps"
    __table_args__ = ({"schema": _OFFICIALS_DB_SCHEMA} if _OFFICIALS_DB_SCHEMA else {})
    id: _sa_Mapped[int] = _sa_mapped_column(_sa_Integer, primary_key=True, autoincrement=True)
    app_id: _sa_Mapped[str] = _sa_mapped_column(_sa_String(64), unique=True, index=True)
    title_en: _sa_Mapped[str] = _sa_mapped_column(_sa_String(200))
    title_ar: _sa_Mapped[str | None] = _sa_mapped_column(_sa_String(200), nullable=True)
    category_en: _sa_Mapped[str | None] = _sa_mapped_column(_sa_String(64), nullable=True)
    category_ar: _sa_Mapped[str | None] = _sa_mapped_column(_sa_String(64), nullable=True)
    description: _sa_Mapped[str | None] = _sa_mapped_column(_sa_String(255), nullable=True)
    icon: _sa_Mapped[str | None] = _sa_mapped_column(_sa_String(64), nullable=True)
    official: _sa_Mapped[bool] = _sa_mapped_column(_sa_Boolean, default=False)
    enabled: _sa_Mapped[bool] = _sa_mapped_column(_sa_Boolean, default=True)
    beta: _sa_Mapped[bool] = _sa_mapped_column(_sa_Boolean, default=False)
    runtime_app_id: _sa_Mapped[str | None] = _sa_mapped_column(
        _sa_String(64), nullable=True
    )
    rating: _sa_Mapped[float | None] = _sa_mapped_column(_sa_Float, nullable=True)
    usage_score: _sa_Mapped[int] = _sa_mapped_column(_sa_Integer, default=0)
    moments_shares: _sa_Mapped[int] = _sa_mapped_column(_sa_Integer, default=0)
    created_at: _sa_Mapped[str | None] = _sa_mapped_column(
        _sa_DateTime(timezone=True), server_default=_sa_func.now()
    )
    updated_at: _sa_Mapped[str | None] = _sa_mapped_column(
        _sa_DateTime(timezone=True),
        server_default=_sa_func.now(),
        onupdate=_sa_func.now(),
    )


class MiniAppRatingDB(_OfficialBase):
    __tablename__ = "mini_app_ratings"
    __table_args__ = (
        _sa_UniqueConstraint(
            "user_key",
            "app_id",
            name="uq_mini_app_ratings_user_app",
        ),
        {"schema": _OFFICIALS_DB_SCHEMA} if _OFFICIALS_DB_SCHEMA else {},
    )
    id: _sa_Mapped[int] = _sa_mapped_column(
        _sa_Integer, primary_key=True, autoincrement=True
    )
    user_key: _sa_Mapped[str] = _sa_mapped_column(_sa_String(128), index=True)
    app_id: _sa_Mapped[str] = _sa_mapped_column(_sa_String(64), index=True)
    rating: _sa_Mapped[int] = _sa_mapped_column(_sa_Integer)
    created_at: _sa_Mapped[datetime] = _sa_mapped_column(
        _sa_DateTime(timezone=True), server_default=_sa_func.now()
    )
    updated_at: _sa_Mapped[datetime] = _sa_mapped_column(
        _sa_DateTime(timezone=True),
        server_default=_sa_func.now(),
        onupdate=_sa_func.now(),
    )


class MiniProgramDB(_OfficialBase):
    """
    Lightweight registry for Mini‑Programs (WeChat‑style mini‑apps).

    This is intentionally minimal for the MVP: it tracks ownership and
    display metadata, while versions and releases are stored in the
    companion tables MiniProgramVersionDB and MiniProgramReleaseDB.
    """

    __tablename__ = "mini_programs"
    __table_args__ = ({"schema": _OFFICIALS_DB_SCHEMA} if _OFFICIALS_DB_SCHEMA else {})

    id: _sa_Mapped[int] = _sa_mapped_column(
        _sa_Integer, primary_key=True, autoincrement=True
    )
    app_id: _sa_Mapped[str] = _sa_mapped_column(
        _sa_String(64), unique=True, index=True
    )
    title_en: _sa_Mapped[str] = _sa_mapped_column(_sa_String(200))
    title_ar: _sa_Mapped[str | None] = _sa_mapped_column(
        _sa_String(200), nullable=True
    )
    description_en: _sa_Mapped[str | None] = _sa_mapped_column(
        _sa_String(512), nullable=True
    )
    description_ar: _sa_Mapped[str | None] = _sa_mapped_column(
        _sa_String(512), nullable=True
    )
    actions_json: _sa_Mapped[str | None] = _sa_mapped_column(
        _sa_Text, nullable=True
    )
    owner_name: _sa_Mapped[str | None] = _sa_mapped_column(
        _sa_String(200), nullable=True
    )
    owner_contact: _sa_Mapped[str | None] = _sa_mapped_column(
        _sa_String(200), nullable=True
    )
    scopes_json: _sa_Mapped[str | None] = _sa_mapped_column(
        _sa_Text, nullable=True
    )
    status: _sa_Mapped[str] = _sa_mapped_column(
        _sa_String(32), default="draft", server_default="draft"
    )
    review_status: _sa_Mapped[str] = _sa_mapped_column(
        _sa_String(32), default="draft", server_default="draft"
    )
    rating: _sa_Mapped[float | None] = _sa_mapped_column(
        _sa_Float, nullable=True
    )
    usage_score: _sa_Mapped[int] = _sa_mapped_column(_sa_Integer, default=0)
    created_at: _sa_Mapped[datetime] = _sa_mapped_column(
        _sa_DateTime(timezone=True), server_default=_sa_func.now()
    )
    updated_at: _sa_Mapped[datetime] = _sa_mapped_column(
        _sa_DateTime(timezone=True),
        server_default=_sa_func.now(),
        onupdate=_sa_func.now(),
    )


class MiniProgramVersionDB(_OfficialBase):
    """
    Individual version records for a Mini‑Program.

    A version references a static bundle_url (e.g. H5/JS bundle) and
    optional changelog text. Releases point at concrete versions.
    """

    __tablename__ = "mini_program_versions"
    __table_args__ = ({"schema": _OFFICIALS_DB_SCHEMA} if _OFFICIALS_DB_SCHEMA else {})

    id: _sa_Mapped[int] = _sa_mapped_column(
        _sa_Integer, primary_key=True, autoincrement=True
    )
    program_id: _sa_Mapped[int] = _sa_mapped_column(_sa_Integer, index=True)
    version: _sa_Mapped[str] = _sa_mapped_column(_sa_String(32))
    bundle_url: _sa_Mapped[str | None] = _sa_mapped_column(
        _sa_String(512), nullable=True
    )
    changelog_en: _sa_Mapped[str | None] = _sa_mapped_column(
        _sa_String(512), nullable=True
    )
    changelog_ar: _sa_Mapped[str | None] = _sa_mapped_column(
        _sa_String(512), nullable=True
    )
    created_at: _sa_Mapped[datetime] = _sa_mapped_column(
        _sa_DateTime(timezone=True), server_default=_sa_func.now()
    )


class MiniProgramReleaseDB(_OfficialBase):
    """
    Tracks which Mini‑Program version is currently released per channel.

    For now we keep this simple: each call to the release endpoint
    appends a new row; clients can query the newest row per program+channel.
    """

    __tablename__ = "mini_program_releases"
    __table_args__ = ({"schema": _OFFICIALS_DB_SCHEMA} if _OFFICIALS_DB_SCHEMA else {})

    id: _sa_Mapped[int] = _sa_mapped_column(
        _sa_Integer, primary_key=True, autoincrement=True
    )
    program_id: _sa_Mapped[int] = _sa_mapped_column(_sa_Integer, index=True)
    version_id: _sa_Mapped[int] = _sa_mapped_column(_sa_Integer, index=True)
    channel: _sa_Mapped[str] = _sa_mapped_column(
        _sa_String(32), default="prod", server_default="prod"
    )
    status: _sa_Mapped[str] = _sa_mapped_column(
        _sa_String(32), default="active", server_default="active"
    )


class MiniProgramRatingDB(_OfficialBase):
    """
    Per-user star ratings for Mini‑Programs (1–5).

    Mirrors MiniAppRatingDB so WeChat‑ähnliche Bewertungen auch
    für Mini‑Programs verfügbar sind.
    """

    __tablename__ = "mini_program_ratings"
    __table_args__ = (
        _sa_UniqueConstraint(
            "user_key",
            "app_id",
            name="uq_mini_program_ratings_user_app",
        ),
        {"schema": _OFFICIALS_DB_SCHEMA} if _OFFICIALS_DB_SCHEMA else {},
    )
    id: _sa_Mapped[int] = _sa_mapped_column(
        _sa_Integer, primary_key=True, autoincrement=True
    )
    user_key: _sa_Mapped[str] = _sa_mapped_column(_sa_String(128), index=True)
    app_id: _sa_Mapped[str] = _sa_mapped_column(_sa_String(64), index=True)
    rating: _sa_Mapped[int] = _sa_mapped_column(_sa_Integer)
    created_at: _sa_Mapped[datetime] = _sa_mapped_column(
        _sa_DateTime(timezone=True), server_default=_sa_func.now()
    )
    updated_at: _sa_Mapped[datetime] = _sa_mapped_column(
        _sa_DateTime(timezone=True),
        server_default=_sa_func.now(),
        onupdate=_sa_func.now(),
    )
    created_at: _sa_Mapped[datetime] = _sa_mapped_column(
        _sa_DateTime(timezone=True), server_default=_sa_func.now()
    )


class ChannelLikeDB(_OfficialBase):
    __tablename__ = "channel_likes"
    __table_args__ = (
        _sa_UniqueConstraint(
            "user_key",
            "item_id",
            name="uq_channel_likes_user_item",
        ),
        {"schema": _OFFICIALS_DB_SCHEMA} if _OFFICIALS_DB_SCHEMA else {},
    )
    id: _sa_Mapped[int] = _sa_mapped_column(
        _sa_Integer, primary_key=True, autoincrement=True
    )
    user_key: _sa_Mapped[str] = _sa_mapped_column(_sa_String(128), index=True)
    item_id: _sa_Mapped[str] = _sa_mapped_column(_sa_String(64), index=True)
    created_at: _sa_Mapped[datetime] = _sa_mapped_column(
        _sa_DateTime(timezone=True), server_default=_sa_func.now()
    )


class ChannelViewDB(_OfficialBase):
    __tablename__ = "channel_views"
    __table_args__ = (
        _sa_UniqueConstraint(
            "item_id",
            name="uq_channel_views_item",
        ),
        {"schema": _OFFICIALS_DB_SCHEMA} if _OFFICIALS_DB_SCHEMA else {},
    )
    id: _sa_Mapped[int] = _sa_mapped_column(
        _sa_Integer, primary_key=True, autoincrement=True
    )
    item_id: _sa_Mapped[str] = _sa_mapped_column(_sa_String(64), index=True)
    views: _sa_Mapped[int] = _sa_mapped_column(_sa_Integer, default=0)
    updated_at: _sa_Mapped[datetime] = _sa_mapped_column(
        _sa_DateTime(timezone=True),
        server_default=_sa_func.now(),
        onupdate=_sa_func.now(),
    )


class ChannelCommentDB(_OfficialBase):
    __tablename__ = "channel_comments"
    __table_args__ = (
        {"schema": _OFFICIALS_DB_SCHEMA} if _OFFICIALS_DB_SCHEMA else {},
    )
    id: _sa_Mapped[int] = _sa_mapped_column(
        _sa_Integer, primary_key=True, autoincrement=True
    )
    item_id: _sa_Mapped[str] = _sa_mapped_column(_sa_String(64), index=True)
    user_key: _sa_Mapped[str] = _sa_mapped_column(_sa_String(128), index=True)
    text: _sa_Mapped[str] = _sa_mapped_column(_sa_Text)
    created_at: _sa_Mapped[datetime] = _sa_mapped_column(
        _sa_DateTime(timezone=True), server_default=_sa_func.now()
    )


class RedPacketCampaignDB(_OfficialBase):
    __tablename__ = "redpacket_campaigns"
    __table_args__ = ({"schema": _OFFICIALS_DB_SCHEMA} if _OFFICIALS_DB_SCHEMA else {})
    id: _sa_Mapped[str] = _sa_mapped_column(_sa_String(64), primary_key=True)
    account_id: _sa_Mapped[str] = _sa_mapped_column(_sa_String(64), index=True)
    title: _sa_Mapped[str] = _sa_mapped_column(_sa_String(255))
    note: _sa_Mapped[str | None] = _sa_mapped_column(_sa_String(255), nullable=True)
    default_amount_cents: _sa_Mapped[int | None] = _sa_mapped_column(
        _sa_Integer, nullable=True
    )
    default_count: _sa_Mapped[int | None] = _sa_mapped_column(
        _sa_Integer, nullable=True
    )
    created_at: _sa_Mapped[str | None] = _sa_mapped_column(
        _sa_DateTime(timezone=True), server_default=_sa_func.now()
    )
    updated_at: _sa_Mapped[str | None] = _sa_mapped_column(
        _sa_DateTime(timezone=True),
        server_default=_sa_func.now(),
        onupdate=_sa_func.now(),
    )
    active: _sa_Mapped[bool] = _sa_mapped_column(_sa_Boolean, default=True)


class OfficialFollowDB(_OfficialBase):
    __tablename__ = "official_follows"
    __table_args__ = (
        _sa_UniqueConstraint("user_key", "account_id", name="uq_official_follows_user_account"),
        {"schema": _OFFICIALS_DB_SCHEMA} if _OFFICIALS_DB_SCHEMA else {},
    )
    id: _sa_Mapped[int] = _sa_mapped_column(_sa_Integer, primary_key=True, autoincrement=True)
    user_key: _sa_Mapped[str] = _sa_mapped_column(_sa_String(128), index=True)
    account_id: _sa_Mapped[str] = _sa_mapped_column(_sa_String(64), index=True)
    created_at: _sa_Mapped[str | None] = _sa_mapped_column(
        _sa_DateTime(timezone=True), server_default=_sa_func.now()
    )


class ChannelFollowDB(_OfficialBase):
    """
    Lightweight follower graph for Channels, separated from Officials.

    This models WeChat‑style \"Follow channel\" state per user and
    account, independent of whether the same Official is followed
    as a service/subscription account.
    """

    __tablename__ = "channel_follows"
    __table_args__ = (
        _sa_UniqueConstraint(
            "user_key",
            "account_id",
            name="uq_channel_follows_user_account",
        ),
        {"schema": _OFFICIALS_DB_SCHEMA} if _OFFICIALS_DB_SCHEMA else {},
    )
    id: _sa_Mapped[int] = _sa_mapped_column(
        _sa_Integer, primary_key=True, autoincrement=True
    )
    user_key: _sa_Mapped[str] = _sa_mapped_column(
        _sa_String(128), index=True
    )
    account_id: _sa_Mapped[str] = _sa_mapped_column(
        _sa_String(64), index=True
    )
    created_at: _sa_Mapped[datetime] = _sa_mapped_column(
        _sa_DateTime(timezone=True), server_default=_sa_func.now()
    )


class OfficialNotificationDB(_OfficialBase):
    __tablename__ = "official_notifications"
    __table_args__ = (
        _sa_UniqueConstraint(
            "user_key",
            "account_id",
            name="uq_official_notifications_user_account",
        ),
        {"schema": _OFFICIALS_DB_SCHEMA} if _OFFICIALS_DB_SCHEMA else {},
    )
    id: _sa_Mapped[int] = _sa_mapped_column(
        _sa_Integer, primary_key=True, autoincrement=True
    )
    user_key: _sa_Mapped[str] = _sa_mapped_column(
        _sa_String(128), index=True
    )
    account_id: _sa_Mapped[str] = _sa_mapped_column(
        _sa_String(64), index=True
    )
    mode: _sa_Mapped[str] = _sa_mapped_column(
        _sa_String(16), default="full"
    )


class OfficialAutoReplyDB(_OfficialBase):
    """
    Lightweight per‑Official auto‑reply configuration.

    For now this is intentionally minimal and focuses on "welcome"
    style replies that can be surfaced client‑side in a WeChat‑like
    way without breaking end‑to‑end chat encryption.
    """

    __tablename__ = "official_auto_replies"
    __table_args__ = ({"schema": _OFFICIALS_DB_SCHEMA} if _OFFICIALS_DB_SCHEMA else {})

    id: _sa_Mapped[int] = _sa_mapped_column(
        _sa_Integer, primary_key=True, autoincrement=True
    )
    account_id: _sa_Mapped[str] = _sa_mapped_column(
        _sa_String(64), index=True
    )
    kind: _sa_Mapped[str] = _sa_mapped_column(
        _sa_String(16), default="welcome"
    )
    keyword: _sa_Mapped[str | None] = _sa_mapped_column(
        _sa_String(64), nullable=True
    )
    text: _sa_Mapped[str] = _sa_mapped_column(_sa_Text)
    enabled: _sa_Mapped[bool] = _sa_mapped_column(_sa_Boolean, default=True)
    created_at: _sa_Mapped[datetime] = _sa_mapped_column(
        _sa_DateTime(timezone=True), server_default=_sa_func.now()
    )
    updated_at: _sa_Mapped[datetime] = _sa_mapped_column(
        _sa_DateTime(timezone=True),
        server_default=_sa_func.now(),
        onupdate=_sa_func.now(),
    )


class OfficialTemplateMessageDB(_OfficialBase):
    """
    Lightweight per-user template messages for Officials.

    This models WeChat‑style one‑time subscription messages that can
    be delivered from an Official account to a user without going
    through the end‑to‑end encrypted chat channel.
    """

    __tablename__ = "official_template_messages"
    __table_args__ = ({"schema": _OFFICIALS_DB_SCHEMA} if _OFFICIALS_DB_SCHEMA else {})

    id: _sa_Mapped[int] = _sa_mapped_column(
        _sa_Integer, primary_key=True, autoincrement=True
    )
    account_id: _sa_Mapped[str] = _sa_mapped_column(
        _sa_String(64), index=True
    )
    user_phone: _sa_Mapped[str] = _sa_mapped_column(
        _sa_String(32), index=True
    )
    title: _sa_Mapped[str] = _sa_mapped_column(_sa_String(200))
    body: _sa_Mapped[str] = _sa_mapped_column(_sa_Text)
    deeplink_json: _sa_Mapped[str | None] = _sa_mapped_column(
        _sa_Text, nullable=True
    )
    created_at: _sa_Mapped[datetime] = _sa_mapped_column(
        _sa_DateTime(timezone=True), server_default=_sa_func.now()
    )
    read_at: _sa_Mapped[datetime | None] = _sa_mapped_column(
        _sa_DateTime(timezone=True), nullable=True
    )


class OfficialServiceSessionDB(_OfficialBase):
    """
    Lightweight per-customer service session for Official accounts.

    This models a WeChat-like customer service "session" or ticket
    that can be surfaced in a unified service inbox for operators.
    """

    __tablename__ = "official_service_sessions"
    __table_args__ = ({"schema": _OFFICIALS_DB_SCHEMA} if _OFFICIALS_DB_SCHEMA else {})

    id: _sa_Mapped[int] = _sa_mapped_column(
        _sa_Integer, primary_key=True, autoincrement=True
    )
    account_id: _sa_Mapped[str] = _sa_mapped_column(_sa_String(64), index=True)
    customer_phone: _sa_Mapped[str] = _sa_mapped_column(
        _sa_String(32), index=True
    )
    chat_peer_id: _sa_Mapped[str | None] = _sa_mapped_column(
        _sa_String(64), nullable=True
    )
    status: _sa_Mapped[str] = _sa_mapped_column(
        _sa_String(16), default="open", index=True
    )
    last_message_ts: _sa_Mapped[datetime] = _sa_mapped_column(
        _sa_DateTime(timezone=True), server_default=_sa_func.now()
    )
    unread_by_operator: _sa_Mapped[bool] = _sa_mapped_column(
        _sa_Boolean, default=True
    )


class DeviceSessionDB(_OfficialBase):
    """
    Lightweight per-device session registry for multi-device/Web login.

    Stores a row per (phone, device_id) so the Me-tab can show a
    list of active devices, similar to WeChat's device management.
    """

    __tablename__ = "device_sessions"
    __table_args__ = ({"schema": _OFFICIALS_DB_SCHEMA} if _OFFICIALS_DB_SCHEMA else {})

    id: _sa_Mapped[int] = _sa_mapped_column(
        _sa_Integer, primary_key=True, autoincrement=True
    )
    phone: _sa_Mapped[str] = _sa_mapped_column(_sa_String(32), index=True)
    device_id: _sa_Mapped[str] = _sa_mapped_column(_sa_String(128), index=True)
    device_type: _sa_Mapped[str | None] = _sa_mapped_column(
        _sa_String(32), nullable=True
    )
    device_name: _sa_Mapped[str | None] = _sa_mapped_column(
        _sa_String(128), nullable=True
    )
    platform: _sa_Mapped[str | None] = _sa_mapped_column(
        _sa_String(32), nullable=True
    )
    app_version: _sa_Mapped[str | None] = _sa_mapped_column(
        _sa_String(32), nullable=True
    )
    last_ip: _sa_Mapped[str | None] = _sa_mapped_column(
        _sa_String(64), nullable=True
    )
    user_agent: _sa_Mapped[str | None] = _sa_mapped_column(
        _sa_String(255), nullable=True
    )
    created_at: _sa_Mapped[datetime] = _sa_mapped_column(
        _sa_DateTime(timezone=True), server_default=_sa_func.now()
    )
    last_seen_at: _sa_Mapped[datetime] = _sa_mapped_column(
        _sa_DateTime(timezone=True),
        server_default=_sa_func.now(),
        onupdate=_sa_func.now(),
    )


_officials_engine = _sa_create_engine(_OFFICIALS_DB_URL, future=True)
_officials_inited = False


def _officials_session() -> _sa_Session:
    """
    Returns a session for the officials DB.

    In addition to relying on FastAPI's startup hook, this lazily ensures
    that the officials schema exists so that deployments that construct the
    app without running startup events still get the required tables
    (e.g. official_feed_items, official_template_messages).
    """
    global _officials_inited
    if not _officials_inited:
        try:
            # Best-effort; failures are logged inside _officials_startup.
            _officials_startup()  # type: ignore[name-defined]
        except Exception:
            logging.getLogger("shamell.officials").exception(
                "failed to init officials DB from session helper"
            )
        _officials_inited = True
    return _sa_Session(_officials_engine)


class OfficialAccountOut(BaseModel):
    id: str
    kind: str = "service"
    featured: bool = False
    name: str
    name_ar: str | None = None
    avatar_url: str | None = None
    verified: bool = True
    mini_app_id: str | None = None
    description: str | None = None
    chat_peer_id: str | None = None
    category: str | None = None
    city: str | None = None
    address: str | None = None
    opening_hours: str | None = None
    website_url: str | None = None
    qr_payload: str | None = None
    unread_count: int = 0
    last_item: dict[str, Any] | None = None
    followed: bool = True
    menu_items: list[dict[str, Any]] | None = None


class OfficialTemplateMessageIn(BaseModel):
    account_id: str
    user_phone: str
    title: str
    body: str
    deeplink_json: dict[str, Any] | None = None


class OfficialTemplateMessageOut(BaseModel):
    id: int
    account_id: str
    title: str
    body: str
    deeplink_json: dict[str, Any] | None = None
    created_at: str
    read_at: str | None = None


def _update_official_service_session_on_message(
    sender_id: str | None,
    recipient_id: str | None,
    created_at: Any,
) -> None:
    """
    Best-effort hook that keeps OfficialServiceSessionDB in sync with chat traffic.

    When a message goes between a service Official (via chat_peer_id) and a
    user device, we create or update a lightweight session so the operator
    sees it in the customer-service inbox.
    """
    try:
        s_id = (sender_id or "").strip()
        r_id = (recipient_id or "").strip()
        if not s_id or not r_id:
            return
        with _officials_session() as s:
            # Determine which side (if any) is an Official service account.
            off_sender = (
                s.execute(
                    _sa_select(OfficialAccountDB).where(
                        OfficialAccountDB.chat_peer_id == s_id
                    )
                )
                .scalars()
                .first()
            )
            off_recipient = (
                s.execute(
                    _sa_select(OfficialAccountDB).where(
                        OfficialAccountDB.chat_peer_id == r_id
                    )
                )
                .scalars()
                .first()
            )
            official = None
            customer_device_id: str | None = None
            incoming_for_operator = False
            if off_sender and not off_recipient:
                official = off_sender
                customer_device_id = r_id
                incoming_for_operator = False  # operator is sender
            elif off_recipient and not off_sender:
                official = off_recipient
                customer_device_id = s_id
                incoming_for_operator = True  # operator is recipient
            else:
                return
            # Only treat "service" officials as customer-service endpoints.
            try:
                kind_val = (getattr(official, "kind", "") or "").strip().lower()
                if kind_val and kind_val != "service":
                    return
            except Exception:
                return
            if not customer_device_id:
                return
            # Resolve customer phone from DeviceSessionDB.
            dev_row = (
                s.execute(
                    _sa_select(DeviceSessionDB)
                    .where(DeviceSessionDB.device_id == customer_device_id)
                    .order_by(
                        DeviceSessionDB.last_seen_at.desc(),
                        DeviceSessionDB.id.desc(),
                    )
                )
                .scalars()
                .first()
            )
            if not dev_row:
                return
            phone = (getattr(dev_row, "phone", "") or "").strip()
            if not phone:
                return
            # Determine timestamp for last_message_ts.
            ts_val: datetime
            try:
                if isinstance(created_at, datetime):
                    ts_val = created_at
                elif isinstance(created_at, str) and created_at:
                    ts_val = datetime.fromisoformat(
                        created_at.replace("Z", "+00:00")
                    )
                else:
                    ts_val = datetime.now(timezone.utc)
            except Exception:
                ts_val = datetime.now(timezone.utc)
            # Upsert session.
            sess = (
                s.execute(
                    _sa_select(OfficialServiceSessionDB)
                    .where(
                        OfficialServiceSessionDB.account_id == official.id,
                        OfficialServiceSessionDB.customer_phone == phone,
                    )
                    .order_by(
                        OfficialServiceSessionDB.last_message_ts.desc(),
                        OfficialServiceSessionDB.id.desc(),
                    )
                    .limit(1)
                )
                .scalars()
                .first()
            )
            if sess:
                sess.last_message_ts = ts_val
                if incoming_for_operator:
                    sess.unread_by_operator = True
                if not getattr(sess, "chat_peer_id", None):
                    try:
                        sess.chat_peer_id = getattr(official, "chat_peer_id", None)
                    except Exception:
                        pass
                if getattr(sess, "status", "open") != "closed":
                    sess.status = "open"
                s.add(sess)
                s.commit()
            else:
                sess = OfficialServiceSessionDB(
                    account_id=official.id,
                    customer_phone=phone,
                    chat_peer_id=getattr(official, "chat_peer_id", None),
                    status="open",
                    last_message_ts=ts_val,
                    unread_by_operator=incoming_for_operator,
                )
                s.add(sess)
                s.commit()
    except Exception:
        # Never break the main chat flow because of service-session bookkeeping.
        return


class OfficialFeedItemOut(BaseModel):
    id: str
    type: str = "promo"
    title: str | None = None
    snippet: str | None = None
    thumb_url: str | None = None
    ts: str | None = None
    deeplink: dict[str, Any] | None = None


class OfficialLocationOut(BaseModel):
    id: int
    name: str | None = None
    city: str | None = None
    address: str | None = None
    lat: float | None = None
    lon: float | None = None
    phone: str | None = None
    opening_hours: str | None = None


class ChannelItemOut(BaseModel):
    id: str
    title: str | None = None
    snippet: str | None = None
    thumb_url: str | None = None
    ts: str | None = None
    item_type: str | None = None
    official_account_id: str | None = None
    official_name: str | None = None
    official_avatar_url: str | None = None
    official_city: str | None = None
    official_category: str | None = None
    likes: int = 0
    liked_by_me: bool = False
    views: int = 0
    comments: int = 0
    official_is_hot: bool = False
    channel_followers: int = 0
    channel_followed_by_me: bool = False
    gifts: int = 0
    gifts_by_me: int = 0
    score: float | None = None


class ChannelGiftDB(_OfficialBase):
    """
    Simple per-user gift / coin log for Channels.

    This is a lightweight WeChat-style gift system that tracks how
    many "coins" a user sent to a given Channels clip. Money flows
    are intentionally decoupled and can be implemented later via
    the payments layer.
    """

    __tablename__ = "channel_gifts"
    __table_args__ = (
        {"schema": _OFFICIALS_DB_SCHEMA} if _OFFICIALS_DB_SCHEMA else {},
    )

    id: _sa_Mapped[int] = _sa_mapped_column(
        _sa_Integer, primary_key=True, autoincrement=True
    )
    user_key: _sa_Mapped[str] = _sa_mapped_column(_sa_String(128), index=True)
    account_id: _sa_Mapped[str] = _sa_mapped_column(_sa_String(64), index=True)
    item_id: _sa_Mapped[str] = _sa_mapped_column(_sa_String(64), index=True)
    gift_kind: _sa_Mapped[str] = _sa_mapped_column(
        _sa_String(32), default="coin"
    )
    coins: _sa_Mapped[int] = _sa_mapped_column(_sa_Integer, default=1)
    created_at: _sa_Mapped[datetime] = _sa_mapped_column(
        _sa_DateTime(timezone=True), server_default=_sa_func.now()
    )


def _sticker_packs_config() -> list[dict[str, Any]]:
    """
    Static sticker pack catalog for the Shamell sticker store.

    This is intentionally simple and mirrors the built‑in packs
    in the Flutter client so that the marketplace can render a
    WeChat‑like catalog without requiring binary updates for
    basic metadata changes.
    """
    return [
        {
            "id": "classic_smileys",
            "name_en": "Classic smileys",
            "name_ar": "الابتسامات الكلاسيكية",
            "stickers": ["😀", "😂", "🥲", "😅", "😍", "😎", "😭", "😡"],
            "price_cents": 0,
            "currency": DEFAULT_CURRENCY,
            "tags": ["free", "starter"],
            "recommended": True,
        },
        {
            "id": "shamell_taxi",
            "name_en": "Shamell Taxi",
            "name_ar": "شامل تاكسي",
            "stickers": ["🚕", "🛣️", "📍", "⏱️", "💳", "⭐"],
            "price_cents": 0,
            "currency": DEFAULT_CURRENCY,
            "tags": ["free", "transport"],
            "recommended": True,
        },
        {
            "id": "food_lovers",
            "name_en": "Food lovers",
            "name_ar": "محبو الطعام",
            "stickers": ["🍕", "🍔", "🍟", "🍣", "🍰", "☕", "🥙", "🥗"],
            "price_cents": 1500,
            "currency": DEFAULT_CURRENCY,
            "tags": ["paid", "food"],
            "recommended": False,
        },
        {
            "id": "celebration",
            "name_en": "Celebrations",
            "name_ar": "الاحتفالات",
            "stickers": ["🎉", "🎂", "🎁", "🕌", "🕋", "🕯️", "🪅", "🥳"],
            "price_cents": 2000,
            "currency": DEFAULT_CURRENCY,
            "tags": ["paid", "events"],
            "recommended": False,
        },
    ]


_OFFICIAL_ACCOUNTS: dict[str, OfficialAccountOut] = {
    "shamell_taxi": OfficialAccountOut(
        id="shamell_taxi",
        kind="service",
        featured=True,
        name="Shamell Taxi",
        name_ar="شامل تاكسي",
        avatar_url="/icons/taxi.svg",
        verified=True,
        mini_app_id="taxi_rider",
        description="Taxi service integrated with Shamell Pay.",
        chat_peer_id="shamell_taxi",
        category="transport",
        city="Damascus",
        opening_hours="24/7",
        website_url="https://shamell.taxi",
        menu_items=[
            {
                "id": "open_taxi",
                "kind": "mini_app",
                "mini_app_id": "taxi_rider",
                "label_en": "Open Taxi",
                "label_ar": "فتح تاكسي",
            }
        ],
    ),
    "shamell_food": OfficialAccountOut(
        id="shamell_food",
        kind="service",
        featured=True,
        name="Shamell Food",
        name_ar="شامل فود",
        avatar_url="/icons/food.svg",
        verified=True,
        mini_app_id="food",
        description="Order food from nearby restaurants.",
        chat_peer_id="shamell_food",
        category="food_delivery",
        city="Damascus",
        opening_hours="10:00–23:00",
        menu_items=[
            {
                "id": "open_food",
                "kind": "mini_app",
                "mini_app_id": "food",
                "label_en": "Open Food service",
                "label_ar": "فتح خدمة الطعام",
            }
        ],
    ),
    "shamell_pay": OfficialAccountOut(
        id="shamell_pay",
        kind="service",
        featured=True,
        name="Shamell Pay",
        name_ar="شامل باي",
        avatar_url="/icons/pay.svg",
        verified=True,
        mini_app_id="payments",
        description="Scan & Pay, send money and manage your wallet.",
        chat_peer_id="shamell_pay",
        category="payments",
        city="Damascus",
        website_url="https://pay.shamell.app",
        menu_items=[
            {
                "id": "open_wallet",
                "kind": "mini_app",
                "mini_app_id": "payments",
                "label_en": "Open Wallet",
                "label_ar": "فتح المحفظة",
            }
        ],
    ),
    "shamell_stays": OfficialAccountOut(
        id="shamell_stays",
        kind="service",
        featured=False,
        name="Shamell Stays",
        name_ar="شامل ستايز",
        avatar_url="/icons/stays.svg",
        verified=True,
        mini_app_id="stays",
        description="Book hotels and stays inside Shamell.",
        chat_peer_id="shamell_stays",
        category="travel",
        city="Damascus",
        menu_items=[
            {
                "id": "open_stays",
                "kind": "mini_app",
                "mini_app_id": "stays",
                "label_en": "Open Stays",
                "label_ar": "فتح الإقامات",
            }
        ],
    ),
}

_OFFICIAL_FEED_SEED: dict[str, list[dict[str, Any]]] = {
    "shamell_taxi": [
        {
            "id": "taxi_airport_30",
            "type": "promo",
            "title": "30% off airport rides this week",
            "snippet": "Book your airport ride with Shamell Taxi and save 30%.",
            "thumb_url": "/assets/feed/taxi_airport.jpg",
            "ts": "2025-01-10T10:00:00Z",
            "deeplink": {"mini_app_id": "taxi_rider", "payload": {"campaign": "airport_30"}},
        },
    ],
    "shamell_food": [
        {
            "id": "food_free_delivery",
            "type": "promo",
            "title": "Free delivery on your next order",
            "snippet": "Use Shamell Food and get free delivery on selected restaurants.",
            "thumb_url": "/assets/feed/food_promo.jpg",
            "ts": "2025-01-09T18:00:00Z",
            "deeplink": {"mini_app_id": "food", "payload": {"campaign": "free_delivery"}},
        },
    ],
    "shamell_pay": [
        {
            "id": "pay_hb_newyear",
            "type": "promo",
            "title": "New Year red packets",
            "snippet": "Send New Year red packets to friends via Shamell Pay.",
            "thumb_url": "/assets/feed/pay_hb.jpg",
            "ts": "2025-01-01T09:00:00Z",
            "deeplink": {"mini_app_id": "payments", "payload": {"section": "redpacket"}},
        },
    ],
    "shamell_stays": [
        {
            "id": "stays_winter",
            "type": "promo",
            "title": "Winter stays offers",
            "snippet": "Discover discounted winter stays in your favourite cities.",
            "thumb_url": "/assets/feed/stays_winter.jpg",
            "ts": "2025-01-05T12:00:00Z",
            "deeplink": {"mini_app_id": "stays", "payload": {"campaign": "winter_offers"}},
        },
    ],
}

# Per-user follow state: in-memory fallback keyed by sa_cookie.
_OFFICIAL_FOLLOWS: dict[str, set[str]] = {}


def _official_cookie_key(request: Request) -> str:
    cookie = request.headers.get("sa_cookie") or request.cookies.get("sa_cookie") or ""
    if not cookie:
        cookie = "anon"
    return cookie


def _officials_startup() -> None:
    logger = logging.getLogger("shamell.officials")
    try:
        _OfficialBase.metadata.create_all(_officials_engine)
    except Exception:
        logger.exception("failed to init official accounts tables")
        return
    # Best-effort schema upgrade for chat_peer_id and campaign defaults on existing deployments.
    try:
        with _officials_engine.begin() as conn:
            if _OFFICIALS_DB_URL.startswith("sqlite"):
                conn.execute(
                    _sa_text("ALTER TABLE official_accounts ADD COLUMN chat_peer_id VARCHAR(64)")
                )
                conn.execute(
                    _sa_text("ALTER TABLE official_accounts ADD COLUMN category VARCHAR(64)")
                )
                conn.execute(
                    _sa_text("ALTER TABLE official_accounts ADD COLUMN city VARCHAR(64)")
                )
                conn.execute(
                    _sa_text("ALTER TABLE official_accounts ADD COLUMN address VARCHAR(255)")
                )
                conn.execute(
                    _sa_text("ALTER TABLE official_accounts ADD COLUMN opening_hours VARCHAR(255)")
                )
                conn.execute(
                    _sa_text("ALTER TABLE official_accounts ADD COLUMN website_url VARCHAR(255)")
                )
                conn.execute(
                    _sa_text("ALTER TABLE official_accounts ADD COLUMN qr_payload VARCHAR(255)")
                )
                conn.execute(
                    _sa_text("ALTER TABLE official_accounts ADD COLUMN featured BOOLEAN DEFAULT 0")
                )
            else:
                table_name = "official_accounts"
                if _OFFICIALS_DB_SCHEMA:
                    table_name = f"{_OFFICIALS_DB_SCHEMA}.{table_name}"
                conn.execute(
                    _sa_text(
                        f"ALTER TABLE {table_name} ADD COLUMN chat_peer_id VARCHAR(64)"
                    )
                )
                conn.execute(
                    _sa_text(
                        f"ALTER TABLE {table_name} ADD COLUMN category VARCHAR(64)"
                    )
                )
                conn.execute(
                    _sa_text(
                        f"ALTER TABLE {table_name} ADD COLUMN city VARCHAR(64)"
                    )
                )
                conn.execute(
                    _sa_text(
                        f"ALTER TABLE {table_name} ADD COLUMN address VARCHAR(255)"
                    )
                )
                conn.execute(
                    _sa_text(
                        f"ALTER TABLE {table_name} ADD COLUMN opening_hours VARCHAR(255)"
                    )
                )
                conn.execute(
                    _sa_text(
                        f"ALTER TABLE {table_name} ADD COLUMN website_url VARCHAR(255)"
                    )
                )
                conn.execute(
                    _sa_text(
                        f"ALTER TABLE {table_name} ADD COLUMN qr_payload VARCHAR(255)"
                    )
                )
                conn.execute(
                    _sa_text(
                        f"ALTER TABLE {table_name} ADD COLUMN featured BOOLEAN DEFAULT FALSE"
                    )
                )
            # Best-effort schema upgrade for MiniAppDB.moments_shares and runtime_app_id.
            if _OFFICIALS_DB_URL.startswith("sqlite"):
                try:
                    conn.execute(
                        _sa_text(
                            "ALTER TABLE mini_apps ADD COLUMN moments_shares INTEGER DEFAULT 0"
                        )
                    )
                except Exception:
                    pass
                try:
                    conn.execute(
                        _sa_text(
                            "ALTER TABLE mini_apps ADD COLUMN runtime_app_id VARCHAR(64)"
                        )
                    )
                except Exception:
                    pass
            # Best-effort schema upgrade for MiniProgramDB.actions_json on existing deployments.
            try:
                if _OFFICIALS_DB_URL.startswith("sqlite"):
                    conn.execute(
                        _sa_text(
                            "ALTER TABLE mini_programs ADD COLUMN actions_json TEXT"
                        )
                    )
                else:
                    prog_table = "mini_programs"
                    if _OFFICIALS_DB_SCHEMA:
                        prog_table = f"{_OFFICIALS_DB_SCHEMA}.{prog_table}"
                    conn.execute(
                        _sa_text(
                            f"ALTER TABLE {prog_table} ADD COLUMN actions_json TEXT"
                        )
                    )
            except Exception:
                pass
            # Best-effort schema upgrade for ChannelFollowDB on existing deployments.
            try:
                table_name = "channel_follows"
                if _OFFICIALS_DB_SCHEMA:
                    table_name = f"{_OFFICIALS_DB_SCHEMA}.{table_name}"
                conn.execute(
                    _sa_text(
                        f"CREATE TABLE IF NOT EXISTS {table_name} ("
                        "id INTEGER PRIMARY KEY AUTOINCREMENT, "
                        "user_key VARCHAR(128) NOT NULL, "
                        "account_id VARCHAR(64) NOT NULL, "
                        "created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, "
                        "CONSTRAINT uq_channel_follows_user_account UNIQUE (user_key, account_id)"
                        ")"
                    )
                )
            except Exception:
                pass
            # Best-effort schema upgrade for ChannelGiftDB on existing deployments.
            try:
                table_name = "channel_gifts"
                if _OFFICIALS_DB_SCHEMA:
                    table_name = f"{_OFFICIALS_DB_SCHEMA}.{table_name}"
                conn.execute(
                    _sa_text(
                        f"CREATE TABLE IF NOT EXISTS {table_name} ("
                        "id INTEGER PRIMARY KEY AUTOINCREMENT, "
                        "user_key VARCHAR(128) NOT NULL, "
                        "account_id VARCHAR(64) NOT NULL, "
                        "item_id VARCHAR(64) NOT NULL, "
                        "gift_kind VARCHAR(32) DEFAULT 'coin', "
                        "coins INTEGER DEFAULT 1, "
                        "created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP"
                        ")"
                    )
                )
            except Exception:
                pass
            # Best-effort schema upgrade for OfficialFeedItemDB on existing deployments.
            try:
                table_name = "official_feed_items"
                if _OFFICIALS_DB_SCHEMA:
                    table_name = f"{_OFFICIALS_DB_SCHEMA}.{table_name}"
                if _OFFICIALS_DB_URL.startswith("sqlite"):
                    conn.execute(
                        _sa_text(
                            f"CREATE TABLE IF NOT EXISTS {table_name} ("
                            "id INTEGER PRIMARY KEY AUTOINCREMENT, "
                            "account_id VARCHAR(64) NOT NULL, "
                            "slug VARCHAR(64) NOT NULL UNIQUE, "
                            "type VARCHAR(16) DEFAULT 'promo', "
                            "title VARCHAR(255), "
                            "snippet VARCHAR(512), "
                            "thumb_url VARCHAR(255), "
                            "ts TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, "
                            "deeplink_json TEXT"
                            ")"
                        )
                    )
                else:
                    conn.execute(
                        _sa_text(
                            f"CREATE TABLE IF NOT EXISTS {table_name} ("
                            "id SERIAL PRIMARY KEY, "
                            "account_id VARCHAR(64) NOT NULL, "
                            "slug VARCHAR(64) NOT NULL UNIQUE, "
                            "type VARCHAR(16) DEFAULT 'promo', "
                            "title VARCHAR(255), "
                            "snippet VARCHAR(512), "
                            "thumb_url VARCHAR(255), "
                            "ts TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, "
                            "deeplink_json TEXT"
                            ")"
                        )
                    )
            except Exception:
                pass
            # Best-effort schema upgrade for OfficialServiceSessionDB on existing deployments.
            try:
                table_name = "official_service_sessions"
                if _OFFICIALS_DB_SCHEMA:
                    table_name = f"{_OFFICIALS_DB_SCHEMA}.{table_name}"
                conn.execute(
                    _sa_text(
                        f"CREATE TABLE IF NOT EXISTS {table_name} ("
                        "id INTEGER PRIMARY KEY AUTOINCREMENT, "
                        "account_id VARCHAR(64) NOT NULL, "
                        "customer_phone VARCHAR(32) NOT NULL, "
                        "chat_peer_id VARCHAR(64), "
                        "status VARCHAR(16) DEFAULT 'open', "
                        "last_message_ts TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, "
                        "unread_by_operator BOOLEAN DEFAULT TRUE"
                        ")"
                    )
                )
            except Exception:
                pass
            # Best-effort schema upgrade for OfficialTemplateMessageDB on existing deployments.
            try:
                table_name = "official_template_messages"
                if _OFFICIALS_DB_SCHEMA:
                    table_name = f"{_OFFICIALS_DB_SCHEMA}.{table_name}"
                if _OFFICIALS_DB_URL.startswith("sqlite"):
                    conn.execute(
                        _sa_text(
                            f"CREATE TABLE IF NOT EXISTS {table_name} ("
                            "id INTEGER PRIMARY KEY AUTOINCREMENT, "
                            "account_id VARCHAR(64) NOT NULL, "
                            "user_phone VARCHAR(32) NOT NULL, "
                            "title VARCHAR(200) NOT NULL, "
                            "body TEXT NOT NULL, "
                            "deeplink_json TEXT, "
                            "created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, "
                            "read_at TIMESTAMP WITH TIME ZONE"
                            ")"
                        )
                    )
                else:
                    conn.execute(
                        _sa_text(
                            f"CREATE TABLE IF NOT EXISTS {table_name} ("
                            "id SERIAL PRIMARY KEY, "
                            "account_id VARCHAR(64) NOT NULL, "
                            "user_phone VARCHAR(32) NOT NULL, "
                            "title VARCHAR(200) NOT NULL, "
                            "body TEXT NOT NULL, "
                            "deeplink_json TEXT, "
                            "created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP, "
                            "read_at TIMESTAMP WITH TIME ZONE"
                            ")"
                        )
                    )
            except Exception:
                pass
            # Best-effort schema upgrade for MiniProgramDB.usage_score, rating and scopes/review_status.
            try:
                if _OFFICIALS_DB_URL.startswith("sqlite"):
                    conn.execute(
                        _sa_text(
                            "ALTER TABLE mini_programs ADD COLUMN usage_score INTEGER DEFAULT 0"
                        )
                    )
                    conn.execute(
                        _sa_text(
                            "ALTER TABLE mini_programs ADD COLUMN rating REAL"
                        )
                    )
                    conn.execute(
                        _sa_text(
                            "ALTER TABLE mini_programs ADD COLUMN scopes_json TEXT"
                        )
                    )
                    conn.execute(
                        _sa_text(
                            "ALTER TABLE mini_programs ADD COLUMN review_status VARCHAR(32) DEFAULT 'draft'"
                        )
                    )
                else:
                    prog_table = "mini_programs"
                    if _OFFICIALS_DB_SCHEMA:
                        prog_table = f"{_OFFICIALS_DB_SCHEMA}.{prog_table}"
                    conn.execute(
                        _sa_text(
                            f"ALTER TABLE {prog_table} ADD COLUMN usage_score INTEGER DEFAULT 0"
                        )
                    )
                    conn.execute(
                        _sa_text(
                            f"ALTER TABLE {prog_table} ADD COLUMN rating DOUBLE PRECISION"
                        )
                    )
                    conn.execute(
                        _sa_text(
                            f"ALTER TABLE {prog_table} ADD COLUMN scopes_json TEXT"
                        )
                    )
                    conn.execute(
                        _sa_text(
                            f"ALTER TABLE {prog_table} ADD COLUMN review_status VARCHAR(32) DEFAULT 'draft'"
                        )
                    )
            except Exception:
                pass
            else:
                mini_table = "mini_apps"
                if _OFFICIALS_DB_SCHEMA:
                    mini_table = f"{_OFFICIALS_DB_SCHEMA}.{mini_table}"
                try:
                    conn.execute(
                        _sa_text(
                            f"ALTER TABLE {mini_table} ADD COLUMN moments_shares INTEGER DEFAULT 0"
                        )
                    )
                except Exception:
                    pass
                try:
                    conn.execute(
                        _sa_text(
                            f"ALTER TABLE {mini_table} ADD COLUMN runtime_app_id VARCHAR(64)"
                        )
                    )
                except Exception:
                    pass
            # Red-packet campaign defaults (amount/count/note) – best-effort.
            if _OFFICIALS_DB_URL.startswith("sqlite"):
                try:
                    conn.execute(
                        _sa_text(
                            "ALTER TABLE redpacket_campaigns ADD COLUMN default_amount_cents INTEGER"
                        )
                    )
                except Exception:
                    pass
                try:
                    conn.execute(
                        _sa_text(
                            "ALTER TABLE redpacket_campaigns ADD COLUMN default_count INTEGER"
                        )
                    )
                except Exception:
                    pass
                try:
                    conn.execute(
                        _sa_text(
                            "ALTER TABLE redpacket_campaigns ADD COLUMN note VARCHAR(255)"
                        )
                    )
                except Exception:
                    pass
            else:
                camp_table = "redpacket_campaigns"
                if _OFFICIALS_DB_SCHEMA:
                    camp_table = f"{_OFFICIALS_DB_SCHEMA}.{camp_table}"
                try:
                    conn.execute(
                        _sa_text(
                            f"ALTER TABLE {camp_table} ADD COLUMN default_amount_cents INTEGER"
                        )
                    )
                except Exception:
                    pass
                try:
                    conn.execute(
                        _sa_text(
                            f"ALTER TABLE {camp_table} ADD COLUMN note VARCHAR(255)"
                        )
                    )
                except Exception:
                    pass
                try:
                    conn.execute(
                        _sa_text(
                            f"ALTER TABLE {camp_table} ADD COLUMN default_count INTEGER"
                        )
                    )
                except Exception:
                    pass
    except Exception:
        # Ignore if column already exists or migration fails; model uses nullable field.
        pass
    # Seed built-in Official accounts and their feed items using a direct
    # SQLAlchemy Session bound to _officials_engine. We deliberately avoid
    # calling _officials_session() here to prevent recursive startup calls,
    # because _officials_session() itself triggers _officials_startup() on
    # first use.
    try:
        with _sa_Session(_officials_engine) as s:
            existing_ids = set(s.execute(_sa_select(OfficialAccountDB.id)).scalars().all())
            for acc in _OFFICIAL_ACCOUNTS.values():
                if acc.id in existing_ids:
                    continue
                row = OfficialAccountDB(
                    id=acc.id,
                    kind=acc.kind,
                    name=acc.name,
                    name_ar=acc.name_ar,
                    avatar_url=acc.avatar_url,
                    verified=acc.verified,
                    mini_app_id=acc.mini_app_id,
                    description=acc.description,
                    chat_peer_id=acc.chat_peer_id,
                    enabled=True,
                    official=True,
                )
                s.add(row)
            for account_id, items in _OFFICIAL_FEED_SEED.items():
                for item in items:
                    slug = item.get("id")
                    if not slug:
                        continue
                    exists = s.execute(
                        _sa_select(OfficialFeedItemDB).where(OfficialFeedItemDB.slug == slug)
                    ).scalars().first()
                    if exists:
                        continue
                    ts_val = None
                    ts_str = item.get("ts")
                    if ts_str:
                        try:
                            ts_val = datetime.fromisoformat(ts_str.replace("Z", "+00:00"))
                        except Exception:
                            ts_val = None
                    s.add(
                        OfficialFeedItemDB(
                            account_id=account_id,
                            slug=slug,
                            type=item.get("type") or "promo",
                            title=item.get("title"),
                            snippet=item.get("snippet"),
                            thumb_url=item.get("thumb_url"),
                            ts=ts_val,
                            deeplink_json=_json.dumps(item.get("deeplink"))
                            if item.get("deeplink") is not None
                            else None,
                        )
                    )
            s.commit()
    except Exception:
        logger.exception("failed to seed official accounts")


app.router.on_startup.append(_officials_startup)


def _official_menu_items_for(acc: OfficialAccountDB) -> list[dict[str, Any]] | None:
    """
    Lightweight, mini_app_id-based menu config for Official accounts.
    This avoids schema changes by deriving a simple menu from the mini_app_id.
    """
    mid = (acc.mini_app_id or "").strip()
    if not mid:
        return None
    items: list[dict[str, Any]] = []
    if mid in ("payments", "alias", "merchant"):
        items.append(
            {
                "id": "open_wallet",
                "kind": "mini_app",
                "mini_app_id": "payments",
                "label_en": "Open Wallet",
                "label_ar": "فتح المحفظة",
            }
        )
    elif mid == "taxi_rider":
        items.append(
            {
                "id": "open_taxi",
                "kind": "mini_app",
                "mini_app_id": "taxi_rider",
                "label_en": "Open Taxi",
                "label_ar": "فتح تاكسي",
            }
        )
    elif mid == "food":
        items.append(
            {
                "id": "open_food",
                "kind": "mini_app",
                "mini_app_id": "food",
                "label_en": "Open Food service",
                "label_ar": "فتح خدمة الطعام",
            }
        )
    elif mid == "stays":
        items.append(
            {
                "id": "open_stays",
                "kind": "mini_app",
                "mini_app_id": "stays",
                "label_en": "Open Stays",
                "label_ar": "فتح الإقامات",
            }
        )
    return items or None


class OfficialAccountAdminIn(BaseModel):
    id: str
    kind: str = "service"
    name: str
    name_ar: str | None = None
    avatar_url: str | None = None
    verified: bool = True
    mini_app_id: str | None = None
    description: str | None = None
    chat_peer_id: str | None = None
    category: str | None = None
    city: str | None = None
    address: str | None = None
    opening_hours: str | None = None
    website_url: str | None = None
    qr_payload: str | None = None
    featured: bool = False
    enabled: bool = True
    official: bool = True


class OfficialAccountSelfRegisterIn(BaseModel):
    """
    Lightweight payload for self‑service Official account registration.

    Merchants can propose a new WeChat‑style Official account; the
    request is stored separately and can later be reviewed and
    approved by ops before the actual OfficialAccountDB entry is
    created.
    """

    account_id: str
    kind: str = "service"
    name: str
    name_ar: str | None = None
    description: str | None = None
    category: str | None = None
    city: str | None = None
    address: str | None = None
    opening_hours: str | None = None
    website_url: str | None = None
    mini_app_id: str | None = None
    owner_name: str | None = None
    contact_phone: str | None = None
    contact_email: str | None = None


class OfficialAccountRequestOut(BaseModel):
    id: int
    account_id: str
    kind: str
    name: str
    name_ar: str | None = None
    description: str | None = None
    category: str | None = None
    city: str | None = None
    address: str | None = None
    opening_hours: str | None = None
    website_url: str | None = None
    mini_app_id: str | None = None
    owner_name: str | None = None
    contact_phone: str | None = None
    contact_email: str | None = None
    requester_phone: str | None = None
    status: str
    created_at: datetime | None = None
    updated_at: datetime | None = None


class OfficialNotificationIn(BaseModel):
    mode: str | None = None


class OfficialAutoReplyIn(BaseModel):
    kind: str = "welcome"
    keyword: str | None = None
    text: str
    enabled: bool = True


class OfficialAutoReplyOut(BaseModel):
    id: int
    account_id: str
    kind: str = "welcome"
    keyword: str | None = None
    text: str
    enabled: bool = True


class OfficialFeedItemAdminIn(BaseModel):
    account_id: str
    id: str
    type: str = "promo"
    title: str | None = None
    snippet: str | None = None
    thumb_url: str | None = None
    ts: str | None = None
    deeplink: dict[str, Any] | None = None


class OfficialLocationAdminIn(BaseModel):
    account_id: str
    name: str | None = None
    city: str | None = None
    address: str | None = None
    lat: float | None = None
    lon: float | None = None
    phone: str | None = None
    opening_hours: str | None = None


class RedPacketCampaignAdminIn(BaseModel):
    id: str
    account_id: str
    title: str
    active: bool = True
    default_amount_cents: int | None = None
    default_count: int | None = None
    note: str | None = None


class RedPacketCampaignTemplateOut(BaseModel):
    campaign_id: str
    account_id: str
    title: str
    text_en: str
    text_ar: str


class RedPacketCampaignTopMomentOut(BaseModel):
    post_id: int
    text: str | None = None
    ts: str | None = None
    likes: int = 0
    comments: int = 0
    score: float = 0.0


class MiniProgramActionConfig(BaseModel):
    """
    Single action/button in a Mini‑Program manifest.

    kind:
      - open_mod: open a Shamell module (taxi, wallet, ...)
      - open_url: open external URL
      - close: close the Mini‑Program shell
    """

    id: str
    label_en: str
    label_ar: str
    kind: str = "open_mod"
    mod_id: str | None = None
    url: str | None = None


class MiniProgramAdminIn(BaseModel):
    """
    Admin payload for registering a Mini‑Program in the catalogue.

    This is deliberately minimal and focuses on identifiers and
    ownership; versioning is handled via MiniProgramVersionIn.
    """

    app_id: str
    title_en: str
    title_ar: str | None = None
    description_en: str | None = None
    description_ar: str | None = None
    owner_name: str | None = None
    owner_contact: str | None = None
    actions: list[MiniProgramActionConfig] | None = None
    scopes: list[str] | None = None


class MiniProgramVersionIn(BaseModel):
    """
    Admin payload for registering a new Mini‑Program version.
    """

    version: str
    bundle_url: str | None = None
    changelog_en: str | None = None
    changelog_ar: str | None = None


class MiniProgramReleaseIn(BaseModel):
    """
    Marks a specific Mini‑Program version as released on a channel.
    """

    version: str
    channel: str | None = "prod"


class MiniAppAdminIn(BaseModel):
    app_id: str
    title_en: str
    title_ar: str | None = None
    category_en: str | None = None
    category_ar: str | None = None
    description: str | None = None
    icon: str | None = None
    official: bool = False
    enabled: bool = True
    beta: bool = False
    runtime_app_id: str | None = None
    rating: float | None = None
    usage_score: int | None = None


class MiniAppRatingIn(BaseModel):
    rating: int


class MiniProgramRatingIn(BaseModel):
    rating: int


class MiniProgramSelfRegisterIn(BaseModel):
    """
    Lightweight payload for third‑party Mini‑Program self‑registration.

    Developers can register basic metadata for their Mini‑Program; the
    entry starts in status "draft" and can later be reviewed and
    activated by the Shamell ops team via the admin console.
    """

    app_id: str
    title_en: str
    title_ar: str | None = None
    description_en: str | None = None
    description_ar: str | None = None
    owner_name: str | None = None
    owner_contact: str | None = None
    scopes: list[str] | None = None


class MiniProgramSelfVersionIn(BaseModel):
    """
    Minimal payload for developers to propose a new Mini‑Program version.

    These versions are stored in MiniProgramVersionDB but do not
    automatically create a Release; publishing remains an ops action.
    """

    version: str
    bundle_url: str
    changelog_en: str | None = None
    changelog_ar: str | None = None


class ChannelCommentIn(BaseModel):
    text: str


class ChannelUploadIn(BaseModel):
    """
    Lightweight payload for creator-style Channels uploads.

    Creates a new OfficialFeedItemDB row of type "clip" (or "live"
    when requested) for a given Official account. Intended as a
    WeChat-like creator tool for merchants and ops; binary media
    is referenced via thumb_url / deeplink rather than uploaded
    directly. The same payload is also used for the lightweight
    /channels/live/start endpoint.
    """

    official_account_id: str
    title: str | None = None
    snippet: str | None = None
    thumb_url: str | None = None
    deeplink: dict[str, Any] | None = None
    # Optional WeChat-style livestream flag – when true the feed
    # item is stored as type "live" instead of a normal clip.
    is_live: bool | None = None


@app.post("/channels/live/start", response_class=JSONResponse)
def channels_live_start(request: Request, body: ChannelUploadIn) -> dict[str, Any]:
    """
    Convenience endpoint to start a Channels livestream.

    This behaves like /channels/upload but always stores the
    item as type "live" so that the Channels feed and Official
    feed can highlight it as a live session, similar to WeChat
    Channels "Go Live".
    """

    # Force live type regardless of caller-provided flag to keep
    # the semantics explicit for this endpoint.
    body.is_live = True
    return channels_upload(request, body)


@app.get("/admin/official_accounts", response_class=JSONResponse)
def admin_official_accounts_list(request: Request, kind: str | None = None) -> dict[str, Any]:
    _require_admin_v2(request)
    with _officials_session() as s:
        stmt = _sa_select(OfficialAccountDB)
        if kind:
            stmt = stmt.where(OfficialAccountDB.kind == kind)
        rows = s.execute(stmt.order_by(OfficialAccountDB.id)).scalars().all()
        items: list[dict[str, Any]] = []
        for acc in rows:
            items.append(
                {
                    "id": acc.id,
                    "kind": acc.kind,
                    "name": acc.name,
                    "name_ar": acc.name_ar,
                    "avatar_url": acc.avatar_url,
                    "verified": acc.verified,
                    "mini_app_id": acc.mini_app_id,
                    "description": acc.description,
                    "chat_peer_id": getattr(acc, "chat_peer_id", None),
                    "category": getattr(acc, "category", None),
                    "city": getattr(acc, "city", None),
                    "address": getattr(acc, "address", None),
                    "opening_hours": getattr(acc, "opening_hours", None),
                    "website_url": getattr(acc, "website_url", None),
                    "qr_payload": getattr(acc, "qr_payload", None),
                    "featured": getattr(acc, "featured", False),
                    "enabled": acc.enabled,
                    "official": acc.official,
                    "created_at": getattr(acc, "created_at", None),
                    "updated_at": getattr(acc, "updated_at", None),
                }
            )
    return {"accounts": items}


@app.get("/admin/official_account_requests", response_class=JSONResponse)
def admin_official_account_requests_list(
    request: Request, status: str | None = None
) -> dict[str, Any]:
    """
    Lists self‑service Official account registration requests (admin only).

    Ops can filter by status (submitted/approved/rejected) and use the
    separate approve/reject endpoints to drive verification, ähnlich
    zum Mini‑Programs‑Review‑Center.
    """
    _require_admin_v2(request)
    try:
        with _officials_session() as s:
            stmt = _sa_select(OfficialAccountRequestDB)
            if status:
                stmt = stmt.where(OfficialAccountRequestDB.status == status)
            rows = (
                s.execute(
                    stmt.order_by(OfficialAccountRequestDB.created_at.desc())
                )
                .scalars()
                .all()
            )
            items: list[dict[str, Any]] = []
            for row in rows:
                items.append(
                    OfficialAccountRequestOut(
                        id=row.id,
                        account_id=row.account_id,
                        kind=row.kind,
                        name=row.name,
                        name_ar=row.name_ar,
                        description=row.description,
                        category=row.category,
                        city=row.city,
                        address=row.address,
                        opening_hours=row.opening_hours,
                        website_url=row.website_url,
                        mini_app_id=row.mini_app_id,
                        owner_name=row.owner_name,
                        contact_phone=row.contact_phone,
                        contact_email=row.contact_email,
                        requester_phone=row.requester_phone,
                        status=row.status,
                        created_at=row.created_at,
                        updated_at=row.updated_at,
                    ).dict()
                )
        return {"requests": items}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/admin/official_accounts", response_class=JSONResponse)
def admin_official_accounts_create(request: Request, body: OfficialAccountAdminIn) -> dict[str, Any]:
    _require_admin_v2(request)
    data = body
    with _officials_session() as s:
        existing = s.get(OfficialAccountDB, data.id)
        if existing:
            raise HTTPException(status_code=409, detail="official account already exists")
        row = OfficialAccountDB(
            id=data.id,
            kind=data.kind,
            name=data.name,
            name_ar=data.name_ar,
            avatar_url=data.avatar_url,
            verified=data.verified,
            mini_app_id=data.mini_app_id,
            description=data.description,
            chat_peer_id=data.chat_peer_id,
            category=data.category,
            city=data.city,
            address=data.address,
            opening_hours=data.opening_hours,
            website_url=data.website_url,
            qr_payload=data.qr_payload,
            featured=data.featured,
            enabled=data.enabled,
            official=data.official,
        )
        s.add(row)
        s.commit()
        s.refresh(row)
        return {
            "id": row.id,
            "kind": row.kind,
            "name": row.name,
            "name_ar": row.name_ar,
            "avatar_url": row.avatar_url,
            "verified": row.verified,
            "mini_app_id": row.mini_app_id,
            "description": row.description,
            "chat_peer_id": getattr(row, "chat_peer_id", None),
            "category": getattr(row, "category", None),
            "city": getattr(row, "city", None),
            "address": getattr(row, "address", None),
            "opening_hours": getattr(row, "opening_hours", None),
            "website_url": getattr(row, "website_url", None),
            "qr_payload": getattr(row, "qr_payload", None),
            "featured": getattr(row, "featured", False),
            "enabled": row.enabled,
            "official": row.official,
        }


@app.patch("/admin/official_accounts/{account_id}", response_class=JSONResponse)
def admin_official_accounts_update(account_id: str, request: Request, body: dict[str, Any]) -> dict[str, Any]:
    _require_admin_v2(request)
    if not isinstance(body, dict):
        body = {}
    allowed_fields = {
        "kind",
        "name",
        "name_ar",
        "avatar_url",
        "verified",
        "mini_app_id",
        "description",
        "chat_peer_id",
        "category",
        "city",
        "address",
        "opening_hours",
        "website_url",
        "qr_payload",
        "featured",
        "enabled",
        "official",
    }
    with _officials_session() as s:
        row = s.get(OfficialAccountDB, account_id)
        if not row:
            raise HTTPException(status_code=404, detail="official account not found")
        for k, v in body.items():
            if k in allowed_fields:
                setattr(row, k, v)
        s.add(row)
        s.commit()
        s.refresh(row)
        return {
            "id": row.id,
            "kind": row.kind,
            "name": row.name,
            "name_ar": row.name_ar,
            "avatar_url": row.avatar_url,
            "verified": row.verified,
            "mini_app_id": row.mini_app_id,
            "description": row.description,
            "chat_peer_id": getattr(row, "chat_peer_id", None),
            "category": getattr(row, "category", None),
            "city": getattr(row, "city", None),
            "address": getattr(row, "address", None),
            "opening_hours": getattr(row, "opening_hours", None),
            "website_url": getattr(row, "website_url", None),
            "qr_payload": getattr(row, "qr_payload", None),
            "featured": getattr(row, "featured", False),
            "enabled": row.enabled,
            "official": row.official,
        }


@app.delete("/admin/official_accounts/{account_id}", response_class=JSONResponse)
def admin_official_accounts_delete(account_id: str, request: Request) -> dict[str, Any]:
    _require_admin_v2(request)
    with _officials_session() as s:
        row = s.get(OfficialAccountDB, account_id)
        if not row:
            raise HTTPException(status_code=404, detail="official account not found")
        s.delete(row)
        s.commit()
    return {"status": "ok"}


@app.post(
    "/admin/official_account_requests/{request_id}/approve",
    response_class=JSONResponse,
)
def admin_official_account_request_approve(
    request_id: int, request: Request
) -> dict[str, Any]:
    """
    Approves a self‑service Official account request and, if needed,
    creates the corresponding OfficialAccountDB entry.

    The created account is enabled and verified but marked as
    partner/third‑party (official=False) by default; Ops can later
    adjust flags via the Official‑Admin‑Konsole.
    """
    _require_admin_v2(request)
    try:
        with _officials_session() as s:
            req_row = s.get(OfficialAccountRequestDB, request_id)
            if not req_row:
                raise HTTPException(status_code=404, detail="request not found")
            # Ensure the target account exists or create it.
            acc_row = s.get(OfficialAccountDB, req_row.account_id)
            if not acc_row:
                kind = (req_row.kind or "service").strip() or "service"
                # Only accept basic kinds from self‑service; admin can
                # later reclassify (merchant/brand/gov).
                if kind not in {"service", "subscription"}:
                    kind = "service"
                acc_row = OfficialAccountDB(
                    id=req_row.account_id,
                    kind=kind,
                    name=req_row.name,
                    name_ar=req_row.name_ar,
                    description=req_row.description,
                    mini_app_id=req_row.mini_app_id,
                    category=req_row.category,
                    city=req_row.city,
                    address=req_row.address,
                    opening_hours=req_row.opening_hours,
                    website_url=req_row.website_url,
                    verified=True,
                    enabled=True,
                    official=False,
                )
                s.add(acc_row)
            req_row.status = "approved"
            s.add(req_row)
            s.commit()
            s.refresh(req_row)
            try:
                emit_event(
                    "officials",
                    "request_approved",
                    {
                        "request_id": req_row.id,
                        "account_id": req_row.account_id,
                        "requester_phone": req_row.requester_phone,
                    },
                )
            except Exception:
                pass
            out = OfficialAccountRequestOut(
                id=req_row.id,
                account_id=req_row.account_id,
                kind=req_row.kind,
                name=req_row.name,
                name_ar=req_row.name_ar,
                description=req_row.description,
                category=req_row.category,
                city=req_row.city,
                address=req_row.address,
                opening_hours=req_row.opening_hours,
                website_url=req_row.website_url,
                mini_app_id=req_row.mini_app_id,
                owner_name=req_row.owner_name,
                contact_phone=req_row.contact_phone,
                contact_email=req_row.contact_email,
                requester_phone=req_row.requester_phone,
                status=req_row.status,
                created_at=req_row.created_at,
                updated_at=req_row.updated_at,
            )
            return out.dict()
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post(
    "/admin/official_account_requests/{request_id}/reject",
    response_class=JSONResponse,
)
def admin_official_account_request_reject(
    request_id: int, request: Request
) -> dict[str, Any]:
    """
    Marks a self‑service Official account request as rejected.

    Does not delete any existing OfficialAccountDB entries – this is
    purely a review/verification decision.
    """
    _require_admin_v2(request)
    try:
        with _officials_session() as s:
            req_row = s.get(OfficialAccountRequestDB, request_id)
            if not req_row:
                raise HTTPException(status_code=404, detail="request not found")
            req_row.status = "rejected"
            s.add(req_row)
            s.commit()
            s.refresh(req_row)
            try:
                emit_event(
                    "officials",
                    "request_rejected",
                    {
                        "request_id": req_row.id,
                        "account_id": req_row.account_id,
                        "requester_phone": req_row.requester_phone,
                    },
                )
            except Exception:
                pass
            out = OfficialAccountRequestOut(
                id=req_row.id,
                account_id=req_row.account_id,
                kind=req_row.kind,
                name=req_row.name,
                name_ar=req_row.name_ar,
                description=req_row.description,
                category=req_row.category,
                city=req_row.city,
                address=req_row.address,
                opening_hours=req_row.opening_hours,
                website_url=req_row.website_url,
                mini_app_id=req_row.mini_app_id,
                owner_name=req_row.owner_name,
                contact_phone=req_row.contact_phone,
                contact_email=req_row.contact_email,
                requester_phone=req_row.requester_phone,
                status=req_row.status,
                created_at=req_row.created_at,
                updated_at=req_row.updated_at,
            )
            return out.dict()
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/admin/official_accounts/{account_id}/auto_replies", response_class=JSONResponse)
def admin_official_auto_replies_list(account_id: str, request: Request) -> dict[str, Any]:
    """
    Lists all auto‑reply rules for a single Official account.

    This is used by the in‑app owner console to configure welcome
    messages and, in the future, keyword‑based replies.
    """

    _require_admin_v2(request)
    with _officials_session() as s:
        acc = s.get(OfficialAccountDB, account_id)
        if not acc:
            raise HTTPException(status_code=404, detail="official account not found")
        stmt = _sa_select(OfficialAutoReplyDB).where(
            OfficialAutoReplyDB.account_id == account_id
        ).order_by(OfficialAutoReplyDB.id.asc())
        rows = s.execute(stmt).scalars().all()
        rules: list[dict[str, Any]] = []
        for row in rows:
            rules.append(
                {
                    "id": row.id,
                    "account_id": row.account_id,
                    "kind": row.kind,
                    "keyword": row.keyword,
                    "text": row.text,
                    "enabled": bool(row.enabled),
                }
            )
    return {"rules": rules}


@app.post("/admin/official_accounts/{account_id}/auto_replies", response_class=JSONResponse)
def admin_official_auto_replies_create(
    account_id: str, request: Request, body: OfficialAutoReplyIn
) -> dict[str, Any]:
    """
    Creates a single auto‑reply rule for an Official account.

    For now the primary use‑case is a "welcome" style message that
    can be surfaced in chat when a user first opens a conversation
    with the Official account.
    """

    _require_admin_v2(request)
    text = (body.text or "").strip()
    if not text:
        raise HTTPException(status_code=400, detail="text is required")
    kind = (body.kind or "welcome").strip().lower() or "welcome"
    keyword = (body.keyword or "").strip() or None
    with _officials_session() as s:
        acc = s.get(OfficialAccountDB, account_id)
        if not acc:
            raise HTTPException(status_code=404, detail="official account not found")
        row = OfficialAutoReplyDB(
            account_id=account_id,
            kind=kind,
            keyword=keyword,
            text=text,
            enabled=bool(body.enabled),
        )
        s.add(row)
        s.commit()
        s.refresh(row)
        return {
            "id": row.id,
            "account_id": row.account_id,
            "kind": row.kind,
            "keyword": row.keyword,
            "text": row.text,
            "enabled": bool(row.enabled),
        }


@app.patch("/admin/official_auto_replies/{rule_id}", response_class=JSONResponse)
def admin_official_auto_replies_update(
    rule_id: int, request: Request, body: dict[str, Any]
) -> dict[str, Any]:
    """
    Updates a single auto‑reply rule.
    """

    _require_admin_v2(request)
    if not isinstance(body, dict):
        body = {}
    allowed_fields = {"kind", "keyword", "text", "enabled"}
    with _officials_session() as s:
        row = s.get(OfficialAutoReplyDB, rule_id)
        if not row:
            raise HTTPException(status_code=404, detail="auto‑reply not found")
        for k, v in body.items():
            if k not in allowed_fields:
                continue
            if k == "kind" and isinstance(v, str):
                v = v.strip().lower() or "welcome"
            if k == "keyword":
                v = (v or "").strip() or None
            if k == "text":
                v = (v or "").strip()
                if not v:
                    raise HTTPException(status_code=400, detail="text is required")
            setattr(row, k, v)
        s.add(row)
        s.commit()
        s.refresh(row)
        return {
            "id": row.id,
            "account_id": row.account_id,
            "kind": row.kind,
            "keyword": row.keyword,
            "text": row.text,
            "enabled": bool(row.enabled),
        }


@app.delete("/admin/official_auto_replies/{rule_id}", response_class=JSONResponse)
def admin_official_auto_replies_delete(rule_id: int, request: Request) -> dict[str, Any]:
    """
    Deletes a single auto‑reply rule.
    """

    _require_admin_v2(request)
    with _officials_session() as s:
        row = s.get(OfficialAutoReplyDB, rule_id)
        if not row:
            raise HTTPException(status_code=404, detail="auto‑reply not found")
        s.delete(row)
        s.commit()
    return {"status": "ok"}


@app.get("/admin/official_feeds", response_class=JSONResponse)
def admin_official_feeds_list(request: Request, account_id: str = "", limit: int = 100) -> dict[str, Any]:
    _require_admin_v2(request)
    limit_val = max(1, min(limit, 500))
    with _officials_session() as s:
        stmt = _sa_select(OfficialFeedItemDB)
        if account_id:
            stmt = stmt.where(OfficialFeedItemDB.account_id == account_id)
        stmt = stmt.order_by(OfficialFeedItemDB.ts.desc(), OfficialFeedItemDB.id.desc()).limit(limit_val)
        rows = s.execute(stmt).scalars().all()
        items: list[dict[str, Any]] = []
        for row in rows:
            try:
                deeplink = _json.loads(row.deeplink_json) if row.deeplink_json else None
            except Exception:
                deeplink = None
            items.append(
                {
                    "account_id": row.account_id,
                    "id": row.slug,
                    "type": row.type,
                    "title": row.title,
                    "snippet": row.snippet,
                    "thumb_url": row.thumb_url,
                    "ts": row.ts.isoformat() if getattr(row, "ts", None) else None,
                    "deeplink": deeplink,
                }
            )
    return {"items": items}


@app.post("/admin/official_feeds", response_class=JSONResponse)
def admin_official_feeds_create(request: Request, body: OfficialFeedItemAdminIn) -> dict[str, Any]:
    _require_admin_v2(request)
    data = body
    with _officials_session() as s:
        acc = s.get(OfficialAccountDB, data.account_id)
        if not acc:
            raise HTTPException(status_code=404, detail="official account not found")
        exists = s.execute(
            _sa_select(OfficialFeedItemDB).where(OfficialFeedItemDB.slug == data.id)
        ).scalars().first()
        if exists:
            raise HTTPException(status_code=409, detail="feed item already exists")
        ts_val = None
        if data.ts:
            try:
                ts_val = datetime.fromisoformat(data.ts.replace("Z", "+00:00"))
            except Exception:
                ts_val = None
        deeplink_json = _json.dumps(data.deeplink) if data.deeplink is not None else None
        row = OfficialFeedItemDB(
            account_id=data.account_id,
            slug=data.id,
            type=data.type or "promo",
            title=data.title,
            snippet=data.snippet,
            thumb_url=data.thumb_url,
            ts=ts_val,
            deeplink_json=deeplink_json,
        )
        s.add(row)
        s.commit()
        s.refresh(row)
        return {
            "account_id": row.account_id,
            "id": row.slug,
            "type": row.type,
            "title": row.title,
            "snippet": row.snippet,
            "thumb_url": row.thumb_url,
            "ts": row.ts.isoformat() if getattr(row, "ts", None) else None,
            "deeplink": data.deeplink,
        }


@app.patch("/admin/official_feeds/{slug}", response_class=JSONResponse)
def admin_official_feeds_update(slug: str, request: Request, body: dict[str, Any]) -> dict[str, Any]:
    _require_admin_v2(request)
    if not isinstance(body, dict):
        body = {}
    with _officials_session() as s:
        row = s.execute(
            _sa_select(OfficialFeedItemDB).where(OfficialFeedItemDB.slug == slug)
        ).scalars().first()
        if not row:
            raise HTTPException(status_code=404, detail="feed item not found")
        if "account_id" in body and body["account_id"]:
            new_acc = s.get(OfficialAccountDB, body["account_id"])
            if not new_acc:
                raise HTTPException(status_code=404, detail="official account not found")
            row.account_id = body["account_id"]
        for field in ("type", "title", "snippet", "thumb_url"):
            if field in body:
                setattr(row, field, body[field])
        if "ts" in body:
            ts_val = None
            ts_str = body.get("ts")
            if ts_str:
                try:
                    ts_val = datetime.fromisoformat(str(ts_str).replace("Z", "+00:00"))
                except Exception:
                    ts_val = None
            row.ts = ts_val
        if "deeplink" in body:
            val = body.get("deeplink")
            row.deeplink_json = _json.dumps(val) if val is not None else None
        s.add(row)
        s.commit()
        s.refresh(row)
        deeplink_val = None
        try:
            deeplink_val = _json.loads(row.deeplink_json) if row.deeplink_json else None
        except Exception:
            deeplink_val = None
        return {
            "account_id": row.account_id,
            "id": row.slug,
            "type": row.type,
            "title": row.title,
            "snippet": row.snippet,
            "thumb_url": row.thumb_url,
            "ts": row.ts.isoformat() if getattr(row, "ts", None) else None,
            "deeplink": deeplink_val,
        }


@app.delete("/admin/official_feeds/{slug}", response_class=JSONResponse)
def admin_official_feeds_delete(slug: str, request: Request) -> dict[str, Any]:
    _require_admin_v2(request)
    with _officials_session() as s:
        row = s.execute(
            _sa_select(OfficialFeedItemDB).where(OfficialFeedItemDB.slug == slug)
        ).scalars().first()
        if not row:
            raise HTTPException(status_code=404, detail="feed item not found")
        s.delete(row)
        s.commit()
    return {"status": "ok"}


@app.get(
    "/admin/official_accounts/{account_id}/service_inbox",
    response_class=JSONResponse,
)
def admin_official_service_inbox(
    account_id: str,
    request: Request,
    status: str | None = None,
    limit: int = 100,
) -> dict[str, Any]:
    """
    Lists lightweight customer-service sessions for an Official account (admin only).

    This provides a WeChat-like unified service inbox with basic
    session state such as open/closed and unread-by-operator flag.
    """
    _require_admin_v2(request)
    limit_val = max(1, min(limit, 500))
    try:
        with _officials_session() as s:
            acc = s.get(OfficialAccountDB, account_id)
            if not acc:
                raise HTTPException(
                    status_code=404, detail="official account not found"
                )
            stmt = _sa_select(OfficialServiceSessionDB).where(
                OfficialServiceSessionDB.account_id == account_id
            )
            if status:
                stmt = stmt.where(OfficialServiceSessionDB.status == status)
            stmt = stmt.order_by(
                OfficialServiceSessionDB.unread_by_operator.desc(),
                OfficialServiceSessionDB.last_message_ts.desc(),
            ).limit(limit_val)
            rows = s.execute(stmt).scalars().all()
            items: list[dict[str, Any]] = []
            for row in rows:
                items.append(
                    {
                        "id": row.id,
                        "account_id": row.account_id,
                        "customer_phone": row.customer_phone,
                        "chat_peer_id": row.chat_peer_id,
                        "status": row.status,
                        "last_message_ts": row.last_message_ts.isoformat(),
                        "unread_by_operator": row.unread_by_operator,
                    }
                )
        return {"sessions": items}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post(
    "/admin/official_accounts/{account_id}/service_inbox/{session_id}/mark_read",
    response_class=JSONResponse,
)
def admin_official_service_inbox_mark_read(
    account_id: str, session_id: int, request: Request
) -> dict[str, Any]:
    """
    Marks a service session as read from the operator perspective.
    """
    _require_admin_v2(request)
    try:
        with _officials_session() as s:
            sess = s.get(OfficialServiceSessionDB, session_id)
            if not sess or sess.account_id != account_id:
                raise HTTPException(status_code=404, detail="session not found")
            if sess.unread_by_operator:
                sess.unread_by_operator = False
                s.add(sess)
                s.commit()
                s.refresh(sess)
            return {
                "id": sess.id,
                "account_id": sess.account_id,
                "customer_phone": sess.customer_phone,
                "chat_peer_id": sess.chat_peer_id,
                "status": sess.status,
                "last_message_ts": sess.last_message_ts.isoformat(),
                "unread_by_operator": sess.unread_by_operator,
            }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post(
    "/admin/official_accounts/{account_id}/service_inbox/{session_id}/close",
    response_class=JSONResponse,
)
def admin_official_service_inbox_close(
    account_id: str, session_id: int, request: Request
) -> dict[str, Any]:
    """
    Closes a customer-service session (sets status=closed).
    """
    _require_admin_v2(request)
    try:
        with _officials_session() as s:
            sess = s.get(OfficialServiceSessionDB, session_id)
            if not sess or sess.account_id != account_id:
                raise HTTPException(status_code=404, detail="session not found")
            sess.status = "closed"
            sess.unread_by_operator = False
            s.add(sess)
            s.commit()
            s.refresh(sess)
            return {
                "id": sess.id,
                "account_id": sess.account_id,
                "customer_phone": sess.customer_phone,
                "chat_peer_id": sess.chat_peer_id,
                "status": sess.status,
                "last_message_ts": sess.last_message_ts.isoformat(),
                "unread_by_operator": sess.unread_by_operator,
            }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post(
    "/admin/official_accounts/{account_id}/service_inbox/{session_id}/template_messages",
    response_class=JSONResponse,
)
def admin_official_service_inbox_send_template_message(
    account_id: str,
    session_id: int,
    request: Request,
    body: dict[str, Any],
) -> dict[str, Any]:
    """
    Sends a one-time Official template message to the customer behind a service session.

    This is a convenience wrapper around OfficialTemplateMessageDB so that
    operators can send WeChat-like subscription messages directly from
    the service inbox without handling phone numbers manually.
    """
    _require_admin_v2(request)
    if not isinstance(body, dict):
        body = {}
    title = (body.get("title") or "").strip()
    msg_body = (body.get("body") or "").strip()
    deeplink = body.get("deeplink_json")
    if not title:
        raise HTTPException(status_code=400, detail="title required")
    if not msg_body:
        raise HTTPException(status_code=400, detail="body required")
    try:
        with _officials_session() as s:
            sess = s.get(OfficialServiceSessionDB, session_id)
            if not sess or sess.account_id != account_id:
                raise HTTPException(status_code=404, detail="session not found")
            acc = s.get(OfficialAccountDB, account_id)
            if not acc:
                raise HTTPException(
                    status_code=404, detail="official account not found"
                )
            deeplink_json = (
                _json.dumps(deeplink) if isinstance(deeplink, dict) else None
            )
            row = OfficialTemplateMessageDB(
                account_id=account_id,
                user_phone=sess.customer_phone,
                title=title,
                body=msg_body,
                deeplink_json=deeplink_json,
            )
            s.add(row)
            s.commit()
            s.refresh(row)
            try:
                emit_event(
                    "officials",
                    "template_message_sent",
                    {
                        "account_id": row.account_id,
                        "user_phone": row.user_phone,
                        "message_id": row.id,
                        "session_id": sess.id,
                    },
                )
            except Exception:
                pass
            try:
                dl = (
                    _json.loads(row.deeplink_json)
                    if row.deeplink_json
                    else None
                )
            except Exception:
                dl = None
            out = OfficialTemplateMessageOut(
                id=row.id,
                account_id=row.account_id,
                title=row.title,
                body=row.body,
                deeplink_json=dl,
                created_at=row.created_at,
                read_at=row.read_at,
            )
            return out.dict()
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/admin/official_template_messages", response_class=JSONResponse)
def admin_official_template_messages_create(
    request: Request, body: OfficialTemplateMessageIn
) -> dict[str, Any]:
    """
    Creates a lightweight per-user Official template message (admin only).

    This models WeChat-like one-time subscription messages that are
    delivered outside the end-to-end encrypted chat stream.
    """
    _require_admin_v2(request)
    data = body
    try:
        with _officials_session() as s:
            acc = s.get(OfficialAccountDB, data.account_id)
            if not acc:
                raise HTTPException(
                    status_code=404, detail="official account not found"
                )
            deeplink_json = (
                _json.dumps(data.deeplink_json)
                if data.deeplink_json is not None
                else None
            )
            row = OfficialTemplateMessageDB(
                account_id=data.account_id,
                user_phone=data.user_phone,
                title=data.title,
                body=data.body,
                deeplink_json=deeplink_json,
            )
            s.add(row)
            s.commit()
            s.refresh(row)
            try:
                emit_event(
                    "officials",
                    "template_message_sent",
                    {
                        "account_id": row.account_id,
                        "user_phone": row.user_phone,
                        "message_id": row.id,
                    },
                )
            except Exception:
                pass
            try:
                deeplink = (
                    _json.loads(row.deeplink_json)
                    if row.deeplink_json
                    else None
                )
            except Exception:
                deeplink = None
            out = OfficialTemplateMessageOut(
                id=row.id,
                account_id=row.account_id,
                title=row.title,
                body=row.body,
                deeplink_json=deeplink,
                created_at=row.created_at,
                read_at=row.read_at,
            )
            return out.dict()
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/admin/official_locations", response_class=JSONResponse)
def admin_official_locations_list(request: Request, account_id: str = "", limit: int = 500) -> dict[str, Any]:
    _require_admin_v2(request)
    limit_val = max(1, min(limit, 1000))
    with _officials_session() as s:
        stmt = _sa_select(OfficialLocationDB)
        if account_id:
            stmt = stmt.where(OfficialLocationDB.account_id == account_id)
        stmt = stmt.order_by(OfficialLocationDB.id.desc()).limit(limit_val)
        rows = s.execute(stmt).scalars().all()
        items: list[dict[str, Any]] = []
        for row in rows:
            items.append(
                {
                    "id": row.id,
                    "account_id": row.account_id,
                    "name": row.name,
                    "city": row.city,
                    "address": row.address,
                    "lat": row.lat,
                    "lon": row.lon,
                    "phone": row.phone,
                    "opening_hours": row.opening_hours,
                }
            )
    return {"locations": items}


@app.post("/admin/official_locations", response_class=JSONResponse)
def admin_official_locations_create(request: Request, body: OfficialLocationAdminIn) -> dict[str, Any]:
    _require_admin_v2(request)
    data = body
    with _officials_session() as s:
        acc = s.get(OfficialAccountDB, data.account_id)
        if not acc:
            raise HTTPException(status_code=404, detail="official account not found")
        row = OfficialLocationDB(
            account_id=data.account_id,
            name=data.name,
            city=data.city,
            address=data.address,
            lat=data.lat,
            lon=data.lon,
            phone=data.phone,
            opening_hours=data.opening_hours,
        )
        s.add(row)
        s.commit()
        s.refresh(row)
        return {
            "id": row.id,
            "account_id": row.account_id,
            "name": row.name,
            "city": row.city,
            "address": row.address,
            "lat": row.lat,
            "lon": row.lon,
            "phone": row.phone,
            "opening_hours": row.opening_hours,
        }


@app.patch("/admin/official_locations/{loc_id}", response_class=JSONResponse)
def admin_official_locations_update(loc_id: int, request: Request, body: dict[str, Any]) -> dict[str, Any]:
    _require_admin_v2(request)
    if not isinstance(body, dict):
        body = {}
    allowed_fields = {"account_id", "name", "city", "address", "lat", "lon", "phone", "opening_hours"}
    with _officials_session() as s:
        row = s.get(OfficialLocationDB, loc_id)
        if not row:
            raise HTTPException(status_code=404, detail="location not found")
        if "account_id" in body and body["account_id"]:
            acc = s.get(OfficialAccountDB, body["account_id"])
            if not acc:
                raise HTTPException(status_code=404, detail="official account not found")
        for k, v in body.items():
            if k in allowed_fields:
                setattr(row, k, v)
        s.add(row)
        s.commit()
        s.refresh(row)
        return {
            "id": row.id,
            "account_id": row.account_id,
            "name": row.name,
            "city": row.city,
            "address": row.address,
            "lat": row.lat,
            "lon": row.lon,
            "phone": row.phone,
            "opening_hours": row.opening_hours,
        }


@app.delete("/admin/official_locations/{loc_id}", response_class=JSONResponse)
def admin_official_locations_delete(loc_id: int, request: Request) -> dict[str, Any]:
    _require_admin_v2(request)
    with _officials_session() as s:
        row = s.get(OfficialLocationDB, loc_id)
        if not row:
            raise HTTPException(status_code=404, detail="location not found")
        s.delete(row)
        s.commit()
    return {"status": "ok"}


@app.get("/admin/redpacket_campaigns", response_class=JSONResponse)
def admin_redpacket_campaigns_list(
    request: Request, account_id: str = "", only_active: bool = False
) -> dict[str, Any]:
    _require_admin_v2(request)
    with _officials_session() as s:
        stmt = _sa_select(RedPacketCampaignDB)
        if account_id:
            stmt = stmt.where(RedPacketCampaignDB.account_id == account_id)
        if only_active:
            stmt = stmt.where(RedPacketCampaignDB.active.is_(True))
        rows = s.execute(stmt.order_by(RedPacketCampaignDB.created_at.desc())).scalars().all()
        items: list[dict[str, Any]] = []
        for row in rows:
            created = getattr(row, "created_at", None)
            updated = getattr(row, "updated_at", None)
            created_str = None
            updated_str = None
            try:
                created_str = created.isoformat().replace("+00:00", "Z") if created else None
            except Exception:
                created_str = str(created) if created is not None else None
            try:
                updated_str = updated.isoformat().replace("+00:00", "Z") if updated else None
            except Exception:
                updated_str = str(updated) if updated is not None else None
            items.append(
                {
                    "id": row.id,
                    "account_id": row.account_id,
                    "title": row.title,
                    "active": bool(getattr(row, "active", True)),
                    "created_at": created_str,
                    "updated_at": updated_str,
                    "default_amount_cents": getattr(row, "default_amount_cents", None),
                    "default_count": getattr(row, "default_count", None),
                    "note": getattr(row, "note", None),
                }
            )
    return {"campaigns": items}


@app.post("/admin/redpacket_campaigns", response_class=JSONResponse)
def admin_redpacket_campaigns_create(
    request: Request, body: RedPacketCampaignAdminIn
) -> dict[str, Any]:
    _require_admin_v2(request)
    data = body
    cid = (data.id or "").strip()
    if not cid:
        raise HTTPException(status_code=400, detail="id is required")
    with _officials_session() as s:
        acc = s.get(OfficialAccountDB, data.account_id)
        if not acc:
            raise HTTPException(status_code=404, detail="official account not found")
        existing = s.get(RedPacketCampaignDB, cid)
        if existing:
            raise HTTPException(status_code=409, detail="campaign already exists")
        row = RedPacketCampaignDB(
            id=cid,
            account_id=data.account_id,
            title=data.title,
            active=data.active,
            default_amount_cents=data.default_amount_cents,
            default_count=data.default_count,
            note=data.note,
        )
        s.add(row)
        s.commit()
        s.refresh(row)
        created = getattr(row, "created_at", None)
        created_str = None
        try:
            created_str = created.isoformat().replace("+00:00", "Z") if created else None
        except Exception:
            created_str = str(created) if created is not None else None
        return {
            "id": row.id,
            "account_id": row.account_id,
            "title": row.title,
            "active": bool(getattr(row, "active", True)),
            "created_at": created_str,
        }


@app.patch("/admin/redpacket_campaigns/{campaign_id}", response_class=JSONResponse)
def admin_redpacket_campaigns_update(
    campaign_id: str, request: Request, body: dict[str, Any]
) -> dict[str, Any]:
    _require_admin_v2(request)
    if not isinstance(body, dict):
        body = {}
    allowed_fields = {"account_id", "title", "active", "default_amount_cents", "default_count", "note"}
    with _officials_session() as s:
        row = s.get(RedPacketCampaignDB, campaign_id)
        if not row:
            raise HTTPException(status_code=404, detail="campaign not found")
        if "account_id" in body and body["account_id"]:
            acc = s.get(OfficialAccountDB, body["account_id"])
            if not acc:
                raise HTTPException(status_code=404, detail="official account not found")
        for k, v in body.items():
            if k in allowed_fields:
                setattr(row, k, v)
        s.add(row)
        s.commit()
        s.refresh(row)
        created = getattr(row, "created_at", None)
        updated = getattr(row, "updated_at", None)
        created_str = None
        updated_str = None
        try:
            created_str = created.isoformat().replace("+00:00", "Z") if created else None
        except Exception:
            created_str = str(created) if created is not None else None
        try:
            updated_str = updated.isoformat().replace("+00:00", "Z") if updated else None
        except Exception:
            updated_str = str(updated) if updated is not None else None
        return {
            "id": row.id,
            "account_id": row.account_id,
            "title": row.title,
            "active": bool(getattr(row, "active", True)),
            "created_at": created_str,
            "updated_at": updated_str,
            "default_amount_cents": getattr(row, "default_amount_cents", None),
            "default_count": getattr(row, "default_count", None),
            "note": getattr(row, "note", None),
        }


@app.delete("/admin/redpacket_campaigns/{campaign_id}", response_class=JSONResponse)
def admin_redpacket_campaigns_delete(campaign_id: str, request: Request) -> dict[str, Any]:
    _require_admin_v2(request)
    with _officials_session() as s:
        row = s.get(RedPacketCampaignDB, campaign_id)
        if not row:
            raise HTTPException(status_code=404, detail="campaign not found")
        # Soft-delete: mark inactive but keep row for historical analytics.
        row.active = False
        s.add(row)
        s.commit()
    return {"status": "ok"}


@app.get(
    "/redpacket/campaigns/{campaign_id}/moments_template",
    response_class=JSONResponse,
)
def redpacket_campaign_moments_template(campaign_id: str) -> dict[str, Any]:
    """
    Returns a best-effort Moments share template for a given Red‑Packet campaign.

    Text is generated from the campaign title and Official account name and
    includes a shamell://official deep-link so Moments can later reconstruct
    origin_official_account_id/origin_official_item_id.
    """
    cid = (campaign_id or "").strip()
    if not cid:
        raise HTTPException(status_code=400, detail="campaign_id required")
    try:
        with _officials_session() as s:
            camp = s.get(RedPacketCampaignDB, cid)
            if not camp:
                raise HTTPException(status_code=404, detail="campaign not found")
            acc = s.get(OfficialAccountDB, camp.account_id)
            acc_name = (acc.name or camp.account_id) if acc else camp.account_id
        base_link = f"shamell://official/{camp.account_id}/{camp.id}"
        title = (camp.title or "").strip() or camp.id
        note = (camp.note or "").strip()
        def_amt = getattr(camp, "default_amount_cents", None)
        def_count = getattr(camp, "default_count", None)
        extra_en = ""
        extra_ar = ""
        try:
            if def_amt and isinstance(def_amt, (int, float)) and def_amt > 0:
                major = float(def_amt) / 100.0
                if def_count and isinstance(def_count, (int, float)) and def_count > 0:
                    extra_en = f"\nDefault: total {major:.2f}, {int(def_count)} recipients."
                    extra_ar = f"\nالإعداد الافتراضي: مجموع {major:.2f}، {int(def_count)} مستلمين."
                else:
                    extra_en = f"\nDefault: total {major:.2f}."
                    extra_ar = f"\nالإعداد الافتراضي: مجموع {major:.2f}."
            elif def_count and isinstance(def_count, (int, float)) and def_count > 0:
                extra_en = f"\nDefault: {int(def_count)} recipients."
                extra_ar = f"\nالإعداد الافتراضي: {int(def_count)} مستلمين."
        except Exception:
            extra_en = ""
            extra_ar = ""
        text_en = (
            f"Red packet campaign from {acc_name}: {title}.\n"
            f"I am sending red packets via Shamell Pay 🎁"
            f"{extra_en}\n"
            f"{base_link}"
        )
        if note:
            text_en = f"{text_en}\n{note}"
        text_ar = (
            f"حملة حزم حمراء من {acc_name}: {title}.\n"
            f"أرسل حزمًا حمراء عبر Shamell Pay 🎁"
            f"{extra_ar}\n"
            f"{base_link}"
        )
        if note:
            text_ar = f"{text_ar}\n{note}"
        return RedPacketCampaignTemplateOut(
            campaign_id=camp.id,
            account_id=camp.account_id,
            title=camp.title,
            text_en=text_en,
            text_ar=text_ar,
        ).dict()
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/admin/officials", response_class=HTMLResponse)
def admin_officials_console(request: Request) -> HTMLResponse:
    """
    Sehr einfache HTML-Konsole für Offizielle Accounts.

    Nutzt die JSON-Admin-API-Endpunkte und lässt bestehende Ops/Admins
    (über _require_admin_v2) neue Accounts anlegen, bearbeiten und
    aktivieren/deaktivieren – ohne zusätzliche Tools.
    """
    _require_admin_v2(request)
    html = """
<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Shamell · Official Accounts</title>
    <style>
      body { font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif; margin: 16px; max-width: 1100px; color: #0f172a; background:#ffffff; }
      h1 { margin-bottom: 4px; }
      h2 { margin-top: 24px; margin-bottom: 8px; }
      table { border-collapse: collapse; width: 100%; margin-top: 8px; }
      th, td { border: 1px solid #e5e7eb; padding: 6px 8px; font-size: 13px; text-align: left; vertical-align: top; }
      th { background: #f9fafb; font-weight: 600; }
      input, select, textarea { font-size: 13px; padding: 4px 6px; margin: 2px 0; width: 100%; box-sizing: border-box; }
      textarea { min-height: 48px; }
      button { font-size: 13px; padding: 4px 8px; margin: 0 2px; cursor: pointer; }
      .pill { display:inline-block; padding:2px 6px; border-radius:999px; font-size:11px; }
      .pill-on { background:#dcfce7; color:#166534; }
      .pill-off { background:#fee2e2; color:#991b1b; }
      .pill-official { background:#dbeafe; color:#1d4ed8; }
      .pill-beta { background:#fef3c7; color:#92400e; }
      .pill-featured { background:#fef9c3; color:#92400e; }
      .row-actions { white-space: nowrap; }
      .muted { color:#6b7280; font-size:12px; }
      .error { color:#b91c1c; margin-top:4px; }
      .success { color:#166534; margin-top:4px; }
      .flex { display:flex; gap:8px; flex-wrap:wrap; }
      .flex > div { flex:1 1 260px; min-width:220px; }
      code { font-size:12px; background:#f3f4f6; padding:2px 4px; border-radius:4px; }
    </style>
  </head>
  <body>
    <h1>Official Accounts</h1>
    <p class="muted">
      <a href="/admin/officials/analytics">Analytics-Dashboard für Official Accounts öffnen</a>
      · <a href="/admin/redpacket_campaigns/analytics">Red‑Packet‑Kampagnen-Analytics</a>
    </p>
    <p class="muted">WeChat-ähnliche Service-/Merchant-Accounts für Shamell Discover &amp; Feeds.</p>

    <div id="flash" class="muted"></div>

    <h2>Bestehende Accounts</h2>
    <p class="muted">Toggle <code>enabled</code>/<code>official</code> für Partner-Mini-Apps, Merchants, Beta-Experimente.</p>
    <table id="accounts-table">
      <thead>
        <tr>
          <th>ID</th>
          <th>Name</th>
          <th>Kind</th>
          <th>Mini-App</th>
          <th>Chat ID</th>
          <th>Kategorie/Ort</th>
          <th>Status</th>
          <th>Beschreibung</th>
          <th>Aktionen</th>
        </tr>
      </thead>
      <tbody id="accounts-body">
        <tr><td colspan="9">Lade Daten…</td></tr>
      </tbody>
    </table>

    <h2>Neuen Official Account anlegen</h2>
    <div class="flex">
      <div>
        <label>ID (z.B. <code>shamell_taxi</code>)<br/>
          <input id="new_id" placeholder="eindeutige ID" />
        </label>
      </div>
      <div>
        <label>Name<br/>
          <input id="new_name" placeholder="Anzeigename (EN)" />
        </label>
      </div>
      <div>
        <label>Name (AR)<br/>
          <input id="new_name_ar" placeholder="Anzeigename (AR, optional)" />
        </label>
      </div>
    </div>
    <div class="flex">
      <div>
        <label>Kind<br/>
          <select id="new_kind">
            <option value="service">service</option>
            <option value="merchant">merchant</option>
            <option value="brand">brand</option>
            <option value="gov">gov</option>
          </select>
        </label>
      </div>
      <div>
        <label>Mini-App ID<br/>
          <input id="new_mini_app_id" placeholder="z.B. payments, taxi_rider, food" />
        </label>
      </div>
      <div>
        <label>Avatar URL<br/>
          <input id="new_avatar_url" placeholder="/icons/… oder https://…" />
        </label>
      </div>
      <div>
        <label>Chat Peer ID<br/>
          <input id="new_chat_peer_id" placeholder="optional: Chat device ID" />
        </label>
      </div>
    </div>
    <div class="flex">
      <div>
        <label>Beschreibung<br/>
          <textarea id="new_description" placeholder="Kurzbeschreibung"></textarea>
        </label>
      </div>
      <div>
        <label><input type="checkbox" id="new_verified" checked /> Verified</label><br/>
        <label><input type="checkbox" id="new_enabled" checked /> Enabled</label><br/>
        <label><input type="checkbox" id="new_official" checked /> Official (Shamell-Account)</label><br/>
        <label><input type="checkbox" id="new_featured" /> Featured (starred in clients)</label>
      </div>
      <div>
        <label>Kategorie<br/>
          <input id="new_category" placeholder="z.B. taxi, food, pay" />
        </label>
        <label>Stadt<br/>
          <input id="new_city" placeholder="z.B. Damascus" />
        </label>
        <label>Öffnungszeiten<br/>
          <input id="new_opening_hours" placeholder="z.B. 09:00–18:00" />
        </label>
        <label>Website URL<br/>
          <input id="new_website_url" placeholder="https://…" />
        </label>
        <label>QR Payload<br/>
          <input id="new_qr_payload" placeholder="optional: Inhalt für QR" />
        </label>
      </div>
    </div>
    <p>
      <button onclick="createAccount()">Account anlegen</button>
    </p>

    <h2>Self‑Service Official‑Account‑Requests</h2>
    <p class="muted">
      WeChat‑ähnlicher Registrierungs‑Flow: Merchants können im Client
      eigene Official Accounts vorschlagen; hier siehst du die
      eingehenden Requests und kannst sie approven/rejecten.
    </p>
    <p class="muted">
      JSON‑API: <code>/admin/official_account_requests?status=submitted</code>
    </p>
    <p>
      <button onclick="loadOfficialRequests()">Requests laden</button>
      <select id="req_filter">
        <option value="">Alle</option>
        <option value="submitted">Nur submitted</option>
        <option value="approved">Approved</option>
        <option value="rejected">Rejected</option>
      </select>
    </p>
    <table id="requests-table">
      <thead>
        <tr>
          <th>ID</th>
          <th>Account</th>
          <th>Kind</th>
          <th>Owner/Contact</th>
          <th>Ort</th>
          <th>Status</th>
          <th>Erstellt</th>
          <th>Aktionen</th>
        </tr>
      </thead>
      <tbody id="requests-body">
        <tr><td colspan="8">Noch keine Requests geladen.</td></tr>
      </tbody>
    </table>

    <h2>Feed-Items (Promos) pro Account</h2>
    <p class="muted">Einfacher WeChat-ähnlicher Feed: pro Official Account Promotions/News pflegen.</p>
    <div class="flex">
      <div>
        <label>Account wählen<br/>
          <select id="feed_account" onchange="loadFeedsForSelected(); loadCampaignsForSelected()">
            <option value="">– bitte wählen –</option>
          </select>
        </label>
      </div>
      <div>
        <label>Feed-ID (Slug)<br/>
          <input id="feed_id" placeholder="z.B. taxi_airport_30" />
        </label>
      </div>
      <div>
        <label>Typ<br/>
          <input id="feed_type" placeholder="promo, update …" value="promo" />
        </label>
      </div>
    </div>
    <div class="flex">
      <div>
        <label>Title<br/>
          <input id="feed_title" placeholder="Titel" />
        </label>
      </div>
      <div>
        <label>Thumb URL<br/>
          <input id="feed_thumb" placeholder="/assets/feed/… oder https://…" />
        </label>
      </div>
      <div>
        <label>Timestamp (ISO, optional)<br/>
          <input id="feed_ts" placeholder="2025-01-10T10:00:00Z" />
        </label>
      </div>
    </div>
    <div class="flex">
      <div>
        <label>Snippet<br/>
          <textarea id="feed_snippet" placeholder="Kurztext"></textarea>
        </label>
      </div>
      <div>
        <label>Deeplink JSON<br/>
          <textarea id="feed_deeplink" placeholder='{"mini_app_id":"payments","payload":{"section":"redpacket"}}'></textarea>
        </label>
      </div>
    </div>
    <p>
      <button onclick="createFeed()">Feed-Item speichern</button>
      <button onclick="presetRedpacketCampaign()">Red‑Packet‑Kampagne vorbelegen</button>
      <button onclick="wizardRedpacketCampaign()">Kampagnen‑Wizard (Feed + DB)</button>
    </p>

    <table id="feeds-table">
      <thead>
        <tr>
          <th>ID</th>
          <th>Title</th>
          <th>Typ</th>
          <th>TS</th>
          <th>Snippet</th>
          <th>Aktionen</th>
        </tr>
      </thead>
      <tbody id="feeds-body">
        <tr><td colspan="6">Bitte Account wählen.</td></tr>
      </tbody>
    </table>

    <h2>Red‑Packet‑Kampagnen</h2>
    <p class="muted">Pro ausgewähltem Account (oben) WeChat‑ähnliche Red‑Packet‑Kampagnen pflegen.</p>
    <div class="flex">
      <div>
        <label>Kampagnen-ID<br/>
          <input id="campaign_id" placeholder="z.B. redpacket_newyear" />
        </label>
      </div>
      <div>
        <label>Titel<br/>
          <input id="campaign_title" placeholder="z.B. New Year red packets" />
        </label>
      </div>
      <div>
        <label>Aktiv<br/>
          <input type="checkbox" id="campaign_active" checked />
        </label>
      </div>
      <div>
        <label>Default-Betrag (Cent, optional)<br/>
          <input id="campaign_default_amount" placeholder="z.B. 100000" />
        </label>
      </div>
      <div>
        <label>Default-Anzahl (optional)<br/>
          <input id="campaign_default_count" placeholder="z.B. 10" />
        </label>
      </div>
    </div>
    <div class="flex">
      <div>
        <label>Notiz (optional)<br/>
          <input id="campaign_note" placeholder="z.B. Happy New Year red packets" />
        </label>
      </div>
    </div>
    <input type="hidden" id="campaign_edit_id" />
    <p>
      <button onclick="saveCampaign()">Kampagne speichern</button>
    </p>

    <table id="campaigns-table">
      <thead>
        <tr>
          <th>ID</th>
          <th>Title</th>
          <th>Status</th>
          <th>Erstellt</th>
          <th>Aktionen</th>
        </tr>
      </thead>
      <tbody id="campaigns-body">
        <tr><td colspan="5">Bitte Account wählen.</td></tr>
      </tbody>
    </table>

    <h2>Standorte / Filialen</h2>
    <p class="muted">Mehrere Standorte pro Official Account pflegen (z.B. Filialen, Büros, Depots).</p>
    <div class="flex">
      <div>
        <label>Account wählen<br/>
          <select id="loc_account" onchange="loadLocationsForSelected()">
            <option value="">– bitte wählen –</option>
          </select>
        </label>
      </div>
      <div>
        <label>Name<br/>
          <input id="loc_name" placeholder="z.B. Shamell Taxi Damascus" />
        </label>
      </div>
      <div>
        <label>Stadt<br/>
          <input id="loc_city" placeholder="z.B. Damascus" />
        </label>
      </div>
    </div>
    <div class="flex">
      <div>
        <label>Adresse<br/>
          <input id="loc_address" placeholder="Straße, Hausnummer, Bezirk" />
        </label>
      </div>
      <div>
        <label>Telefon<br/>
          <input id="loc_phone" placeholder="+963…" />
        </label>
      </div>
      <div>
        <label>Öffnungszeiten<br/>
          <input id="loc_opening_hours" placeholder="z.B. 09:00–18:00" />
        </label>
      </div>
    </div>
    <div class="flex">
      <div>
        <label>Latitude<br/>
          <input id="loc_lat" placeholder="optional: 33.5138" />
        </label>
      </div>
      <div>
        <label>Longitude<br/>
          <input id="loc_lon" placeholder="optional: 36.2765" />
        </label>
      </div>
    </div>
    <input type="hidden" id="loc_id" />
    <p>
      <button onclick="saveLocation()">Location speichern</button>
    </p>

    <table id="locations-table">
      <thead>
        <tr>
          <th>ID</th>
          <th>Name</th>
          <th>Stadt</th>
          <th>Adresse</th>
          <th>Telefon</th>
          <th>Öffnungszeiten</th>
          <th>Koordinaten</th>
          <th>Aktionen</th>
        </tr>
      </thead>
      <tbody id="locations-body">
        <tr><td colspan="8">Bitte Account wählen.</td></tr>
      </tbody>
    </table>

    <script>
      async function loadAccounts() {
        const bodyEl = document.getElementById('accounts-body');
        const feedSelect = document.getElementById('feed_account');
        const locSelect = document.getElementById('loc_account');
        try {
          const r = await fetch('/admin/official_accounts');
          if (!r.ok) {
            bodyEl.innerHTML = '<tr><td colspan="9">Fehler beim Laden: ' + r.status + '</td></tr>';
            return;
          }
          const data = await r.json();
          const items = data.accounts || [];
          if (!items.length) {
            bodyEl.innerHTML = '<tr><td colspan="9">Noch keine Accounts.</td></tr>';
            if (feedSelect) {
              feedSelect.innerHTML = '<option value="">– keine Accounts –</option>';
            }
            if (locSelect) {
              locSelect.innerHTML = '<option value="">– keine Accounts –</option>';
            }
            return;
          }
          if (feedSelect) {
            feedSelect.innerHTML = '<option value=\"\">– bitte wählen –</option>';
          }
          if (locSelect) {
            locSelect.innerHTML = '<option value=\"\">– bitte wählen –</option>';
          }
          bodyEl.innerHTML = '';
          for (const acc of items) {
            const tr = document.createElement('tr');
            const meta = [
              acc.category || '',
              acc.city || '',
            ].filter(Boolean).join(' · ');
            const statusHtml = [
              '<span class="pill ' + (acc.enabled ? 'pill-on' : 'pill-off') + '">' + (acc.enabled ? 'enabled' : 'disabled') + '</span>',
              acc.official ? '<span class="pill pill-official">official</span>' : '',
              acc.featured ? '<span class="pill pill-featured">featured</span>' : '',
              acc.kind && acc.kind !== 'service' ? '<span class="pill pill-beta">' + acc.kind + '</span>' : '',
            ].filter(Boolean).join(' ');
            tr.innerHTML = `
              <td><code>${acc.id}</code></td>
              <td>${acc.name || ''}<br/><span class="muted">${acc.name_ar || ''}</span></td>
              <td>${acc.kind || ''}</td>
              <td><span class="muted">${acc.mini_app_id || ''}</span></td>
              <td><span class="muted">${acc.chat_peer_id || ''}</span></td>
              <td>${meta || ''}</td>
              <td>${statusHtml}</td>
              <td>${acc.description || ''}</td>
              <td class="row-actions">
                <button onclick="toggleEnabled('${acc.id}', ${acc.enabled ? 'false' : 'true'})">${acc.enabled ? 'Disable' : 'Enable'}</button>
                <button onclick="toggleOfficial('${acc.id}', ${acc.official ? 'false' : 'true'})">${acc.official ? 'Set partner' : 'Set official'}</button>
                <button onclick="toggleFeatured('${acc.id}', ${acc.featured ? 'false' : 'true'})">${acc.featured ? 'Unstar' : 'Star'}</button>
              </td>
            `;
            bodyEl.appendChild(tr);
            if (feedSelect) {
              const optFeed = document.createElement('option');
              optFeed.value = acc.id;
              optFeed.textContent = acc.id + ' – ' + (acc.name || '');
              feedSelect.appendChild(optFeed);
            }
            if (locSelect) {
              const optLoc = document.createElement('option');
              optLoc.value = acc.id;
              optLoc.textContent = acc.id + ' – ' + (acc.name || '');
              locSelect.appendChild(optLoc);
            }
          }
        } catch (e) {
          bodyEl.innerHTML = '<tr><td colspan="9">Fehler: ' + e + '</td></tr>';
        }
      }

      async function patchAccount(id, patch) {
        const flash = document.getElementById('flash');
        flash.textContent = '';
        try {
          const r = await fetch('/admin/official_accounts/' + encodeURIComponent(id), {
            method: 'PATCH',
            headers: {'content-type':'application/json'},
            body: JSON.stringify(patch),
          });
          if (!r.ok) {
            const txt = await r.text();
            flash.textContent = 'Fehler: ' + r.status + ' ' + txt;
            flash.className = 'error';
          } else {
            flash.textContent = 'Gespeichert.';
            flash.className = 'success';
            loadAccounts();
          }
        } catch (e) {
          flash.textContent = 'Fehler: ' + e;
          flash.className = 'error';
        }
      }

      function toggleEnabled(id, enabled) {
        patchAccount(id, {enabled: !!enabled});
      }

      function toggleOfficial(id, official) {
        patchAccount(id, {official: !!official});
      }

      function toggleFeatured(id, featured) {
        patchAccount(id, {featured: !!featured});
      }

      async function createAccount() {
        const flash = document.getElementById('flash');
        flash.textContent = '';
        const id = document.getElementById('new_id').value.trim();
        const name = document.getElementById('new_name').value.trim();
        const name_ar = document.getElementById('new_name_ar').value.trim();
        const kind = document.getElementById('new_kind').value.trim() || 'service';
        const mini_app_id = document.getElementById('new_mini_app_id').value.trim();
        const avatar_url = document.getElementById('new_avatar_url').value.trim();
        const chat_peer_id = document.getElementById('new_chat_peer_id').value.trim();
        const description = document.getElementById('new_description').value.trim();
        const category = document.getElementById('new_category').value.trim();
        const city = document.getElementById('new_city').value.trim();
        const opening_hours = document.getElementById('new_opening_hours').value.trim();
        const website_url = document.getElementById('new_website_url').value.trim();
        const qr_payload = document.getElementById('new_qr_payload').value.trim();
        const verified = document.getElementById('new_verified').checked;
        const enabled = document.getElementById('new_enabled').checked;
        const official = document.getElementById('new_official').checked;
        const featured = document.getElementById('new_featured').checked;
        if (!id || !name) {
          flash.textContent = 'ID und Name sind Pflicht.';
          flash.className = 'error';
          return;
        }
        const payload = {
          id,
          kind,
          name,
          name_ar: name_ar || null,
          avatar_url: avatar_url || null,
          verified,
          mini_app_id: mini_app_id || null,
          description: description || null,
          chat_peer_id: chat_peer_id || null,
          category: category || null,
          city: city || null,
          opening_hours: opening_hours || null,
          website_url: website_url || null,
          qr_payload: qr_payload || null,
          featured,
          enabled,
          official,
        };
        try {
          const r = await fetch('/admin/official_accounts', {
            method: 'POST',
            headers: {'content-type':'application/json'},
            body: JSON.stringify(payload),
          });
          if (!r.ok) {
            const txt = await r.text();
            flash.textContent = 'Fehler: ' + r.status + ' ' + txt;
            flash.className = 'error';
          } else {
            flash.textContent = 'Account angelegt.';
            flash.className = 'success';
            document.getElementById('new_id').value = '';
            document.getElementById('new_name').value = '';
            document.getElementById('new_name_ar').value = '';
            document.getElementById('new_mini_app_id').value = '';
            document.getElementById('new_avatar_url').value = '';
            document.getElementById('new_chat_peer_id').value = '';
            document.getElementById('new_description').value = '';
            document.getElementById('new_category').value = '';
            document.getElementById('new_city').value = '';
            document.getElementById('new_opening_hours').value = '';
            document.getElementById('new_website_url').value = '';
            document.getElementById('new_qr_payload').value = '';
            document.getElementById('new_verified').checked = true;
            document.getElementById('new_enabled').checked = true;
            document.getElementById('new_official').checked = true;
            document.getElementById('new_featured').checked = false;
            loadAccounts();
          }
        } catch (e) {
          flash.textContent = 'Fehler: ' + e;
          flash.className = 'error';
        }
      }

      async function loadFeedsForSelected() {
        const accId = document.getElementById('feed_account').value;
        const bodyEl = document.getElementById('feeds-body');
        if (!accId) {
          bodyEl.innerHTML = '<tr><td colspan="6">Bitte Account wählen.</td></tr>';
          return;
        }
        try {
          const r = await fetch('/admin/official_feeds?account_id=' + encodeURIComponent(accId));
          if (!r.ok) {
            bodyEl.innerHTML = '<tr><td colspan="6">Fehler beim Laden: ' + r.status + '</td></tr>';
            return;
          }
          const data = await r.json();
          const items = data.items || [];
          if (!items.length) {
            bodyEl.innerHTML = '<tr><td colspan="6">Noch keine Feed-Items.</td></tr>';
            return;
          }
          bodyEl.innerHTML = '';
          for (const it of items) {
            const tr = document.createElement('tr');
            tr.innerHTML = `
              <td><code>${it.id}</code></td>
              <td>${it.title || ''}</td>
              <td>${it.type || ''}</td>
              <td><span class="muted">${it.ts || ''}</span></td>
              <td>${it.snippet || ''}</td>
              <td class="row-actions">
                <button onclick="copyFeedToForm('${it.id.replace(/'/g, '')}')">Bearbeiten</button>
                <button onclick="deleteFeed('${it.id.replace(/'/g, '')}')">Löschen</button>
              </td>
            `;
            tr.dataset.feedId = it.id;
            tr.dataset.feedTitle = it.title || '';
            tr.dataset.feedType = it.type || '';
            tr.dataset.feedTs = it.ts || '';
            tr.dataset.feedSnippet = it.snippet || '';
            tr.dataset.feedThumb = it.thumb_url || '';
            tr.dataset.feedDeeplink = it.deeplink ? JSON.stringify(it.deeplink) : '';
            bodyEl.appendChild(tr);
          }
        } catch (e) {
          bodyEl.innerHTML = '<tr><td colspan="6">Fehler: ' + e + '</td></tr>';
        }
      }

      function copyFeedToForm(id) {
        const bodyEl = document.getElementById('feeds-body');
        const rows = bodyEl.querySelectorAll('tr');
        for (const tr of rows) {
          if (tr.dataset.feedId === id) {
            document.getElementById('feed_id').value = tr.dataset.feedId || '';
            document.getElementById('feed_title').value = tr.dataset.feedTitle || '';
            document.getElementById('feed_type').value = tr.dataset.feedType || 'promo';
            document.getElementById('feed_ts').value = tr.dataset.feedTs || '';
            document.getElementById('feed_snippet').value = tr.dataset.feedSnippet || '';
            document.getElementById('feed_thumb').value = tr.dataset.feedThumb || '';
            document.getElementById('feed_deeplink').value = tr.dataset.feedDeeplink || '';
            break;
          }
        }
      }

      async function deleteFeed(id) {
        const accId = document.getElementById('feed_account').value;
        if (!accId || !id) return;
        const flash = document.getElementById('flash');
        flash.textContent = '';
        try {
          const r = await fetch('/admin/official_feeds/' + encodeURIComponent(id), { method: 'DELETE' });
          if (!r.ok) {
            const txt = await r.text();
            flash.textContent = 'Fehler beim Löschen: ' + r.status + ' ' + txt;
            flash.className = 'error';
          } else {
            flash.textContent = 'Feed-Item gelöscht.';
            flash.className = 'success';
            loadFeedsForSelected();
          }
        } catch (e) {
          flash.textContent = 'Fehler: ' + e;
          flash.className = 'error';
        }
      }

      async function createFeed() {
        const flash = document.getElementById('flash');
        flash.textContent = '';
        const account_id = document.getElementById('feed_account').value.trim();
        const id = document.getElementById('feed_id').value.trim();
        const type = document.getElementById('feed_type').value.trim() || 'promo';
        const title = document.getElementById('feed_title').value.trim();
        const thumb = document.getElementById('feed_thumb').value.trim();
        const ts = document.getElementById('feed_ts').value.trim();
        const snippet = document.getElementById('feed_snippet').value.trim();
        const deeplinkStr = document.getElementById('feed_deeplink').value.trim();
        if (!account_id || !id) {
          flash.textContent = 'Account und Feed-ID sind Pflicht.';
          flash.className = 'error';
          return;
        }
        let deeplink = null;
        if (deeplinkStr) {
          try {
            deeplink = JSON.parse(deeplinkStr);
          } catch (e) {
            flash.textContent = 'Deeplink ist kein gültiges JSON.';
            flash.className = 'error';
            return;
          }
        }
        const payload = {
          account_id,
          id,
          type,
          title: title || null,
          snippet: snippet || null,
          thumb_url: thumb || null,
          ts: ts || null,
          deeplink,
        };
        try {
          const r = await fetch('/admin/official_feeds', {
            method: 'POST',
            headers: {'content-type':'application/json'},
            body: JSON.stringify(payload),
          });
          if (!r.ok) {
            const txt = await r.text();
            flash.textContent = 'Fehler beim Speichern: ' + r.status + ' ' + txt;
            flash.className = 'error';
          } else {
            flash.textContent = 'Feed-Item gespeichert.';
            flash.className = 'success';
            loadFeedsForSelected();
          }
        } catch (e) {
          flash.textContent = 'Fehler: ' + e;
          flash.className = 'error';
        }
      }

      function presetRedpacketCampaign() {
        const accId = document.getElementById('feed_account').value.trim();
        const flash = document.getElementById('flash');
        flash.textContent = '';
        if (!accId) {
          flash.textContent = 'Bitte zuerst einen Official-Account auswählen.';
          flash.className = 'error';
          return;
        }
        const slug = window.prompt('Kampagnen-ID (z.B. newyear_redpacket):', 'redpacket_' + accId);
        if (!slug || !slug.trim()) {
          return;
        }
        const now = new Date().toISOString();
        document.getElementById('feed_id').value = slug.trim();
        document.getElementById('feed_type').value = 'promo';
        if (!document.getElementById('feed_title').value.trim()) {
          document.getElementById('feed_title').value = 'Red‑packet campaign';
        }
        if (!document.getElementById('feed_snippet').value.trim()) {
          document.getElementById('feed_snippet').value = 'Launch a red‑packet promotion for this merchant.';
        }
        if (!document.getElementById('feed_ts').value.trim()) {
          document.getElementById('feed_ts').value = now;
        }
        const deeplink = {
          mini_app_id: 'payments',
          payload: {
            section: 'redpacket',
            campaign: slug.trim(),
            merchant_official_id: accId
          }
        };
        document.getElementById('feed_deeplink').value = JSON.stringify(deeplink);
        flash.textContent = 'Vorlage für Red‑Packet‑Kampagne befüllt – Felder ggf. anpassen und dann speichern.';
        flash.className = 'success';
      }

      async function wizardRedpacketCampaign() {
        const accId = document.getElementById('feed_account').value.trim();
        const flash = document.getElementById('flash');
        if (flash) {
          flash.textContent = '';
        }
        if (!accId) {
          if (flash) {
            flash.textContent = 'Bitte zuerst einen Official-Account auswählen.';
            flash.className = 'error';
          }
          return;
        }
        let slug = document.getElementById('campaign_id').value.trim();
        if (!slug) {
          slug = window.prompt('Kampagnen-ID (z.B. newyear_redpacket):', 'redpacket_' + accId) || '';
          slug = slug.trim();
        }
        if (!slug) {
          return;
        }
        const now = new Date().toISOString();
        // Prefill feed fields (wie presetRedpacketCampaign)
        document.getElementById('feed_id').value = slug;
        document.getElementById('feed_type').value = 'promo';
        if (!document.getElementById('feed_title').value.trim()) {
          document.getElementById('feed_title').value = 'Red‑packet campaign';
        }
        if (!document.getElementById('feed_snippet').value.trim()) {
          document.getElementById('feed_snippet').value = 'Launch a red‑packet promotion for this merchant.';
        }
        if (!document.getElementById('feed_ts').value.trim()) {
          document.getElementById('feed_ts').value = now;
        }
        const deeplink = {
          mini_app_id: 'payments',
          payload: {
            section: 'redpacket',
            campaign: slug,
            merchant_official_id: accId
          }
        };
        document.getElementById('feed_deeplink').value = JSON.stringify(deeplink);
        // Build campaign payload (mit Defaults, falls gesetzt)
        const title = (document.getElementById('campaign_title').value.trim() ||
                       document.getElementById('feed_title').value.trim() ||
                       'Red‑packet campaign');
        const defAmountStr = document.getElementById('campaign_default_amount').value.trim();
        const defCountStr = document.getElementById('campaign_default_count').value.trim();
        const campPayload = {
          id: slug,
          account_id: accId,
          title,
          active: true,
        };
        if (defAmountStr) {
          const v = Number(defAmountStr);
          if (!Number.isNaN(v)) {
            campPayload.default_amount_cents = Math.trunc(v);
          }
        }
        if (defCountStr) {
          const v = Number(defCountStr);
          if (!Number.isNaN(v)) {
            campPayload.default_count = Math.trunc(v);
          }
        }
        const noteStr = document.getElementById('campaign_note').value.trim();
        if (noteStr) {
          campPayload.note = noteStr;
        }
        try {
          const r = await fetch('/admin/redpacket_campaigns', {
            method: 'POST',
            headers: {'content-type':'application/json'},
            body: JSON.stringify(campPayload),
          });
          if (!r.ok) {
            const txt = await r.text();
            if (flash) {
              flash.textContent = 'Fehler beim Anlegen der Kampagne: ' + r.status + ' ' + txt;
              flash.className = 'error';
            }
            return;
          }
        } catch (e) {
          if (flash) {
            flash.textContent = 'Fehler beim Anlegen der Kampagne: ' + e;
            flash.className = 'error';
          }
          return;
        }
        try {
          // Feed-Item direkt erstellen
          await createFeed();
          if (flash) {
            flash.textContent = 'Kampagne und Feed-Item angelegt.';
            flash.className = 'success';
          }
          // Formular etwas aufräumen
          document.getElementById('campaign_id').value = slug;
          document.getElementById('campaign_title').value = title;
          loadCampaignsForSelected();
        } catch (e) {
          if (flash) {
            flash.textContent = 'Kampagne angelegt, aber Fehler beim Feed-Item: ' + e;
            flash.className = 'error';
          }
        }
      }

      async function loadCampaignsForSelected() {
        const bodyEl = document.getElementById('campaigns-body');
        if (!bodyEl) return;
        const accId = document.getElementById('feed_account').value;
        if (!accId) {
          bodyEl.innerHTML = '<tr><td colspan="5">Bitte Account wählen.</td></tr>';
          return;
        }
        try {
          const r = await fetch('/admin/redpacket_campaigns?account_id=' + encodeURIComponent(accId));
          if (!r.ok) {
            bodyEl.innerHTML = '<tr><td colspan="5">Fehler beim Laden: ' + r.status + '</td></tr>';
            return;
          }
          const data = await r.json();
          const items = data.campaigns || [];
          if (!items.length) {
            bodyEl.innerHTML = '<tr><td colspan="5">Noch keine Kampagnen.</td></tr>';
            return;
          }
          bodyEl.innerHTML = '';
          for (const c of items) {
            const idSafe = String(c.id || '').replace(/'/g, '');
            const tr = document.createElement('tr');
            tr.innerHTML = `
              <td><code>${c.id}</code></td>
              <td>${c.title || ''}</td>
              <td>${c.active ? 'aktiv' : 'inaktiv'}</td>
              <td><span class="muted">${c.created_at || ''}</span></td>
              <td class="row-actions">
                <button onclick="copyCampaignToForm('${idSafe}')">Bearbeiten</button>
                <button onclick="toggleCampaignActive('${idSafe}', ${c.active ? 'false' : 'true'})">${c.active ? 'Deaktivieren' : 'Aktivieren'}</button>
              </td>
            `;
            tr.dataset.campaignId = String(c.id || '');
            tr.dataset.campaignTitle = c.title || '';
            tr.dataset.campaignActive = c.active ? 'true' : 'false';
            tr.dataset.campaignDefaultAmount = (c.default_amount_cents != null ? String(c.default_amount_cents) : '');
            tr.dataset.campaignDefaultCount = (c.default_count != null ? String(c.default_count) : '');
            tr.dataset.campaignNote = (c.note || '');
            bodyEl.appendChild(tr);
          }
        } catch (e) {
          bodyEl.innerHTML = '<tr><td colspan="5">Fehler: ' + e + '</td></tr>';
        }
      }

      function copyCampaignToForm(id) {
        const bodyEl = document.getElementById('campaigns-body');
        if (!bodyEl) return;
        const rows = bodyEl.querySelectorAll('tr');
        for (const tr of rows) {
          if (!tr.dataset) continue;
          if (tr.dataset.campaignId === String(id)) {
            document.getElementById('campaign_edit_id').value = tr.dataset.campaignId || '';
            document.getElementById('campaign_id').value = tr.dataset.campaignId || '';
            document.getElementById('campaign_title').value = tr.dataset.campaignTitle || '';
            document.getElementById('campaign_active').checked = (tr.dataset.campaignActive === 'true');
            document.getElementById('campaign_default_amount').value = tr.dataset.campaignDefaultAmount || '';
            document.getElementById('campaign_default_count').value = tr.dataset.campaignDefaultCount || '';
            document.getElementById('campaign_note').value = tr.dataset.campaignNote || '';
            break;
          }
        }
      }

      async function saveCampaign() {
        const flash = document.getElementById('flash');
        if (flash) {
          flash.textContent = '';
        }
        const accId = document.getElementById('feed_account').value.trim();
        const editId = document.getElementById('campaign_edit_id').value.trim();
        const id = document.getElementById('campaign_id').value.trim();
        const title = document.getElementById('campaign_title').value.trim();
        const active = document.getElementById('campaign_active').checked;
        const defaultAmountStr = document.getElementById('campaign_default_amount').value.trim();
        const defaultCountStr = document.getElementById('campaign_default_count').value.trim();
        const noteStr = document.getElementById('campaign_note').value.trim();
        if (!accId || !id || !title) {
          if (flash) {
            flash.textContent = 'Account, Kampagnen-ID und Titel sind Pflicht.';
            flash.className = 'error';
          }
          return;
        }
        const payload = {
          account_id: accId,
          title,
          active,
        };
        if (defaultAmountStr) {
          const v = Number(defaultAmountStr);
          if (!Number.isNaN(v)) {
            payload.default_amount_cents = Math.trunc(v);
          }
        }
        if (defaultCountStr) {
          const v = Number(defaultCountStr);
          if (!Number.isNaN(v)) {
            payload.default_count = Math.trunc(v);
          }
        }
        if (noteStr) {
          payload.note = noteStr;
        }
        let url = '/admin/redpacket_campaigns';
        let method = 'POST';
        if (editId && editId === id) {
          url = '/admin/redpacket_campaigns/' + encodeURIComponent(id);
          method = 'PATCH';
        } else {
          payload.id = id;
        }
        try {
          const r = await fetch(url, {
            method,
            headers: {'content-type':'application/json'},
            body: JSON.stringify(payload),
          });
          if (!r.ok) {
            const txt = await r.text();
            if (flash) {
              flash.textContent = 'Fehler beim Speichern der Kampagne: ' + r.status + ' ' + txt;
              flash.className = 'error';
            }
          } else {
            if (flash) {
              flash.textContent = 'Kampagne gespeichert.';
              flash.className = 'success';
            }
            document.getElementById('campaign_edit_id').value = '';
            document.getElementById('campaign_id').value = '';
            document.getElementById('campaign_title').value = '';
            document.getElementById('campaign_active').checked = true;
            document.getElementById('campaign_default_amount').value = '';
            document.getElementById('campaign_default_count').value = '';
            document.getElementById('campaign_note').value = '';
            loadCampaignsForSelected();
          }
        } catch (e) {
          if (flash) {
            flash.textContent = 'Fehler: ' + e;
            flash.className = 'error';
          }
        }
      }

      async function toggleCampaignActive(id, active) {
        const flash = document.getElementById('flash');
        if (flash) {
          flash.textContent = '';
        }
        if (!id) return;
        const payload = {active: !!active};
        try {
          const r = await fetch('/admin/redpacket_campaigns/' + encodeURIComponent(id), {
            method: 'PATCH',
            headers: {'content-type':'application/json'},
            body: JSON.stringify(payload),
          });
          if (!r.ok) {
            const txt = await r.text();
            if (flash) {
              flash.textContent = 'Fehler beim Aktualisieren der Kampagne: ' + r.status + ' ' + txt;
              flash.className = 'error';
            }
          } else {
            if (flash) {
              flash.textContent = 'Kampagnenstatus aktualisiert.';
              flash.className = 'success';
            }
            loadCampaignsForSelected();
          }
        } catch (e) {
          if (flash) {
            flash.textContent = 'Fehler: ' + e;
            flash.className = 'error';
          }
        }
      }

      async function loadLocationsForSelected() {
        const accSelect = document.getElementById('loc_account');
        const bodyEl = document.getElementById('locations-body');
        if (!accSelect || !bodyEl) return;
        const accId = accSelect.value;
        if (!accId) {
          bodyEl.innerHTML = '<tr><td colspan="8">Bitte Account wählen.</td></tr>';
          return;
        }
        try {
          const r = await fetch('/admin/official_locations?account_id=' + encodeURIComponent(accId));
          if (!r.ok) {
            bodyEl.innerHTML = '<tr><td colspan="8">Fehler beim Laden: ' + r.status + '</td></tr>';
            return;
          }
          const data = await r.json();
          const items = data.locations || data.items || [];
          if (!items.length) {
            bodyEl.innerHTML = '<tr><td colspan="8">Noch keine Locations.</td></tr>';
            return;
          }
          bodyEl.innerHTML = '';
          for (const loc of items) {
            const tr = document.createElement('tr');
            const lat = loc.lat != null ? String(loc.lat) : '';
            const lon = loc.lon != null ? String(loc.lon) : '';
            tr.innerHTML = `
              <td>${loc.id}</td>
              <td>${loc.name || ''}</td>
              <td>${loc.city || ''}</td>
              <td>${loc.address || ''}</td>
              <td>${loc.phone || ''}</td>
              <td>${loc.opening_hours || ''}</td>
              <td>${lat && lon ? lat + ', ' + lon : ''}</td>
              <td class="row-actions">
                <button onclick="copyLocationToForm('${loc.id}')">Bearbeiten</button>
                <button onclick="deleteLocation('${loc.id}')">Löschen</button>
              </td>
            `;
            tr.dataset.locId = String(loc.id);
            tr.dataset.locName = loc.name || '';
            tr.dataset.locCity = loc.city || '';
            tr.dataset.locAddress = loc.address || '';
            tr.dataset.locPhone = loc.phone || '';
            tr.dataset.locOpening = loc.opening_hours || '';
            tr.dataset.locLat = lat;
            tr.dataset.locLon = lon;
            bodyEl.appendChild(tr);
          }
        } catch (e) {
          bodyEl.innerHTML = '<tr><td colspan="8">Fehler: ' + e + '</td></tr>';
        }
      }

      function copyLocationToForm(id) {
        const bodyEl = document.getElementById('locations-body');
        if (!bodyEl) return;
        const rows = bodyEl.querySelectorAll('tr');
        for (const tr of rows) {
          if (!tr.dataset) continue;
          if (tr.dataset.locId === String(id)) {
            document.getElementById('loc_id').value = tr.dataset.locId || '';
            document.getElementById('loc_name').value = tr.dataset.locName || '';
            document.getElementById('loc_city').value = tr.dataset.locCity || '';
            document.getElementById('loc_address').value = tr.dataset.locAddress || '';
            document.getElementById('loc_phone').value = tr.dataset.locPhone || '';
            document.getElementById('loc_opening_hours').value = tr.dataset.locOpening || '';
            document.getElementById('loc_lat').value = tr.dataset.locLat || '';
            document.getElementById('loc_lon').value = tr.dataset.locLon || '';
            break;
          }
        }
      }

      async function deleteLocation(id) {
        const flash = document.getElementById('flash');
        flash.textContent = '';
        try {
          const r = await fetch('/admin/official_locations/' + encodeURIComponent(id), { method: 'DELETE' });
          if (!r.ok) {
            const txt = await r.text();
            flash.textContent = 'Fehler beim Löschen: ' + r.status + ' ' + txt;
            flash.className = 'error';
          } else {
            flash.textContent = 'Location gelöscht.';
            flash.className = 'success';
            loadLocationsForSelected();
          }
        } catch (e) {
          flash.textContent = 'Fehler: ' + e;
          flash.className = 'error';
        }
      }

      async function saveLocation() {
        const flash = document.getElementById('flash');
        flash.textContent = '';
        const locId = document.getElementById('loc_id').value.trim();
        const account_id = document.getElementById('loc_account').value.trim();
        const name = document.getElementById('loc_name').value.trim();
        const city = document.getElementById('loc_city').value.trim();
        const address = document.getElementById('loc_address').value.trim();
        const phone = document.getElementById('loc_phone').value.trim();
        const opening_hours = document.getElementById('loc_opening_hours').value.trim();
        const latStr = document.getElementById('loc_lat').value.trim();
        const lonStr = document.getElementById('loc_lon').value.trim();
        if (!account_id) {
          flash.textContent = 'Bitte Account wählen.';
          flash.className = 'error';
          return;
        }
        const payload = {
          account_id,
          name: name || null,
          city: city || null,
          address: address || null,
          phone: phone || null,
          opening_hours: opening_hours || null,
        };
        if (latStr) {
          const v = Number(latStr);
          if (!Number.isNaN(v)) payload.lat = v;
        }
        if (lonStr) {
          const v = Number(lonStr);
          if (!Number.isNaN(v)) payload.lon = v;
        }
        let url = '/admin/official_locations';
        let method = 'POST';
        if (locId) {
          url = '/admin/official_locations/' + encodeURIComponent(locId);
          method = 'PATCH';
        }
        try {
          const r = await fetch(url, {
            method,
            headers: {'content-type':'application/json'},
            body: JSON.stringify(payload),
          });
          if (!r.ok) {
            const txt = await r.text();
            flash.textContent = 'Fehler beim Speichern: ' + r.status + ' ' + txt;
            flash.className = 'error';
          } else {
            flash.textContent = 'Location gespeichert.';
            flash.className = 'success';
            document.getElementById('loc_id').value = '';
            loadLocationsForSelected();
          }
        } catch (e) {
          flash.textContent = 'Fehler: ' + e;
          flash.className = 'error';
        }
      }

      function escHtml(s) {
        if (!s) return '';
        return String(s)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;');
      }

      async function loadOfficialRequests() {
        const tbody = document.getElementById('requests-body');
        const flash = document.getElementById('flash');
        if (!tbody) return;
        if (flash) {
          flash.textContent = '';
          flash.className = 'muted';
        }
        tbody.innerHTML = '<tr><td colspan="8">Lade Requests…</td></tr>';
        const sel = document.getElementById('req_filter');
        const status = sel ? (sel.value || '').trim() : '';
        let url = '/admin/official_account_requests';
        if (status) {
          url += '?status=' + encodeURIComponent(status);
        }
        try {
          const r = await fetch(url);
          if (!r.ok) {
            const txt = await r.text();
            tbody.innerHTML = '<tr><td colspan="8">Fehler: ' + r.status + ' ' + txt + '</td></tr>';
            if (flash) {
              flash.textContent = 'Fehler beim Laden der Requests.';
              flash.className = 'error';
            }
            return;
          }
          const data = await r.json();
          const items = data.requests || [];
          if (!items.length) {
            tbody.innerHTML = '<tr><td colspan="8">Keine Requests gefunden.</td></tr>';
            return;
          }
          tbody.innerHTML = '';
          for (const req of items) {
            const tr = document.createElement('tr');
            const created = req.created_at || '';
            const owner = [
              req.owner_name || '',
              req.contact_phone || '',
              req.contact_email || '',
            ].filter(Boolean).join(' · ');
            const place = [
              req.city || '',
              req.category || '',
            ].filter(Boolean).join(' · ');
            const statusVal = req.status || '';
            let statusPillClass = 'pill-off';
            if (statusVal === 'submitted') statusPillClass = 'pill-beta';
            else if (statusVal === 'approved') statusPillClass = 'pill-on';
            const statusHtml = '<span class="pill ' + statusPillClass + '">' + escHtml(statusVal) + '</span>';
            tr.innerHTML = `
              <td>${req.id}</td>
              <td><code>${escHtml(req.account_id)}</code><br/><span class="muted">${escHtml(req.name || '')}</span></td>
              <td>${escHtml(req.kind || '')}</td>
              <td>${escHtml(owner)}</td>
              <td>${escHtml(place)}</td>
              <td>${statusHtml}</td>
              <td><span class="muted">${escHtml(created)}</span></td>
              <td class="row-actions">
                <button onclick="approveOfficialRequest(${req.id})">Approve &amp; create</button>
                <button onclick="rejectOfficialRequest(${req.id})">Reject</button>
              </td>
            `;
            tbody.appendChild(tr);
          }
        } catch (e) {
          tbody.innerHTML = '<tr><td colspan="8">Fehler: ' + e + '</td></tr>';
          if (flash) {
            flash.textContent = 'Fehler beim Laden der Requests.';
            flash.className = 'error';
          }
        }
      }

      async function approveOfficialRequest(id) {
        const flash = document.getElementById('flash');
        if (flash) {
          flash.textContent = '';
          flash.className = 'muted';
        }
        if (!id && id !== 0) return;
        try {
          const r = await fetch('/admin/official_account_requests/' + encodeURIComponent(String(id)) + '/approve', {
            method: 'POST',
          });
          if (!r.ok) {
            const txt = await r.text();
            if (flash) {
              flash.textContent = 'Fehler beim Approven: ' + r.status + ' ' + txt;
              flash.className = 'error';
            }
          } else {
            if (flash) {
              flash.textContent = 'Request approved und Official Account ggf. angelegt.';
              flash.className = 'success';
            }
            loadAccounts();
            loadOfficialRequests();
          }
        } catch (e) {
          if (flash) {
            flash.textContent = 'Fehler: ' + e;
            flash.className = 'error';
          }
        }
      }

      async function rejectOfficialRequest(id) {
        const flash = document.getElementById('flash');
        if (flash) {
          flash.textContent = '';
          flash.className = 'muted';
        }
        if (!id && id !== 0) return;
        try {
          const r = await fetch('/admin/official_account_requests/' + encodeURIComponent(String(id)) + '/reject', {
            method: 'POST',
          });
          if (!r.ok) {
            const txt = await r.text();
            if (flash) {
              flash.textContent = 'Fehler beim Rejecten: ' + r.status + ' ' + txt;
              flash.className = 'error';
            }
          } else {
            if (flash) {
              flash.textContent = 'Request rejected.';
              flash.className = 'success';
            }
            loadOfficialRequests();
          }
        } catch (e) {
          if (flash) {
            flash.textContent = 'Fehler: ' + e;
            flash.className = 'error';
          }
        }
      }

      loadAccounts();
      loadOfficialRequests();
    </script>
  </body>
</html>
"""
    return HTMLResponse(content=html)


@app.get("/admin/miniapps", response_class=HTMLResponse)
def admin_miniapps_console(request: Request) -> HTMLResponse:
    """
    Einfache HTML-Konsole für Mini-Apps (Mini-Programme).

    Nutzt die JSON-Admin-Endpunkte /admin/mini_apps, um Partner- und
    Drittanbieter-Apps ähnlich wie WeChat Mini-Programs zu verwalten.
    """
    _require_admin_v2(request)
    html = """
<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Shamell · Mini-Apps</title>
    <style>
      body { font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif; margin: 16px; max-width: 960px; color: #0f172a; background:#ffffff; }
      h1 { margin-bottom: 4px; }
      h2 { margin-top: 24px; margin-bottom: 8px; }
      table { border-collapse: collapse; width: 100%; margin-top: 8px; }
      th, td { border: 1px solid #e5e7eb; padding: 6px 8px; font-size: 13px; text-align: left; vertical-align: top; }
      th { background: #f9fafb; font-weight: 600; }
      input, select, textarea { font-size: 13px; padding: 4px 6px; margin: 2px 0; width: 100%; box-sizing: border-box; }
      textarea { min-height: 48px; }
      button { font-size: 13px; padding: 4px 8px; margin: 0 2px; cursor: pointer; }
      .pill { display:inline-block; padding:2px 6px; border-radius:999px; font-size:11px; }
      .pill-official { background:#dbeafe; color:#1d4ed8; }
      .pill-beta { background:#fef3c7; color:#92400e; }
      .pill-disabled { background:#fee2e2; color:#991b1b; }
      .muted { color:#6b7280; font-size:12px; }
      .row-actions { white-space: nowrap; }
      .error { color:#b91c1c; margin-top:4px; }
      .success { color:#166534; margin-top:4px; }
      .flex { display:flex; gap:8px; flex-wrap:wrap; }
      .flex > div { flex:1 1 220px; min-width:200px; }
      code { font-size:12px; background:#f3f4f6; padding:2px 4px; border-radius:4px; }
    </style>
  </head>
  <body>
    <h1>Mini-Apps</h1>
    <p class="muted">
      WeChat-ähnliche Mini-Programme für das Shamell-Ökosystem.<br/>
      Diese Konsole steuert den Katalog unter <code>/mini_apps</code> und den Mini-Apps-Tab in der Super-App.
    </p>
    <p class="muted">
      <a href="/admin/officials">Official-Accounts-Konsole</a>
      · <a href="/admin/redpacket_campaigns/analytics">Red‑Packet‑Kampagnen-Analytics</a>
      · <a href="/admin/miniapps/analytics">Mini‑Apps‑Analytics</a>
    </p>

    <div id="flash" class="muted"></div>

    <h2>Bestehende Mini-Apps</h2>
    <p class="muted">Status, Rating und Usage-Scores dienen als einfache Trending-Signale (analog zu WeChat Popular Mini-Programs).</p>
    <table id="miniapps-table">
      <thead>
        <tr>
          <th>ID</th>
          <th>Title</th>
          <th>Kategorie</th>
          <th>Runtime</th>
          <th>Status</th>
          <th>Rating</th>
          <th>Usage</th>
          <th>Beschreibung</th>
          <th>Aktionen</th>
        </tr>
      </thead>
      <tbody id="miniapps-body">
        <tr><td colspan="9">Lade Daten…</td></tr>
      </tbody>
    </table>

    <h2>Neue Mini-App registrieren</h2>
    <div class="flex">
      <div>
        <label>App-ID<br/>
          <input id="new_app_id" placeholder="z.B. partner_shop" />
        </label>
      </div>
      <div>
        <label>Titel (EN)<br/>
          <input id="new_title_en" placeholder="Display title (EN)" />
        </label>
      </div>
      <div>
        <label>Titel (AR, optional)<br/>
          <input id="new_title_ar" placeholder="Display title (AR)" />
        </label>
      </div>
    </div>
    <div class="flex">
      <div>
        <label>Kategorie (EN)<br/>
          <input id="new_category_en" placeholder="z.B. Mobility, Marketplace" />
        </label>
      </div>
      <div>
        <label>Kategorie (AR)<br/>
          <input id="new_category_ar" placeholder="optional (AR)" />
        </label>
      </div>
      <div>
        <label>Icon (optional)<br/>
          <input id="new_icon" placeholder="Material-Icon-Name oder custom key" />
        </label>
      </div>
    </div>
    <div class="flex">
      <div>
        <label>Runtime-App-ID (optional, Mini‑Program)<br/>
          <input id="new_runtime_app_id" placeholder="z.B. taxi_demo (Mini-Program app_id)" />
        </label>
      </div>
      <div></div>
      <div></div>
    </div>
    <div class="flex">
      <div>
        <label>Beschreibung<br/>
          <textarea id="new_description" placeholder="Kurzbeschreibung (z.B. Partner-Shop oder Service)"></textarea>
        </label>
      </div>
      <div>
        <label><input type="checkbox" id="new_official" /> Official (Shamell-first-party)</label><br/>
        <label><input type="checkbox" id="new_beta" /> Beta</label><br/>
        <label><input type="checkbox" id="new_enabled" checked /> Enabled</label>
      </div>
      <div>
        <label>Rating (0–5, optional)<br/>
          <input id="new_rating" placeholder="z.B. 4.5" />
        </label>
        <label>Usage-Score (optional)<br/>
          <input id="new_usage" placeholder="z.B. 50" />
        </label>
      </div>
    </div>
    <p>
      <button onclick="createMiniApp()">Mini-App registrieren</button>
    </p>

    <script>
      async function loadMiniApps() {
        const bodyEl = document.getElementById('miniapps-body');
        const flash = document.getElementById('flash');
        flash.textContent = '';
        try {
          const r = await fetch('/admin/mini_apps');
          if (!r.ok) {
            bodyEl.innerHTML = '<tr><td colspan="9">Fehler beim Laden: ' + r.status + '</td></tr>';
            return;
          }
          const data = await r.json();
          const items = data.apps || [];
          if (!items.length) {
            bodyEl.innerHTML = '<tr><td colspan="9">Noch keine Mini-Apps registriert.</td></tr>';
            return;
          }
          bodyEl.innerHTML = '';
          for (const app of items) {
            const tr = document.createElement('tr');
            const statusHtml = [
              app.enabled ? '' : '<span class="pill pill-disabled">disabled</span>',
              app.official ? '<span class="pill pill-official">official</span>' : '',
              app.beta ? '<span class="pill pill-beta">beta</span>' : '',
            ].filter(Boolean).join(' ');
            const rating = (app.rating != null ? app.rating : 0).toFixed ? Number(app.rating).toFixed(1) : String(app.rating || '');
            const usage = app.usage_score != null ? String(app.usage_score) : '';
            const cat = [app.category_en || '', app.category_ar || ''].filter(Boolean).join(' / ');
            const runtime = app.runtime_app_id || '';
            tr.innerHTML = `
              <td><code>${app.app_id || ''}</code></td>
              <td>${app.title_en || ''}<br/><span class="muted">${app.title_ar || ''}</span></td>
              <td>${cat}</td>
              <td>${runtime ? '<code>' + runtime + '</code>' : '<span class="muted">–</span>'}</td>
              <td>${statusHtml || '<span class="muted">–</span>'}</td>
              <td>${rating || ''}</td>
              <td>${usage || ''}</td>
              <td>${app.description || ''}</td>
              <td class="row-actions">
                <button onclick="toggleMiniAppEnabled('${app.app_id}', ${app.enabled ? 'false' : 'true'})">${app.enabled ? 'Disable' : 'Enable'}</button>
                <button onclick="toggleMiniAppOfficial('${app.app_id}', ${app.official ? 'false' : 'true'})">${app.official ? 'Set partner' : 'Set official'}</button>
                <button onclick="editMiniApp('${app.app_id}')">Edit</button>
              </td>
            `;
            tr.dataset.appId = app.app_id || '';
            tr.dataset.titleEn = app.title_en || '';
            tr.dataset.titleAr = app.title_ar || '';
            tr.dataset.categoryEn = app.category_en || '';
            tr.dataset.categoryAr = app.category_ar || '';
            tr.dataset.description = app.description || '';
            tr.dataset.icon = app.icon || '';
            tr.dataset.runtimeAppId = app.runtime_app_id || '';
            tr.dataset.official = app.official ? 'true' : 'false';
            tr.dataset.enabled = app.enabled ? 'true' : 'false';
            tr.dataset.beta = app.beta ? 'true' : 'false';
            tr.dataset.rating = rating || '';
            tr.dataset.usage = usage || '';
            bodyEl.appendChild(tr);
          }
        } catch (e) {
          bodyEl.innerHTML = '<tr><td colspan="8">Fehler: ' + e + '</td></tr>';
        }
      }

      async function patchMiniApp(appId, patch) {
        const flash = document.getElementById('flash');
        flash.textContent = '';
        try {
          const r = await fetch('/admin/mini_apps/' + encodeURIComponent(appId), {
            method: 'PATCH',
            headers: {'content-type':'application/json'},
            body: JSON.stringify(patch),
          });
          if (!r.ok) {
            const txt = await r.text();
            flash.textContent = 'Fehler: ' + r.status + ' ' + txt;
            flash.className = 'error';
          } else {
            flash.textContent = 'Gespeichert.';
            flash.className = 'success';
            loadMiniApps();
          }
        } catch (e) {
          flash.textContent = 'Fehler: ' + e;
          flash.className = 'error';
        }
      }

      function toggleMiniAppEnabled(appId, enabled) {
        patchMiniApp(appId, {enabled: !!enabled});
      }

      function toggleMiniAppOfficial(appId, official) {
        patchMiniApp(appId, {official: !!official});
      }

      function editMiniApp(appId) {
        const bodyEl = document.getElementById('miniapps-body');
        const rows = bodyEl.querySelectorAll('tr');
        for (const tr of rows) {
          if (!tr.dataset) continue;
          if (tr.dataset.appId === String(appId)) {
            document.getElementById('new_app_id').value = tr.dataset.appId || '';
            document.getElementById('new_title_en').value = tr.dataset.titleEn || '';
            document.getElementById('new_title_ar').value = tr.dataset.titleAr || '';
            document.getElementById('new_category_en').value = tr.dataset.categoryEn || '';
            document.getElementById('new_category_ar').value = tr.dataset.categoryAr || '';
            document.getElementById('new_description').value = tr.dataset.description || '';
            document.getElementById('new_icon').value = tr.dataset.icon || '';
            document.getElementById('new_runtime_app_id').value = tr.dataset.runtimeAppId || '';
            document.getElementById('new_official').checked = (tr.dataset.official === 'true');
            document.getElementById('new_enabled').checked = (tr.dataset.enabled === 'true');
            document.getElementById('new_beta').checked = (tr.dataset.beta === 'true');
            document.getElementById('new_rating').value = tr.dataset.rating || '';
            document.getElementById('new_usage').value = tr.dataset.usage || '';
            break;
          }
        }
      }

      async function createMiniApp() {
        const flash = document.getElementById('flash');
        flash.textContent = '';
        const app_id = document.getElementById('new_app_id').value.trim();
        const title_en = document.getElementById('new_title_en').value.trim();
        const title_ar = document.getElementById('new_title_ar').value.trim();
        const category_en = document.getElementById('new_category_en').value.trim();
        const category_ar = document.getElementById('new_category_ar').value.trim();
        const description = document.getElementById('new_description').value.trim();
        const icon = document.getElementById('new_icon').value.trim();
        const official = document.getElementById('new_official').checked;
        const beta = document.getElementById('new_beta').checked;
        const enabled = document.getElementById('new_enabled').checked;
        const ratingStr = document.getElementById('new_rating').value.trim();
        const usageStr = document.getElementById('new_usage').value.trim();
        const runtimeAppId = document.getElementById('new_runtime_app_id').value.trim();
        if (!app_id || !title_en) {
          flash.textContent = 'App-ID und Titel (EN) sind Pflicht.';
          flash.className = 'error';
          return;
        }
        const payload = {
          app_id,
          title_en,
          title_ar: title_ar || null,
          category_en: category_en || null,
          category_ar: category_ar || null,
          description: description || null,
          icon: icon || null,
          official,
          beta,
          enabled,
          runtime_app_id: runtimeAppId || null,
        };
        if (ratingStr) {
          const v = Number(ratingStr.replace(',', '.'));
          if (!Number.isNaN(v)) {
            payload.rating = v;
          }
        }
        if (usageStr) {
          const v = Number(usageStr);
          if (!Number.isNaN(v)) {
            payload.usage_score = Math.trunc(v);
          }
        }
        try {
          const r = await fetch('/admin/mini_apps', {
            method: 'POST',
            headers: {'content-type':'application/json'},
            body: JSON.stringify(payload),
          });
          if (!r.ok) {
            const txt = await r.text();
            flash.textContent = 'Fehler: ' + r.status + ' ' + txt;
            flash.className = 'error';
          } else {
            flash.textContent = 'Mini-App registriert.';
            flash.className = 'success';
            document.getElementById('new_app_id').value = '';
            document.getElementById('new_title_en').value = '';
            document.getElementById('new_title_ar').value = '';
            document.getElementById('new_category_en').value = '';
            document.getElementById('new_category_ar').value = '';
            document.getElementById('new_description').value = '';
            document.getElementById('new_icon').value = '';
            document.getElementById('new_official').checked = false;
            document.getElementById('new_beta').checked = false;
            document.getElementById('new_enabled').checked = true;
            document.getElementById('new_rating').value = '';
            document.getElementById('new_usage').value = '';
            document.getElementById('new_runtime_app_id').value = '';
            loadMiniApps();
          }
        } catch (e) {
          flash.textContent = 'Fehler: ' + e;
          flash.className = 'error';
        }
      }

      loadMiniApps();
    </script>
  </body>
</html>
"""
    return HTMLResponse(content=html)


@app.get("/admin/miniprograms", response_class=HTMLResponse)
def admin_miniprograms_console(request: Request) -> HTMLResponse:
    """
    Einfache HTML-Konsole für Mini-Programme (Mini-Programs).

    Nutzt die öffentlichen JSON-Endpunkte /mini_programs und
    /mini_programs/{id}, um WeChat-ähnliche Mini-Programs zu
    inspizieren und neue Einträge anzulegen.
    """
    _require_admin_v2(request)
    html = """
<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Shamell · Mini-Programs</title>
    <style>
      body { font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif; margin: 16px; max-width: 960px; color: #0f172a; background:#ffffff; }
      h1 { margin-bottom: 4px; }
      h2 { margin-top: 24px; margin-bottom: 8px; }
      table { border-collapse: collapse; width: 100%; margin-top: 8px; }
      th, td { border: 1px solid #e5e7eb; padding: 6px 8px; font-size: 13px; text-align: left; vertical-align: top; }
      th { background: #f9fafb; font-weight: 600; }
      input, textarea { font-size: 13px; padding: 4px 6px; margin: 2px 0; width: 100%; box-sizing: border-box; }
      textarea { min-height: 64px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
      button { font-size: 13px; padding: 4px 8px; margin: 0 2px; cursor: pointer; }
      .muted { color:#6b7280; font-size:12px; }
      .pill { display:inline-block; padding:2px 6px; border-radius:999px; font-size:11px; }
      .pill-active { background:#dcfce7; color:#15803d; }
      .pill-draft { background:#e5e7eb; color:#374151; }
      .pill-owner { background:#e0f2fe; color:#1d4ed8; }
      .pill-review-draft { background:#f3f4f6; color:#374151; }
      .pill-review-submitted { background:#fffbeb; color:#92400e; }
      .pill-review-approved { background:#dcfce7; color:#166534; }
      .pill-review-rejected { background:#fee2e2; color:#b91c1c; }
      .pill-review-suspended { background:#fef9c3; color:#854d0e; }
      .flex { display:flex; gap:8px; flex-wrap:wrap; }
      .flex > div { flex:1 1 220px; min-width:200px; }
      code { font-size:12px; background:#f3f4f6; padding:2px 4px; border-radius:4px; }
      #flash { margin: 4px 0 8px; }
      #flash.error { color:#b91c1c; }
      #flash.success { color:#166534; }
    </style>
  </head>
  <body>
    <h1>Mini-Programs</h1>
    <p class="muted">
      WeChat-ähnliche Mini-Programme, die in der Shamell-Shell laufen.<br/>
      Diese Konsole zeigt den Katalog aus <code>/mini_programs</code> und erlaubt das Anlegen neuer Einträge.
    </p>
    <p class="muted">
      <a href="/admin/miniapps">Mini-Apps-Konsole</a>
      · <a href="/admin/officials">Official-Accounts-Konsole</a>
      · <a href="/admin/mini_programs/analytics">Mini‑Programs‑Analytics</a>
    </p>

    <div id="flash" class="muted"></div>

    <h2>Registrierte Mini-Programs</h2>
    <table id="programs-table">
      <thead>
        <tr>
          <th>ID</th>
          <th>Title</th>
          <th>Owner</th>
          <th>Status</th>
          <th>Review</th>
          <th>Scopes</th>
          <th>Released</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody id="programs-body">
        <tr><td colspan="7">Lade Daten…</td></tr>
      </tbody>
    </table>

    <h2>Neues Mini-Program registrieren</h2>
    <div class="flex">
      <div>
        <label>App-ID<br/>
          <input id="mp_app_id" placeholder="z.B. taxi_demo" />
        </label>
      </div>
      <div>
        <label>Titel (EN)<br/>
          <input id="mp_title_en" placeholder="Display title (EN)" />
        </label>
      </div>
      <div>
        <label>Titel (AR, optional)<br/>
          <input id="mp_title_ar" placeholder="Display title (AR)" />
        </label>
      </div>
    </div>
    <div class="flex">
      <div>
        <label>Beschreibung (EN, optional)<br/>
          <textarea id="mp_desc_en" placeholder="Kurzbeschreibung (EN)"></textarea>
        </label>
      </div>
      <div>
        <label>Beschreibung (AR, optional)<br/>
          <textarea id="mp_desc_ar" placeholder="Kurzbeschreibung (AR)"></textarea>
        </label>
      </div>
    </div>
    <div class="flex">
      <div>
        <label>Owner-Name (optional)<br/>
          <input id="mp_owner_name" placeholder="z.B. Partner oder Marke" />
        </label>
      </div>
      <div>
        <label>Owner-Kontakt (optional)<br/>
          <input id="mp_owner_contact" placeholder="Kontakt/E-Mail" />
        </label>
      </div>
    </div>
    <div>
      <label>Actions (JSON-Array, optional)<br/>
        <textarea id="mp_actions_json" placeholder='[
  {"id":"open_taxi","label_en":"Open Taxi","label_ar":"فتح التاكسي","kind":"open_mod","mod_id":"taxi_rider"},
  {"id":"close","label_en":"Close","label_ar":"إغلاق","kind":"close"}
]'></textarea>
      </label>
      <p class="muted">
        Felder: <code>id</code>, <code>label_en</code>, <code>label_ar</code>, <code>kind</code> (open_mod | open_url | close),
        optional <code>mod_id</code> bzw. <code>url</code>.
      </p>
    </div>
    <p>
      <button onclick="createMiniProgram()">Mini-Program registrieren</button>
    </p>

    <script>
      async function loadMiniPrograms() {
        const bodyEl = document.getElementById('programs-body');
        const flash = document.getElementById('flash');
        flash.textContent = '';
        try {
          const r = await fetch('/mini_programs');
          if (!r.ok) {
            bodyEl.innerHTML = '<tr><td colspan="7">Fehler beim Laden: ' + r.status + '</td></tr>';
            return;
          }
          const data = await r.json();
          const items = data.programs || [];
          if (!items.length) {
            bodyEl.innerHTML = '<tr><td colspan="7">Noch keine Mini-Programs registriert.</td></tr>';
            return;
          }
          bodyEl.innerHTML = '';
          for (const prog of items) {
            const tr = document.createElement('tr');
            const status = (prog.status || '').toLowerCase();
            const reviewStatus = (prog.review_status || 'draft').toString();
            const scopes = Array.isArray(prog.scopes) ? prog.scopes : [];
            let statusHtml = '';
            if (status === 'active') {
              statusHtml = '<span class="pill pill-active">active</span>';
            } else {
              statusHtml = '<span class="pill pill-draft">' + (status || 'draft') + '</span>';
            }
            let reviewClass = 'pill-review-draft';
            const rs = reviewStatus.toLowerCase();
            if (rs === 'submitted') reviewClass = 'pill-review-submitted';
            else if (rs === 'approved') reviewClass = 'pill-review-approved';
            else if (rs === 'rejected') reviewClass = 'pill-review-rejected';
            else if (rs === 'suspended') reviewClass = 'pill-review-suspended';
            const reviewHtml = '<span class="pill ' + reviewClass + '">' + reviewStatus + '</span>';
            let scopesHtml = '<span class="muted">–</span>';
            if (scopes.length) {
              scopesHtml = scopes.map(s => '<code>' + String(s) + '</code>').join(' ');
            }
            const ownerBits = [];
            if (prog.owner_name) ownerBits.push(prog.owner_name);
            if (prog.owner_contact) ownerBits.push('<span class="muted">' + prog.owner_contact + '</span>');
            const ownerHtml = ownerBits.length
              ? '<span class="pill pill-owner">' + ownerBits.join(' · ') + '</span>'
              : '<span class="muted">–</span>';
            const relVer = prog.released_version || '';
            const relChan = prog.released_channel || '';
            const relHtml = relVer
              ? '<code>' + relVer + '</code>' + (relChan ? ' <span class="muted">(' + relChan + ')</span>' : '')
              : '<span class="muted">–</span>';
            const appIdSafe = prog.app_id || '';
            tr.innerHTML = `
              <td><code>${appIdSafe}</code></td>
              <td>${prog.title_en || ''}<br/><span class="muted">${prog.title_ar || ''}</span></td>
              <td>${ownerHtml}</td>
              <td>${statusHtml}</td>
              <td>${reviewHtml}</td>
              <td>${scopesHtml}</td>
              <td>${relHtml}</td>
              <td>
                <a href="/mini_programs/${encodeURIComponent(appIdSafe)}" target="_blank">JSON</a><br/>
                <button type="button" onclick="updateMiniProgramStatus('${appIdSafe}','active','approved')">Approve &amp; activate</button>
                <button type="button" onclick="updateMiniProgramStatus('${appIdSafe}','disabled','rejected')">Reject</button>
              </td>
            `;
            bodyEl.appendChild(tr);
          }
        } catch (e) {
          bodyEl.innerHTML = '<tr><td colspan="7">Fehler: ' + e + '</td></tr>';
        }
      }

      async function updateMiniProgramStatus(appId, status, reviewStatus) {
        const flash = document.getElementById('flash');
        flash.textContent = '';
        flash.className = 'muted';
        if (!appId) {
          flash.textContent = 'App-ID fehlt.';
          flash.className = 'error';
          return;
        }
        const payload = {};
        if (status) payload.status = status;
        if (reviewStatus) payload.review_status = reviewStatus;
        try {
          const r = await fetch('/admin/mini_programs/' + encodeURIComponent(appId), {
            method: 'PATCH',
            headers: {'content-type':'application/json'},
            body: JSON.stringify(payload),
          });
          if (!r.ok) {
            const txt = await r.text();
            flash.textContent = 'Fehler beim Aktualisieren: ' + r.status + ' ' + txt;
            flash.className = 'error';
          } else {
            flash.textContent = 'Mini-Program aktualisiert.';
            flash.className = 'success';
            loadMiniPrograms();
          }
        } catch (e) {
          flash.textContent = 'Fehler: ' + e;
          flash.className = 'error';
        }
      }

      async function createMiniProgram() {
        const flash = document.getElementById('flash');
        flash.textContent = '';
        flash.className = 'muted';
        const app_id = document.getElementById('mp_app_id').value.trim();
        const title_en = document.getElementById('mp_title_en').value.trim();
        const title_ar = document.getElementById('mp_title_ar').value.trim();
        const desc_en = document.getElementById('mp_desc_en').value.trim();
        const desc_ar = document.getElementById('mp_desc_ar').value.trim();
        const owner_name = document.getElementById('mp_owner_name').value.trim();
        const owner_contact = document.getElementById('mp_owner_contact').value.trim();
        const actionsRaw = document.getElementById('mp_actions_json').value.trim();
        if (!app_id || !title_en) {
          flash.textContent = 'App-ID und Titel (EN) sind Pflicht.';
          flash.className = 'error';
          return;
        }
        const payload = {
          app_id,
          title_en,
          title_ar: title_ar || null,
          description_en: desc_en || null,
          description_ar: desc_ar || null,
          owner_name: owner_name || null,
          owner_contact: owner_contact || null,
        };
        if (actionsRaw) {
          try {
            const parsed = JSON.parse(actionsRaw);
            if (Array.isArray(parsed)) {
              payload.actions = parsed;
            } else {
              flash.textContent = 'Actions JSON muss ein Array sein.';
              flash.className = 'error';
              return;
            }
          } catch (e) {
            flash.textContent = 'Fehler im Actions JSON: ' + e;
            flash.className = 'error';
            return;
          }
        }
        try {
          const r = await fetch('/mini_programs', {
            method: 'POST',
            headers: {'content-type':'application/json'},
            body: JSON.stringify(payload),
          });
          if (!r.ok) {
            const txt = await r.text();
            flash.textContent = 'Fehler: ' + r.status + ' ' + txt;
            flash.className = 'error';
          } else {
            flash.textContent = 'Mini-Program registriert.';
            flash.className = 'success';
            document.getElementById('mp_app_id').value = '';
            document.getElementById('mp_title_en').value = '';
            document.getElementById('mp_title_ar').value = '';
            document.getElementById('mp_desc_en').value = '';
            document.getElementById('mp_desc_ar').value = '';
            document.getElementById('mp_owner_name').value = '';
            document.getElementById('mp_owner_contact').value = '';
            // Actions-Template bewusst nicht leeren, damit es als Vorlage dient.
            loadMiniPrograms();
          }
        } catch (e) {
          flash.textContent = 'Fehler: ' + e;
          flash.className = 'error';
        }
      }

      loadMiniPrograms();
    </script>
  </body>
</html>
"""
    return HTMLResponse(content=html)


@app.get("/admin/mini_programs/analytics", response_class=HTMLResponse)
def admin_miniprograms_analytics(request: Request) -> HTMLResponse:
    """
    Lightweight HTML analytics für Mini-Programs.

    Nutzt usage_score als einfache KPI – ähnlich zu WeChat
    Mini-Program \"popular\" / \"top\" Rankings.
    """
    _require_admin_v2(request)
    try:
        with _officials_session() as s:
            rows = (
                s.execute(
                    _sa_select(MiniProgramDB).order_by(
                        MiniProgramDB.usage_score.desc(), MiniProgramDB.app_id
                    )
                )
                .scalars()
                .all()
            )
        total_usage = 0
        for row in rows:
            try:
                total_usage += int(getattr(row, "usage_score", 0) or 0)
            except Exception:
                continue

        # Best-effort Moments share counts pro Mini-Program für Analytics:
        # lifetime und letzte 30 Tage (WeChat-like "hot last 30 days").
        moments_all: dict[str, int] = {}
        moments_30d: dict[str, int] = {}
        try:
            app_ids = [r.app_id for r in rows if getattr(r, "app_id", None)]
            if app_ids:
                with _moments_session() as ms:
                    since_30d = datetime.now(timezone.utc) - timedelta(days=30)
                    for app_id in app_ids:
                        try:
                            pattern = f"shamell://mini_program/{app_id}"
                            base_stmt = _sa_select(
                                _sa_func.count(MomentPostDB.id)
                            ).where(MomentPostDB.text.contains(pattern))
                            cnt_all = ms.execute(base_stmt).scalar() or 0
                            cnt_30 = (
                                ms.execute(
                                    base_stmt.where(
                                        MomentPostDB.created_at >= since_30d
                                    )
                                ).scalar()
                                or 0
                            )
                            moments_all[str(app_id)] = int(cnt_all or 0)
                            moments_30d[str(app_id)] = int(cnt_30 or 0)
                        except Exception:
                            continue
        except Exception:
            moments_all = {}
            moments_30d = {}

        def esc(s: str) -> str:
            return (
                s.replace("&", "&amp;")
                .replace("<", "&lt;")
                .replace(">", "&gt;")
            )

        rows_html: list[str] = []
        for row in rows:
            app_id = row.app_id
            title_en = row.title_en or ""
            title_ar = row.title_ar or ""
            owner = getattr(row, "owner_name", "") or ""
            status = (row.status or "").strip()
            try:
                usage = int(getattr(row, "usage_score", 0) or 0)
            except Exception:
                usage = 0
            share = 0.0
            if total_usage > 0 and usage > 0:
                try:
                    share = (usage / float(total_usage)) * 100.0
                except Exception:
                    share = 0.0
            try:
                rating_val = float(getattr(row, "rating", 0.0) or 0.0)
            except Exception:
                rating_val = 0.0
            try:
                m_all = int(
                    moments_all.get(app_id, 0)
                    or getattr(row, "moments_shares", 0)
                    or 0
                )
            except Exception:
                m_all = 0
            try:
                m_30 = int(moments_30d.get(app_id, 0) or 0)
            except Exception:
                m_30 = 0
            rows_html.append(
                "<tr>"
                f"<td><code>{esc(app_id)}</code></td>"
                f"<td>{esc(title_en)}<br/><span class=\"meta\">{esc(title_ar)}</span></td>"
                f"<td>{esc(owner)}</td>"
                f"<td>{esc(status)}</td>"
                f"<td>{usage}</td>"
                f"<td>{share:.1f}%</td>"
                f"<td>{rating_val:.1f}</td>"
                f"<td>{m_all}</td>"
                f"<td>{m_30}</td>"
                "</tr>"
            )

        html = f"""
<!doctype html>
<html><head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mini-Programs · Analytics</title>
  <style>
    body{{font-family:sans-serif;margin:20px;max-width:960px;color:#0f172a;}}
    h1{{margin-bottom:4px;}}
    table{{border-collapse:collapse;width:100%;margin-top:12px;}}
    th,td{{padding:6px 8px;border-bottom:1px solid #e5e7eb;font-size:13px;text-align:left;vertical-align:top;}}
    th{{background:#f9fafb;font-weight:600;}}
    .meta{{color:#6b7280;font-size:12px;margin-top:2px;}}
    code{{background:#f3f4f6;padding:2px 4px;border-radius:3px;font-size:12px;}}
  </style>
</head><body>
  <h1>Mini-Programs · Analytics</h1>
  <div class="meta">
    Basierend auf usage_score (Open-Events via /mini_programs/&lt;id&gt;/track_open)
    und Moments-Sharing (Deep-Links auf shamell://mini_program/&lt;id&gt;).<br/>
    Dient als WeChat‑ähnliche Übersicht der beliebtesten und zuletzt in Moments
    geteilten Mini‑Programme.
  </div>
  <p class="meta">
    <a href="/admin/miniprograms">Zurück zur Mini‑Programs-Konsole</a>
    · <a href="/admin/mini_programs/review">Review‑Center</a>
  </p>
  <table>
    <thead>
      <tr>
        <th>App ID</th>
        <th>Title</th>
        <th>Owner</th>
        <th>Status</th>
        <th>Usage score</th>
        <th>Share of usage</th>
        <th>Avg. rating</th>
        <th>Moments shares</th>
        <th>Moments (30d)</th>
      </tr>
    </thead>
    <tbody>
      {''.join(rows_html) if rows_html else '<tr><td colspan="9">No Mini-Programs registered yet.</td></tr>'}
    </tbody>
  </table>
</body></html>
"""
        return HTMLResponse(content=html)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/admin/mini_programs/review", response_class=HTMLResponse)
def admin_miniprograms_review(request: Request) -> HTMLResponse:
    """
    Lightweight Review‑Center für Mini‑Programs – WeChat‑artig.

    Zeigt alle eingereichten Mini‑Programme (review_status=submitted)
    inklusive Owner, Status, Nutzung und Rating, plus schnelle
    Aktionen zum Approven/Rejecten.
    """
    _require_admin_v2(request)
    try:
        with _officials_session() as s:
            rows = (
                s.execute(
                    _sa_select(MiniProgramDB).order_by(
                        MiniProgramDB.review_status.desc(),
                        MiniProgramDB.created_at.desc(),
                        MiniProgramDB.id.desc(),
                    )
                )
                .scalars()
                .all()
            )
        review_rows: list[MiniProgramDB] = []
        other_rows: list[MiniProgramDB] = []
        for prog in rows:
            r_state = (getattr(prog, "review_status", "draft") or "").strip().lower()
            if r_state == "submitted":
                review_rows.append(prog)
            else:
                other_rows.append(prog)

        def esc(s: str) -> str:
            return (
                s.replace("&", "&amp;")
                .replace("<", "&lt;")
                .replace(">", "&gt;")
            )

        def _row_html(prog: MiniProgramDB) -> str:
            app_id = prog.app_id or ""
            title_en = prog.title_en or ""
            title_ar = getattr(prog, "title_ar", "") or ""
            owner_name = getattr(prog, "owner_name", "") or ""
            owner_contact = getattr(prog, "owner_contact", "") or ""
            status = (prog.status or "draft").strip()
            review_status = (getattr(prog, "review_status", "draft") or "").strip()
            try:
                usage = int(getattr(prog, "usage_score", 0) or 0)
            except Exception:
                usage = 0
            try:
                rating_val = float(getattr(prog, "rating", 0.0) or 0.0)
            except Exception:
                rating_val = 0.0
            created = getattr(prog, "created_at", None)
            created_str = ""
            try:
                if isinstance(created, datetime):
                    created_str = created.isoformat().replace("+00:00", "Z")
                elif created is not None:
                    created_str = str(created)
            except Exception:
                created_str = ""
            return (
                "<tr>"
                f"<td><code>{esc(app_id)}</code></td>"
                f"<td>{esc(title_en)}<br/><span class=\"muted\">{esc(title_ar)}</span></td>"
                f"<td>{esc(owner_name)}<br/><span class=\"muted\">{esc(owner_contact)}</span></td>"
                f"<td>{esc(status)}</td>"
                f"<td>{esc(review_status)}</td>"
                f"<td>{usage}</td>"
                f"<td>{rating_val:.1f}</td>"
                f"<td>{esc(created_str)}</td>"
                f"<td>"
                f"<a href=\"/mini_programs/{esc(app_id)}\" target=\"_blank\">JSON</a>"
                "</td>"
                f"<td>"
                f"<button onclick=\"mpReviewApprove('{esc(app_id)}')\">Approve</button><br/>"
                f"<button onclick=\"mpReviewReject('{esc(app_id)}')\">Reject</button><br/>"
                f"<button onclick=\"mpReviewSuspend('{esc(app_id)}')\">Suspend</button>"
                "</td>"
                "</tr>"
            )

        submitted_html = "".join(_row_html(p) for p in review_rows)
        other_html = "".join(_row_html(p) for p in other_rows)

        html = f"""
<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Mini-Programs · Review-Center</title>
    <style>
      body {{ font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif; margin: 16px; max-width: 1080px; color: #0f172a; }}
      h1 {{ margin-bottom: 4px; }}
      h2 {{ margin-top: 24px; margin-bottom: 8px; }}
      table {{ border-collapse: collapse; width: 100%; margin-top: 8px; }}
      th, td {{ border: 1px solid #e5e7eb; padding: 6px 8px; font-size: 13px; text-align: left; vertical-align: top; }}
      th {{ background: #f9fafb; font-weight: 600; }}
      .muted {{ color:#6b7280; font-size:12px; }}
      #flash {{ margin: 4px 0 8px; }}
      #flash.error {{ color:#b91c1c; }}
      #flash.success {{ color:#166534; }}
      button {{ font-size: 12px; padding: 2px 6px; margin: 1px 0; }}
    </style>
  </head>
  <body>
    <h1>Mini-Programs · Review-Center</h1>
    <p class="muted">
      WeChat‑ähnliche Review‑Übersicht: fokussiert auf eingereichte Mini‑Programs
      (<code>review_status = submitted</code>) mit schnellen Aktionen zum Approven/Rejekten.
    </p>
    <p class="muted">
      <a href="/admin/miniprograms">Mini‑Programs-Konsole</a>
      · <a href="/admin/mini_programs/analytics">Analytics</a>
    </p>
    <div id="flash" class="muted"></div>

    <h2>Eingereichte Mini-Programs (Review-Queue)</h2>
    <table>
      <thead>
        <tr>
          <th>App ID</th>
          <th>Title</th>
          <th>Owner</th>
          <th>Status</th>
          <th>Review</th>
          <th>Usage</th>
          <th>Rating</th>
          <th>Created</th>
          <th>Links</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody>
        {submitted_html or '<tr><td colspan="10">Keine eingereichten Mini‑Programs.</td></tr>'}
      </tbody>
    </table>

    <h2>Weitere Mini-Programs</h2>
    <table>
      <thead>
        <tr>
          <th>App ID</th>
          <th>Title</th>
          <th>Owner</th>
          <th>Status</th>
          <th>Review</th>
          <th>Usage</th>
          <th>Rating</th>
          <th>Created</th>
          <th>Links</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody>
        {other_html or '<tr><td colspan="10">Keine weiteren Mini‑Programs.</td></tr>'}
      </tbody>
    </table>

    <script>
      async function mpReviewUpdate(appId, status, reviewStatus) {{
        const flash = document.getElementById('flash');
        flash.textContent = '';
        flash.className = 'muted';
        if (!appId) {{
          flash.textContent = 'App-ID fehlt.';
          flash.className = 'error';
          return;
        }}
        const payload = {{}};
        if (status) payload.status = status;
        if (reviewStatus) payload.review_status = reviewStatus;
        try {{
          const r = await fetch('/admin/mini_programs/' + encodeURIComponent(appId), {{
            method: 'PATCH',
            headers: {{'content-type':'application/json'}},
            body: JSON.stringify(payload),
          }});
          if (!r.ok) {{
            const txt = await r.text();
            flash.textContent = 'Fehler beim Aktualisieren: ' + r.status + ' ' + txt;
            flash.className = 'error';
          }} else {{
            flash.textContent = 'Review-Status aktualisiert.';
            flash.className = 'success';
            window.location.reload();
          }}
        }} catch (e) {{
          flash.textContent = 'Fehler: ' + e;
          flash.className = 'error';
        }}
      }}

      function mpReviewApprove(appId) {{
        mpReviewUpdate(appId, 'active', 'approved');
      }}
      function mpReviewReject(appId) {{
        mpReviewUpdate(appId, 'disabled', 'rejected');
      }}
      function mpReviewSuspend(appId) {{
        mpReviewUpdate(appId, 'disabled', 'suspended');
      }}
    </script>
  </body>
</html>
"""
        return HTMLResponse(content=html)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.patch("/admin/mini_programs/{app_id}", response_class=JSONResponse)
def admin_mini_program_update(
    app_id: str, request: Request, body: dict[str, Any]
) -> dict[str, Any]:
    """
    Admin‑Endpoint zum Aktualisieren einzelner Mini‑Program‑Felder.

    Unterstützt u.a. Status (draft/active/disabled), review_status
    (draft/submitted/approved/rejected/suspended) und scopes.
    """
    _require_admin_v2(request)
    if not isinstance(body, dict):
        raise HTTPException(status_code=400, detail="body must be object")
    app_id_clean = (app_id or "").strip()
    if not app_id_clean:
        raise HTTPException(status_code=400, detail="app_id required")
    allowed_status = {"draft", "active", "disabled"}
    allowed_review = {"draft", "submitted", "approved", "rejected", "suspended"}
    raw_status = body.get("status")
    raw_review = body.get("review_status")
    if raw_status is not None:
        status_val = str(raw_status).strip().lower()
        if status_val not in allowed_status:
            raise HTTPException(status_code=400, detail="invalid status")
    else:
        status_val = None
    if raw_review is not None:
        review_val = str(raw_review).strip().lower()
        if review_val not in allowed_review:
            raise HTTPException(status_code=400, detail="invalid review_status")
    else:
        review_val = None
    scopes_val = None
    if "scopes" in body:
        raw_scopes = body.get("scopes")
        if raw_scopes is None:
            scopes_val = None
        elif isinstance(raw_scopes, list):
            scopes_val = [str(s).strip() for s in raw_scopes if str(s).strip()]
        else:
            raise HTTPException(status_code=400, detail="scopes must be list of strings or null")
    try:
        with _officials_session() as s:
            prog = (
                s.execute(
                    _sa_select(MiniProgramDB).where(
                        MiniProgramDB.app_id == app_id_clean
                    )
                )
                .scalars()
                .first()
            )
            if not prog:
                raise HTTPException(status_code=404, detail="mini-program not found")
            if status_val is not None:
                prog.status = status_val
            if review_val is not None:
                prog.review_status = review_val
            if scopes_val is not None:
                if scopes_val:
                    try:
                        prog.scopes_json = _json.dumps(scopes_val)
                    except Exception:
                        prog.scopes_json = None
                else:
                    prog.scopes_json = None
            s.add(prog)
            s.commit()
            s.refresh(prog)
            scopes_list: list[str] = []
            try:
                raw_scopes = getattr(prog, "scopes_json", None)
                if raw_scopes:
                    val = _json.loads(raw_scopes)
                    if isinstance(val, list):
                        scopes_list = [
                            str(s).strip() for s in val if str(s).strip()
                        ]
            except Exception:
                scopes_list = []
            return {
                "app_id": prog.app_id,
                "status": prog.status,
                "review_status": getattr(prog, "review_status", "draft"),
                "scopes": scopes_list,
            }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/admin/officials/analytics", response_class=HTMLResponse)
def admin_officials_analytics(request: Request) -> HTMLResponse:
    """
    Lightweight HTML analytics for Official accounts.

    Shows follower counts, notification mode breakdown, feed items
    and Moments shares per account – WeChat-style merchant overview.
    """
    _require_admin_v2(request)
    try:
        # Aggregate per-account metrics from Official DB
        with _officials_session() as s:
            accounts = (
                s.execute(
                    _sa_select(OfficialAccountDB).order_by(OfficialAccountDB.id)
                )
                .scalars()
                .all()
            )
            follower_counts: dict[str, int] = {}
            notif_summary: dict[str, int] = {}
            notif_muted: dict[str, int] = {}
            feed_counts: dict[str, int] = {}
            feed_last_ts: dict[str, str] = {}

            rows = (
                s.execute(
                    _sa_select(
                        OfficialFollowDB.account_id,
                        _sa_func.count(OfficialFollowDB.id),
                    ).group_by(OfficialFollowDB.account_id)
                )
                .all()
            )
            for acc_id, cnt in rows:
                follower_counts[str(acc_id)] = int(cnt or 0)

            notif_rows = (
                s.execute(
                    _sa_select(
                        OfficialNotificationDB.account_id,
                        OfficialNotificationDB.mode,
                        _sa_func.count(OfficialNotificationDB.id),
                    ).group_by(
                        OfficialNotificationDB.account_id,
                        OfficialNotificationDB.mode,
                    )
                )
                .all()
            )
            for acc_id, mode, cnt in notif_rows:
                aid = str(acc_id)
                m = (mode or "").strip().lower()
                if m == "summary":
                    notif_summary[aid] = notif_summary.get(aid, 0) + int(cnt or 0)
                elif m == "muted":
                    notif_muted[aid] = notif_muted.get(aid, 0) + int(cnt or 0)

            feed_rows = (
                s.execute(
                    _sa_select(
                        OfficialFeedItemDB.account_id,
                        _sa_func.count(OfficialFeedItemDB.id),
                        _sa_func.max(OfficialFeedItemDB.ts),
                    ).group_by(OfficialFeedItemDB.account_id)
                )
                .all()
            )
            for acc_id, cnt, ts in feed_rows:
                aid = str(acc_id)
                feed_counts[aid] = int(cnt or 0)
                if ts is not None:
                    try:
                        ts_str = ts.isoformat().replace("+00:00", "Z")
                    except Exception:
                        ts_str = str(ts)
                    feed_last_ts[aid] = ts_str

        # Aggregate Moments shares per Official account (origin_official_account_id)
        moments_shares: dict[str, int] = {}
        moments_shares_30d: dict[str, int] = {}
        moments_unique_sharers: dict[str, int] = {}
        moments_unique_sharers_30d: dict[str, int] = {}
        moments_redpacket_shares: dict[str, int] = {}
        moments_redpacket_shares_30d: dict[str, int] = {}
        try:
            with _moments_session() as ms:
                since_30d = datetime.now(timezone.utc) - timedelta(days=30)

                base_stmt = _sa_select(
                    MomentPostDB.origin_official_account_id,
                    _sa_func.count(MomentPostDB.id),
                ).where(MomentPostDB.origin_official_account_id.is_not(None))

                # All Moments shares per official
                m_rows = ms.execute(
                    base_stmt.group_by(MomentPostDB.origin_official_account_id)
                ).all()
                for acc_id, cnt in m_rows:
                    if not acc_id:
                        continue
                    moments_shares[str(acc_id)] = int(cnt or 0)

                # Last 30 days Moments shares per official
                recent_rows = ms.execute(
                    base_stmt.where(MomentPostDB.created_at >= since_30d).group_by(
                        MomentPostDB.origin_official_account_id
                    )
                ).all()
                for acc_id, cnt in recent_rows:
                    if not acc_id:
                        continue
                    moments_shares_30d[str(acc_id)] = int(cnt or 0)

                # Unique sharers (distinct users who shared this official) – all time
                uniq_stmt = _sa_select(
                    MomentPostDB.origin_official_account_id,
                    _sa_func.count(_sa_func.distinct(MomentPostDB.user_key)),
                ).where(MomentPostDB.origin_official_account_id.is_not(None))
                uniq_rows = ms.execute(
                    uniq_stmt.group_by(MomentPostDB.origin_official_account_id)
                ).all()
                for acc_id, cnt in uniq_rows:
                    if not acc_id:
                        continue
                    moments_unique_sharers[str(acc_id)] = int(cnt or 0)

                # Unique sharers in the last 30 days
                uniq_recent_rows = ms.execute(
                    uniq_stmt.where(MomentPostDB.created_at >= since_30d).group_by(
                        MomentPostDB.origin_official_account_id
                    )
                ).all()
                for acc_id, cnt in uniq_recent_rows:
                    if not acc_id:
                        continue
                    moments_unique_sharers_30d[str(acc_id)] = int(cnt or 0)

                # Red-packet related Moments shares per official (same heuristics as Moments analytics)
                def _add_redpacket_rows(stmt, target: dict[str, int]):
                    rows = ms.execute(stmt).all()
                    for acc_id, cnt in rows:
                        if not acc_id:
                            continue
                        key = str(acc_id)
                        target[key] = target.get(key, 0) + int(cnt or 0)

                rp_stmt = base_stmt.group_by(MomentPostDB.origin_official_account_id)
                _add_redpacket_rows(
                    rp_stmt.where(MomentPostDB.text.contains("Red packet")),
                    moments_redpacket_shares,
                )
                _add_redpacket_rows(
                    rp_stmt.where(
                        MomentPostDB.text.contains(
                            "I am sending red packets via Shamell Pay"
                        )
                    ),
                    moments_redpacket_shares,
                )
                _add_redpacket_rows(
                    rp_stmt.where(MomentPostDB.text.contains("حزمة حمراء")),
                    moments_redpacket_shares,
                )

                # Red-packet related Moments shares in the last 30 days
                rp_30_stmt = rp_stmt.where(MomentPostDB.created_at >= since_30d)
                _add_redpacket_rows(
                    rp_30_stmt.where(MomentPostDB.text.contains("Red packet")),
                    moments_redpacket_shares_30d,
                )
                _add_redpacket_rows(
                    rp_30_stmt.where(
                        MomentPostDB.text.contains(
                            "I am sending red packets via Shamell Pay"
                        )
                    ),
                    moments_redpacket_shares_30d,
                )
                _add_redpacket_rows(
                    rp_30_stmt.where(MomentPostDB.text.contains("حزمة حمراء")),
                    moments_redpacket_shares_30d,
                )
        except Exception:
            moments_shares = {}
            moments_shares_30d = {}
            moments_unique_sharers = {}
            moments_unique_sharers_30d = {}
            moments_redpacket_shares = {}
            moments_redpacket_shares_30d = {}

        def esc(s: str) -> str:
            return (
                s.replace("&", "&amp;")
                .replace("<", "&lt;")
                .replace(">", "&gt;")
            )

        rows_html: list[str] = []
        total_followers = 0
        for acc in accounts:
            acc_id = acc.id
            followers = follower_counts.get(acc_id, 0)
            total_followers += followers
            feed_count = feed_counts.get(acc_id, 0)
            last_ts = feed_last_ts.get(acc_id, "")
            share_count = moments_shares.get(acc_id, 0)
            share_30 = moments_shares_30d.get(acc_id, 0)
            # Unique sharers (all time / 30d) for this Official
            uniq_sharers = moments_unique_sharers.get(acc_id, 0)
            uniq_sharers_30 = moments_unique_sharers_30d.get(acc_id, 0)
            rp_share_count = moments_redpacket_shares.get(acc_id, 0)
            rp_share_30 = moments_redpacket_shares_30d.get(acc_id, 0)
            summary_cnt = notif_summary.get(acc_id, 0)
            muted_cnt = notif_muted.get(acc_id, 0)
            shares_per_1k = 0.0
            redpacket_share_ratio_30 = 0.0
            try:
                if followers > 0 and share_count > 0:
                    shares_per_1k = (share_count / float(followers)) * 1000.0
                if share_30 > 0 and rp_share_30 > 0:
                    redpacket_share_ratio_30 = (rp_share_30 / float(share_30)) * 100.0
            except Exception:
                shares_per_1k = 0.0
                redpacket_share_ratio_30 = 0.0
            if share_30 > 0:
                share_30_cell = (
                    f'<a href="/moments/admin/comments/html?official_account_id={esc(acc_id)}">{share_30}</a>'
                )
            else:
                share_30_cell = str(share_30)
            comments_link = (
                f'<a href="/moments/admin/comments/html?official_account_id={esc(acc_id)}">View</a>'
            )
            rows_html.append(
                "<tr>"
                f"<td><code>{esc(acc_id)}</code></td>"
                f"<td>{esc(acc.name or '')}</td>"
                f"<td>{esc(acc.kind or '')}</td>"
                f"<td>{followers}</td>"
                f"<td>{feed_count}</td>"
                f"<td>{esc(last_ts)}</td>"
                f"<td>{share_count}</td>"
                f"<td>{rp_share_count}</td>"
                f"<td>{share_30_cell}</td>"
                f"<td>{rp_share_30}</td>"
                f"<td>{uniq_sharers}</td>"
                f"<td>{uniq_sharers_30}</td>"
                f"<td>{shares_per_1k:.1f}</td>"
                f"<td>{redpacket_share_ratio_30:.1f}%</td>"
                f"<td>{comments_link}</td>"
                f"<td>{summary_cnt}</td>"
                f"<td>{muted_cnt}</td>"
                "</tr>"
            )

        html = f"""
<!doctype html>
<html><head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Official Accounts · Analytics</title>
  <style>
    body{{font-family:sans-serif;margin:20px;max-width:1100px;color:#0f172a;}}
    h1{{margin-bottom:4px;}}
    table{{border-collapse:collapse;width:100%;margin-top:12px;}}
    th,td{{padding:6px 8px;border-bottom:1px solid #e5e7eb;font-size:13px;text-align:left;vertical-align:top;}}
    th{{background:#f9fafb;font-weight:600;}}
    .meta{{color:#6b7280;font-size:12px;margin-top:4px;}}
    code{{background:#f3f4f6;padding:2px 4px;border-radius:3px;font-size:12px;}}
  </style>
</head><body>
  <h1>Official Accounts · Analytics</h1>
  <div class="meta">
    Followers total: {total_followers} · Accounts: {len(accounts)}.
    Data based on Official DB and Moments shares (incl. red-packet mentions); event hooks (follow/feed) go to Redis/logs.
  </div>
  <div class="meta">
    Unique sharers = distinct users who shared this account in Moments (all time / last 30 days). Shares / 1k followers = Moments shares per 1,000 followers (engagement intensity, normalised for follower size).
  </div>
  <p class="meta">
    <a href="/admin/officials">Zurück zur Official-Admin-Konsole</a>
  </p>
  <table>
    <thead>
      <tr>
        <th>ID</th>
        <th>Name</th>
        <th>Kind</th>
        <th>Followers</th>
        <th>Feed items</th>
        <th>Last feed TS</th>
        <th>Moments shares</th>
        <th>Red-packet shares</th>
        <th>Moments (30d)</th>
        <th>Red-packet (30d)</th>
        <th>Unique sharers</th>
        <th>Unique sharers (30d)</th>
        <th>Shares / 1k followers</th>
        <th>Red-packet share rate (30d)</th>
        <th>Moments comments (QA)</th>
        <th>Notif summary</th>
        <th>Notif muted</th>
      </tr>
    </thead>
    <tbody>
      {''.join(rows_html) if rows_html else '<tr><td colspan="17">No Official accounts configured.</td></tr>'}
    </tbody>
  </table>
</body></html>
"""
        return HTMLResponse(content=html)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/admin/channels/analytics", response_class=HTMLResponse)
def admin_channels_analytics(request: Request) -> HTMLResponse:
    """
    Lightweight HTML-Analytics für Channels – WeChat-ähnlicher Überblick.

    Aggregiert pro Official-Account:
      - Anzahl Clips
      - Gesamt-Views, Likes, Comments
      - Einfacher Engagement-Score und "Hot in Moments"-Flag (basierend auf
        der gleichen Heuristik wie /channels/feed).
    """
    _require_admin_v2(request)
    try:
        with _officials_session() as s:
            rows = (
                s.execute(
                    _sa_select(
                        OfficialFeedItemDB.id,
                        OfficialFeedItemDB.account_id,
                        OfficialFeedItemDB.type,
                        OfficialAccountDB.name,
                        OfficialAccountDB.city,
                        OfficialAccountDB.category,
                    )
                    .join(
                        OfficialAccountDB,
                        OfficialFeedItemDB.account_id == OfficialAccountDB.id,
                    )
                )
                .all()
            )
            if not rows:
                html_empty = """
<!doctype html>
<html><head>
  <meta charset="utf-8" />
  <title>Channels · Analytics</title>
  <style>
    body{font-family:sans-serif;margin:20px;max-width:960px;color:#0f172a;}
  </style>
</head><body>
  <h1>Channels · Analytics</h1>
  <p>No Channels clips found.</p>
</body></html>
"""
                return HTMLResponse(content=html_empty)

            item_ids: list[str] = []
            acc_ids: set[str] = set()
            for fid, acc_id, ftype, name, city, category in rows:
                try:
                    item_ids.append(str(fid))
                except Exception:
                    continue
                if acc_id is not None:
                    acc_ids.add(str(acc_id))

            likes_map: dict[str, int] = {}
            views_map: dict[str, int] = {}
            comments_map: dict[str, int] = {}

            if item_ids:
                try:
                    like_rows = (
                        s.execute(
                            _sa_select(
                                ChannelLikeDB.item_id,
                                _sa_func.count(ChannelLikeDB.id),
                            )
                            .where(ChannelLikeDB.item_id.in_(item_ids))
                            .group_by(ChannelLikeDB.item_id)
                        )
                        .all()
                    )
                    for iid, cnt in like_rows:
                        try:
                            likes_map[str(iid)] = int(cnt or 0)
                        except Exception:
                            continue
                except Exception:
                    likes_map = {}
                try:
                    view_rows = (
                        s.execute(
                            _sa_select(
                                ChannelViewDB.item_id,
                                ChannelViewDB.views,
                            ).where(ChannelViewDB.item_id.in_(item_ids))
                        )
                        .all()
                    )
                    for iid, views in view_rows:
                        try:
                            views_map[str(iid)] = int(views or 0)
                        except Exception:
                            continue
                except Exception:
                    views_map = {}
                try:
                    comment_rows = (
                        s.execute(
                            _sa_select(
                                ChannelCommentDB.item_id,
                                _sa_func.count(ChannelCommentDB.id),
                            )
                            .where(ChannelCommentDB.item_id.in_(item_ids))
                            .group_by(ChannelCommentDB.item_id)
                        )
                        .all()
                    )
                    for iid, cnt in comment_rows:
                        try:
                            comments_map[str(iid)] = int(cnt or 0)
                        except Exception:
                            continue
                except Exception:
                    comments_map = {}

            hot_accounts: set[str] = set()
            try:
                if acc_ids:
                    with _moments_session() as ms:
                        agg_rows = (
                            ms.execute(
                                _sa_select(
                                    MomentPostDB.origin_official_account_id,
                                    _sa_func.count(MomentPostDB.id),
                                )
                                .where(
                                    MomentPostDB.origin_official_account_id.in_(
                                        list(acc_ids)
                                    )
                                )
                                .group_by(MomentPostDB.origin_official_account_id)
                            )
                            .all()
                        )
                        for acc_id, cnt in agg_rows:
                            try:
                                if int(cnt or 0) >= 10:
                                    hot_accounts.add(str(acc_id))
                            except Exception:
                                continue
            except Exception:
                hot_accounts = set()

            per_acc: dict[str, dict[str, Any]] = {}
            for fid, acc_id, ftype, name, city, category in rows:
                acc_key = str(acc_id) if acc_id is not None else ""
                if not acc_key:
                    continue
                acc = per_acc.setdefault(
                    acc_key,
                    {
                        "id": acc_key,
                        "name": name or "",
                        "city": city or "",
                        "category": category or "",
                        "clips": 0,
                        "views": 0,
                        "likes": 0,
                        "comments": 0,
                        "campaign_clips": 0,
                        "hot_in_moments": acc_key in hot_accounts,
                    },
                )
                acc["clips"] += 1
                item_id = str(fid)
                acc["views"] += views_map.get(item_id, 0)
                acc["likes"] += likes_map.get(item_id, 0)
                acc["comments"] += comments_map.get(item_id, 0)
                f_type = (ftype or "").strip().lower()
                if f_type in {"campaign", "promo"}:
                    acc["campaign_clips"] += 1

        rows_list: list[dict[str, Any]] = list(per_acc.values())
        for acc in rows_list:
            try:
                clips = int(acc.get("clips", 0) or 0)
                views = int(acc.get("views", 0) or 0)
                likes = int(acc.get("likes", 0) or 0)
                comments = int(acc.get("comments", 0) or 0)
            except Exception:
                clips = views = likes = comments = 0
            score = 0.0
            if clips > 0:
                try:
                    score = (views / max(clips, 1)) * 0.1 + (likes * 0.5) + (comments * 1.0)
                except Exception:
                    score = 0.0
            if acc.get("hot_in_moments"):
                score += 5.0
            acc["score"] = score

        rows_list.sort(key=lambda x: float(x.get("score") or 0.0), reverse=True)

        def esc(s: str) -> str:
            return (
                s.replace("&", "&amp;")
                .replace("<", "&lt;")
                .replace(">", "&gt;")
            )

        rows_html: list[str] = []
        for acc in rows_list:
            aid = str(acc.get("id", ""))
            name = str(acc.get("name", ""))
            city = str(acc.get("city", ""))
            category = str(acc.get("category", ""))
            clips = int(acc.get("clips", 0) or 0)
            views = int(acc.get("views", 0) or 0)
            likes = int(acc.get("likes", 0) or 0)
            comments = int(acc.get("comments", 0) or 0)
            campaigns = int(acc.get("campaign_clips", 0) or 0)
            score = float(acc.get("score", 0.0) or 0.0)
            hot = bool(acc.get("hot_in_moments", False))
            rows_html.append(
                "<tr>"
                f"<td><code>{esc(aid)}</code></td>"
                f"<td>{esc(name)}</td>"
                f"<td>{esc(city)}</td>"
                f"<td>{esc(category)}</td>"
                f"<td>{clips}</td>"
                f"<td>{campaigns}</td>"
                f"<td>{views}</td>"
                f"<td>{likes}</td>"
                f"<td>{comments}</td>"
                f"<td>{score:.1f}</td>"
                f"<td>{'✅' if hot else ''}</td>"
                "</tr>"
            )

        html = f"""
<!doctype html>
<html><head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Channels · Analytics</title>
  <style>
    body{{font-family:sans-serif;margin:20px;max-width:1080px;color:#0f172a;}}
    h1{{margin-bottom:4px;}}
    table{{border-collapse:collapse;width:100%;margin-top:12px;}}
    th,td{{padding:6px 8px;border-bottom:1px solid #e5e7eb;font-size:13px;text-align:left;vertical-align:top;}}
    th{{background:#f9fafb;font-weight:600;}}
    .meta{{color:#6b7280;font-size:12px;margin-top:2px;}}
    code{{background:#f3f4f6;padding:2px 4px;border-radius:3px;font-size:12px;}}
  </style>
</head><body>
  <h1>Channels · Analytics</h1>
  <div class="meta">
    Per-Account-Übersicht der Channels-Performance (Clips, Views, Likes, Comments) mit
    einfachem Engagement-Score und einem "Hot in Moments"-Flag – angelehnt an WeChat Channels.
  </div>
  <p class="meta">
    <a href="/admin/officials/analytics">Zurück zu Official-Analytics</a>
  </p>
  <table>
    <thead>
      <tr>
        <th>Account ID</th>
        <th>Name</th>
        <th>City</th>
        <th>Category</th>
        <th>Clips</th>
        <th>Campaigns</th>
        <th>Views</th>
        <th>Likes</th>
        <th>Comments</th>
        <th>Engagement score</th>
        <th>Hot in Moments</th>
      </tr>
    </thead>
    <tbody>
      {''.join(rows_html) if rows_html else '<tr><td colspan="11">No data.</td></tr>'}
    </tbody>
  </table>
</body></html>
"""
        return HTMLResponse(content=html)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/admin/redpacket_campaigns/analytics", response_class=HTMLResponse)
def admin_redpacket_campaigns_analytics(request: Request) -> HTMLResponse:
    """
    Lightweight HTML analytics for Red‑Packet campaigns.

    Aggregates Moments shares per campaign (based on origin_official_item_id)
    to provide WeChat‑ähnliche KPIs pro Kampagne.
    """
    _require_admin_v2(request)
    try:
        with _officials_session() as s:
            campaigns = (
                s.execute(
                    _sa_select(RedPacketCampaignDB).order_by(
                        RedPacketCampaignDB.created_at.desc()
                    )
                )
                .scalars()
                .all()
            )
            accounts_by_id: dict[str, OfficialAccountDB] = {}
            if campaigns:
                acc_ids = {c.account_id for c in campaigns}
                acc_rows = (
                    s.execute(
                        _sa_select(OfficialAccountDB).where(
                            OfficialAccountDB.id.in_(list(acc_ids))
                        )
                    )
                    .scalars()
                    .all()
                )
                for acc in acc_rows:
                    accounts_by_id[acc.id] = acc

        # Aggregate Moments metrics per campaign (keyed by origin_official_item_id)
        moments_total: dict[str, int] = {}
        moments_30d: dict[str, int] = {}
        uniq_total: dict[str, int] = {}
        uniq_30d: dict[str, int] = {}
        last_ts: dict[str, str] = {}
        try:
            with _moments_session() as ms:
                since_30d = datetime.now(timezone.utc) - timedelta(days=30)
                base_stmt = _sa_select(
                    MomentPostDB.origin_official_item_id,
                    _sa_func.count(MomentPostDB.id),
                ).where(MomentPostDB.origin_official_item_id.is_not(None))
                # All-time totals
                rows = ms.execute(
                    base_stmt.group_by(MomentPostDB.origin_official_item_id)
                ).all()
                for cid, cnt in rows:
                    if not cid:
                        continue
                    moments_total[str(cid)] = int(cnt or 0)
                # Last 30 days totals
                rows_30 = ms.execute(
                    base_stmt.where(MomentPostDB.created_at >= since_30d).group_by(
                        MomentPostDB.origin_official_item_id
                    )
                ).all()
                for cid, cnt in rows_30:
                    if not cid:
                        continue
                    moments_30d[str(cid)] = int(cnt or 0)
                # Unique sharers (all time)
                uniq_stmt = _sa_select(
                    MomentPostDB.origin_official_item_id,
                    _sa_func.count(_sa_func.distinct(MomentPostDB.user_key)),
                ).where(MomentPostDB.origin_official_item_id.is_not(None))
                u_rows = ms.execute(
                    uniq_stmt.group_by(MomentPostDB.origin_official_item_id)
                ).all()
                for cid, cnt in u_rows:
                    if not cid:
                        continue
                    uniq_total[str(cid)] = int(cnt or 0)
                # Unique sharers (30d)
                u_rows_30 = ms.execute(
                    uniq_stmt.where(MomentPostDB.created_at >= since_30d).group_by(
                        MomentPostDB.origin_official_item_id
                    )
                ).all()
                for cid, cnt in u_rows_30:
                    if not cid:
                        continue
                    uniq_30d[str(cid)] = int(cnt or 0)
                # Last post timestamp per campaign
                ts_rows = ms.execute(
                    _sa_select(
                        MomentPostDB.origin_official_item_id,
                        _sa_func.max(MomentPostDB.created_at),
                    )
                    .where(MomentPostDB.origin_official_item_id.is_not(None))
                    .group_by(MomentPostDB.origin_official_item_id)
                ).all()
                for cid, ts in ts_rows:
                    if not cid or ts is None:
                        continue
                    try:
                        ts_str = ts.isoformat().replace("+00:00", "Z")
                    except Exception:
                        ts_str = str(ts)
                    last_ts[str(cid)] = ts_str
        except Exception:
            moments_total = {}
            moments_30d = {}
            uniq_total = {}
            uniq_30d = {}
            last_ts = {}

        # Optional Payments KPIs per campaign (best-effort via PAYMENTS_BASE)
        payments_stats: dict[str, dict[str, Any]] = {}
        try:
            if PAYMENTS_BASE and campaigns:
                base = PAYMENTS_BASE.rstrip("/")
                for camp in campaigns:
                    cid = camp.id
                    try:
                        url = f"{base}/admin/redpacket_campaigns/payments_analytics"
                        r = httpx.get(
                            url,
                            headers=_payments_headers(),
                            params={"campaign_id": cid},
                            timeout=5.0,
                        )
                        if (
                            r.status_code == 200
                            and r.headers.get("content-type", "").startswith("application/json")
                        ):
                            data = r.json()
                            if isinstance(data, dict):
                                payments_stats[cid] = data
                    except Exception:
                        # Soft-fail; payments KPIs are optional
                        continue
        except Exception:
            payments_stats = {}

        def esc(s: str) -> str:
            return (
                s.replace("&", "&amp;")
                .replace("<", "&lt;")
                .replace(">", "&gt;")
            )

        rows_html: list[str] = []
        for camp in campaigns:
            cid = camp.id
            acc = accounts_by_id.get(camp.account_id)
            cname = camp.title or ""
            aname = acc.name if acc else camp.account_id
            kind = acc.kind if acc else ""
            total = moments_total.get(cid, 0)
            total_30 = moments_30d.get(cid, 0)
            utotal = uniq_total.get(cid, 0)
            u30 = uniq_30d.get(cid, 0)
            ts_str = last_ts.get(cid, "")
            status = "active" if getattr(camp, "active", True) else "inactive"
            ps = payments_stats.get(cid) or {}
            try:
                issued = int(ps.get("total_packets_issued", 0) or 0)
            except Exception:
                issued = 0
            try:
                claimed = int(ps.get("total_packets_claimed", 0) or 0)
            except Exception:
                claimed = 0
            try:
                amt_total = int(ps.get("total_amount_cents", 0) or 0)
            except Exception:
                amt_total = 0
            try:
                amt_claimed = int(ps.get("claimed_amount_cents", 0) or 0)
            except Exception:
                amt_claimed = 0
            try:
                def_amt = int(getattr(camp, "default_amount_cents", 0) or 0)
            except Exception:
                def_amt = 0
            try:
                def_count = int(getattr(camp, "default_count", 0) or 0)
            except Exception:
                def_count = 0
            rows_html.append(
                "<tr>"
                f"<td><a href=\"/admin/redpacket_campaigns/detail?campaign_id={esc(cid)}\"><code>{esc(cid)}</code></a></td>"
                f"<td>{esc(cname)}</td>"
                f"<td>{esc(aname or '')}</td>"
                f"<td>{esc(kind or '')}</td>"
                f"<td>{status}</td>"
                f"<td>{total}</td>"
                f"<td>{total_30}</td>"
                f"<td>{utotal}</td>"
                f"<td>{u30}</td>"
                f"<td><span class=\"meta\">{esc(ts_str)}</span></td>"
                f"<td>{issued}</td>"
                f"<td>{claimed}</td>"
                f"<td>{amt_total}</td>"
                f"<td>{amt_claimed}</td>"
                f"<td>{def_amt if def_amt > 0 else ''}</td>"
                f"<td>{def_count if def_count > 0 else ''}</td>"
                "</tr>"
            )

        html = f"""
<!doctype html>
<html><head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Red‑Packet Campaigns · Analytics</title>
  <style>
    body{{font-family:sans-serif;margin:20px;max-width:1100px;color:#0f172a;}}
    h1{{margin-bottom:4px;}}
    table{{border-collapse:collapse;width:100%;margin-top:12px;}}
    th,td{{padding:6px 8px;border-bottom:1px solid #e5e7eb;font-size:13px;text-align:left;vertical-align:top;}}
    th{{background:#f9fafb;font-weight:600;}}
    .meta{{color:#6b7280;font-size:12px;margin-top:2px;}}
    code{{background:#f3f4f6;padding:2px 4px;border-radius:3px;font-size:12px;}}
  </style>
</head><body>
  <h1>Red‑Packet Campaigns · Analytics</h1>
  <div class="meta">
    Based on Moments posts tagged with shamell://official/&lt;account&gt;/&lt;campaign_id&gt;
    (origin_official_item_id = campaign_id). Best-effort, WeChat‑ähnliche Kampagnen-Sicht.
  </div>
  <p class="meta">
    <a href="/admin/officials">Zurück zur Official-Admin-Konsole</a>
  </p>
  <table>
    <thead>
      <tr>
        <th>Campaign ID</th>
        <th>Title</th>
        <th>Account</th>
        <th>Kind</th>
        <th>Status</th>
        <th>Moments shares</th>
        <th>Moments (30d)</th>
        <th>Unique sharers</th>
        <th>Unique sharers (30d)</th>
        <th>Last share TS</th>
        <th>Packets issued</th>
        <th>Packets claimed</th>
        <th>Amount (total cents)</th>
        <th>Amount (claimed cents)</th>
        <th>Default amount (cents)</th>
        <th>Default count</th>
      </tr>
    </thead>
    <tbody>
      {''.join(rows_html) if rows_html else '<tr><td colspan="16">No Red‑Packet campaigns configured.</td></tr>'}
    </tbody>
  </table>
</body></html>
"""
        return HTMLResponse(content=html)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/admin/redpacket_campaigns/detail", response_class=HTMLResponse)
def admin_redpacket_campaign_detail(
    request: Request, campaign_id: str
) -> HTMLResponse:
    """
    Detailansicht für eine einzelne Red‑Packet‑Kampagne.

    Kombiniert Stammdaten, Moments‑KPI und Payments‑KPI – WeChat‑ähnlich.
    """
    _require_admin_v2(request)
    try:
        # Load campaign + owning Official account
        with _officials_session() as s:
            camp = s.get(RedPacketCampaignDB, campaign_id)
            if not camp:
                raise HTTPException(status_code=404, detail="campaign not found")
            acc = s.get(OfficialAccountDB, camp.account_id)

        # Moments metrics for this campaign (origin_official_item_id == campaign_id)
        moments_total = 0
        moments_30d = 0
        uniq_total = 0
        uniq_30d = 0
        last_share_ts = ""
        posts: list[MomentPostDB] = []
        likes_map: dict[int, int] = {}
        comments_map: dict[int, int] = {}
        try:
            since_30d = datetime.now(timezone.utc) - timedelta(days=30)
            with _moments_session() as ms:
                moments_total = (
                    ms.execute(
                        _sa_select(_sa_func.count(MomentPostDB.id)).where(
                            MomentPostDB.origin_official_item_id == campaign_id
                        )
                    )
                    .scalar()
                    or 0
                )
                moments_30d = (
                    ms.execute(
                        _sa_select(_sa_func.count(MomentPostDB.id)).where(
                            MomentPostDB.origin_official_item_id == campaign_id,
                            MomentPostDB.created_at >= since_30d,
                        )
                    )
                    .scalar()
                    or 0
                )
                uniq_total = (
                    ms.execute(
                        _sa_select(
                            _sa_func.count(
                                _sa_func.distinct(MomentPostDB.user_key)
                            )
                        ).where(
                            MomentPostDB.origin_official_item_id
                            == campaign_id
                        )
                    )
                    .scalar()
                    or 0
                )
                uniq_30d = (
                    ms.execute(
                        _sa_select(
                            _sa_func.count(
                                _sa_func.distinct(MomentPostDB.user_key)
                            )
                        ).where(
                            MomentPostDB.origin_official_item_id
                            == campaign_id,
                            MomentPostDB.created_at >= since_30d,
                        )
                    )
                    .scalar()
                    or 0
                )
                last_row = (
                    ms.execute(
                        _sa_select(_sa_func.max(MomentPostDB.created_at)).where(
                            MomentPostDB.origin_official_item_id == campaign_id
                        )
                    )
                    .scalar()
                    or None
                )
                if last_row is not None:
                    try:
                        last_share_ts = (
                            last_row.isoformat().replace("+00:00", "Z")
                            if isinstance(last_row, datetime)
                            else str(last_row)
                        )
                    except Exception:
                        last_share_ts = str(last_row)
                # Latest posts for QA table
                posts = (
                    ms.execute(
                        _sa_select(MomentPostDB)
                        .where(MomentPostDB.origin_official_item_id == campaign_id)
                        .order_by(
                            MomentPostDB.created_at.desc(), MomentPostDB.id.desc()
                        )
                        .limit(100)
                    )
                    .scalars()
                    .all()
                )
                post_ids = [p.id for p in posts]
                if post_ids:
                    likes_rows = (
                        ms.execute(
                            _sa_select(
                                MomentLikeDB.post_id,
                                _sa_func.count(MomentLikeDB.id),
                            ).where(MomentLikeDB.post_id.in_(post_ids))
                            .group_by(MomentLikeDB.post_id)
                        )
                        .all()
                    )
                    for pid, cnt in likes_rows:
                        likes_map[int(pid)] = int(cnt or 0)
                    comments_rows = (
                        ms.execute(
                            _sa_select(
                                MomentCommentDB.post_id,
                                _sa_func.count(MomentCommentDB.id),
                            ).where(MomentCommentDB.post_id.in_(post_ids))
                            .group_by(MomentCommentDB.post_id)
                        )
                        .all()
                    )
                    for pid, cnt in comments_rows:
                        comments_map[int(pid)] = int(cnt or 0)
        except Exception:
            moments_total = 0
            moments_30d = 0
            uniq_total = 0
            uniq_30d = 0
            last_share_ts = ""
            posts = []
            likes_map = {}
            comments_map = {}

        # Optional Payments metrics via PAYMENTS_BASE
        payments_data: dict[str, Any] = {}
        try:
            if PAYMENTS_BASE:
                base = PAYMENTS_BASE.rstrip("/")
                url = f"{base}/admin/redpacket_campaigns/payments_analytics"
                r = httpx.get(
                    url, headers=_payments_headers(), params={"campaign_id": campaign_id}, timeout=5.0
                )
                if (
                    r.status_code == 200
                    and r.headers.get("content-type", "").startswith(
                        "application/json"
                    )
                ):
                    data = r.json()
                    if isinstance(data, dict):
                        payments_data = data
        except Exception:
            payments_data = {}

        def esc(s: str) -> str:
            return (
                s.replace("&", "&amp;")
                .replace("<", "&lt;")
                .replace(">", "&gt;")
            )

        def_amt = getattr(camp, "default_amount_cents", None) or 0
        def_count = getattr(camp, "default_count", None) or 0
        note = getattr(camp, "note", "") or ""
        status = "active" if getattr(camp, "active", True) else "inactive"
        acc_name = acc.name if acc else camp.account_id
        acc_kind = acc.kind if acc else ""

        total_packets_issued = int(payments_data.get("total_packets_issued", 0) or 0)
        total_packets_claimed = int(
            payments_data.get("total_packets_claimed", 0) or 0
        )
        total_amount_cents = int(
            payments_data.get("total_amount_cents", 0) or 0
        )
        claimed_amount_cents = int(
            payments_data.get("claimed_amount_cents", 0) or 0
        )

        rows_html: list[str] = []
        for p in posts:
            pts = p.created_at
            pts_str = (
                pts.isoformat().replace("+00:00", "Z")
                if isinstance(pts, datetime)
                else datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")
            )
            likes = likes_map.get(p.id, 0)
            comments = comments_map.get(p.id, 0)
            text = (p.text or "")[:260]
            rows_html.append(
                "<tr>"
                f"<td>{p.id}</td>"
                f"<td><pre>{esc(p.user_key or '')}</pre></td>"
                f"<td><span class=\"meta\">{esc(pts_str)}</span></td>"
                f"<td>{likes}</td>"
                f"<td>{comments}</td>"
                f"<td><pre>{esc(text)}</pre></td>"
                f"<td><a href=\"/moments/admin/comments/html?post_id={p.id}"
                + (
                    f"&official_account_id={esc(camp.account_id)}"
                    if camp.account_id
                    else ""
                )
                + "\">Comments</a></td>"
                "</tr>"
            )

        html = f"""
<!doctype html>
<html><head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Red‑Packet Campaign · {esc(campaign_id)}</title>
  <style>
    body{{font-family:sans-serif;margin:20px;max-width:1100px;color:#0f172a;}}
    h1{{margin-bottom:4px;}}
    h2{{margin-top:20px;margin-bottom:6px;}}
    table{{border-collapse:collapse;width:100%;margin-top:8px;}}
    th,td{{padding:6px 8px;border-bottom:1px solid #e5e7eb;font-size:13px;text-align:left;vertical-align:top;}}
    th{{background:#f9fafb;font-weight:600;}}
    .meta{{color:#6b7280;font-size:12px;margin-top:2px;}}
    code{{background:#f3f4f6;padding:2px 4px;border-radius:3px;font-size:12px;}}
  </style>
</head><body>
  <h1>Red‑Packet Campaign · <code>{esc(campaign_id)}</code></h1>
  <p class="meta">
    <a href="/admin/redpacket_campaigns/analytics">Zurück zur Kampagnen-Übersicht</a>
    · <a href="/admin/officials">Official-Admin-Konsole</a>
  </p>

  <h2>Stammdaten</h2>
  <table>
    <tbody>
      <tr><th>Campaign ID</th><td><code>{esc(campaign_id)}</code></td></tr>
      <tr><th>Title</th><td>{esc(camp.title or "")}</td></tr>
      <tr><th>Account</th><td>{esc(acc_name or "")} <span class="meta">({esc(camp.account_id)})</span></td></tr>
      <tr><th>Kind</th><td>{esc(acc_kind or "")}</td></tr>
      <tr><th>Status</th><td>{status}</td></tr>
      <tr><th>Default amount (cents)</th><td>{def_amt if def_amt else ''}</td></tr>
      <tr><th>Default count</th><td>{def_count if def_count else ''}</td></tr>
      <tr><th>Note</th><td>{esc(note)}</td></tr>
    </tbody>
  </table>

  <h2>Moments · Social Impact</h2>
  <table>
    <tbody>
      <tr><th>Moments shares (all time)</th><td>{moments_total}</td></tr>
      <tr><th>Moments shares (30d)</th><td>{moments_30d}</td></tr>
      <tr><th>Unique sharers (all time)</th><td>{uniq_total}</td></tr>
      <tr><th>Unique sharers (30d)</th><td>{uniq_30d}</td></tr>
      <tr><th>Last share TS</th><td><span class="meta">{esc(last_share_ts)}</span></td></tr>
    </tbody>
  </table>
  <p class="meta">
    QA‑Links:
    <a href="/moments/admin/html?campaign_id={esc(campaign_id)}&limit=200">Moments Admin (nur diese Kampagne)</a>
    · <a href="/moments/admin/html?redpacket_only=1">Alle Red‑Packet‑Moments</a>
  </p>

  <h2>Payments · Red‑Packets</h2>
  <table>
    <tbody>
      <tr><th>Packets issued</th><td>{total_packets_issued}</td></tr>
      <tr><th>Packets claimed</th><td>{total_packets_claimed}</td></tr>
      <tr><th>Amount total (cents)</th><td>{total_amount_cents}</td></tr>
      <tr><th>Amount claimed (cents)</th><td>{claimed_amount_cents}</td></tr>
    </tbody>
  </table>

  <h2>Moments · Letzte Posts (QA)</h2>
  <table>
    <thead>
      <tr>
        <th>ID</th>
        <th>User</th>
        <th>Created</th>
        <th>Likes</th>
        <th>Comments</th>
        <th>Text (truncated)</th>
        <th>Actions</th>
      </tr>
    </thead>
    <tbody>
      {''.join(rows_html) if rows_html else '<tr><td colspan="7">No Moments posts for this campaign yet.</td></tr>'}
    </tbody>
  </table>
</body></html>
"""
        return HTMLResponse(content=html)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get(
    "/official_accounts/{account_id}/campaigns/{campaign_id}/top_moments",
    response_class=JSONResponse,
)
def official_campaign_top_moments(
    account_id: str, campaign_id: str, limit: int = 5
) -> dict[str, Any]:
    """
    Returns top Moments posts for a single Red‑Packet campaign.

    This powers a WeChat‑style in‑app ranking of the most engaging
    Red‑Packet Moments per campaign (based on likes, comments and
    recency) in merchant UIs.
    """
    cid = (campaign_id or "").strip()
    if not cid:
        raise HTTPException(status_code=400, detail="campaign_id required")
    try:
        with _officials_session() as s:
            camp = s.get(RedPacketCampaignDB, cid)
            if not camp or camp.account_id != account_id:
                raise HTTPException(status_code=404, detail="campaign not found")
        try:
            limit_val = max(1, min(limit, 20))
        except Exception:
            limit_val = 5
        items: list[RedPacketCampaignTopMomentOut] = []
        try:
            with _moments_session() as ms:
                posts = (
                    ms.execute(
                        _sa_select(MomentPostDB)
                        .where(MomentPostDB.origin_official_item_id == cid)
                        .order_by(
                            MomentPostDB.created_at.desc(),
                            MomentPostDB.id.desc(),
                        )
                        .limit(100)
                    )
                    .scalars()
                    .all()
                )
                if posts:
                    post_ids = [p.id for p in posts]
                    likes_map: dict[int, int] = {}
                    comments_map: dict[int, int] = {}
                    try:
                        likes_rows = (
                            ms.execute(
                                _sa_select(
                                    MomentLikeDB.post_id,
                                    _sa_func.count(MomentLikeDB.id),
                                )
                                .where(MomentLikeDB.post_id.in_(post_ids))
                                .group_by(MomentLikeDB.post_id)
                            )
                            .all()
                        )
                        for pid, cnt in likes_rows:
                            try:
                                likes_map[int(pid)] = int(cnt or 0)
                            except Exception:
                                continue
                    except Exception:
                        likes_map = {}
                    try:
                        comments_rows = (
                            ms.execute(
                                _sa_select(
                                    MomentCommentDB.post_id,
                                    _sa_func.count(MomentCommentDB.id),
                                )
                                .where(MomentCommentDB.post_id.in_(post_ids))
                                .group_by(MomentCommentDB.post_id)
                            )
                            .all()
                        )
                        for pid, cnt in comments_rows:
                            try:
                                comments_map[int(pid)] = int(cnt or 0)
                            except Exception:
                                continue
                    except Exception:
                        comments_map = {}
                    now = datetime.now(timezone.utc)
                    scored: list[tuple[float, RedPacketCampaignTopMomentOut]] = []
                    for p in posts:
                        try:
                            pid = int(p.id)
                        except Exception:
                            continue
                        likes = likes_map.get(pid, 0)
                        comments = comments_map.get(pid, 0)
                        ts = getattr(p, "created_at", None)
                        if isinstance(ts, datetime):
                            ts_str = ts.isoformat().replace("+00:00", "Z")
                            age_days = max(0.0, (now - ts).total_seconds() / 86400.0)
                        else:
                            ts_str = None
                            age_days = 0.0
                        # Simple engagement score: likes & comments with
                        # a mild recency boost (newer posts slightly ahead).
                        score = float(likes * 2 + comments * 3)
                        try:
                            if age_days > 0.0:
                                score = score + max(0.0, 5.0 - age_days)
                        except Exception:
                            pass
                        text = (getattr(p, "text", "") or "")[:140]
                        scored.append(
                            (
                                score,
                                RedPacketCampaignTopMomentOut(
                                    post_id=pid,
                                    text=text,
                                    ts=ts_str,
                                    likes=likes,
                                    comments=comments,
                                    score=score,
                                ),
                            )
                        )
                    if scored:
                        scored.sort(key=lambda t: t[0], reverse=True)
                        for _, item in scored[:limit_val]:
                            items.append(item)
        except Exception:
            items = []
        return {"items": [i.dict() for i in items]}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/official_accounts", response_class=JSONResponse)
async def list_official_accounts(request: Request, kind: str | None = None, followed_only: bool = True):
    ck = _official_cookie_key(request)
    try:
        with _officials_session() as s:
            stmt = _sa_select(OfficialAccountDB).where(OfficialAccountDB.enabled == True)  # type: ignore[comparison-overlap]
            if kind:
                stmt = stmt.where(OfficialAccountDB.kind == kind)
            accounts = list(s.execute(stmt).scalars().all())
            # Active Red‑Packet campaigns per Official (for badges in directory / search).
            campaign_counts: dict[str, int] = {}
            try:
                acc_ids_campaign = [acc.id for acc in accounts]
                if acc_ids_campaign:
                    camp_rows = (
                        s.execute(
                            _sa_select(
                                RedPacketCampaignDB.account_id,
                                _sa_func.count(RedPacketCampaignDB.id),
                            )
                            .where(
                                RedPacketCampaignDB.account_id.in_(acc_ids_campaign),
                                RedPacketCampaignDB.active.is_(True),
                            )
                            .group_by(RedPacketCampaignDB.account_id)
                        )
                        .all()
                    )
                    for acc_id, cnt in camp_rows:
                        try:
                            campaign_counts[str(acc_id)] = int(cnt or 0)
                        except Exception:
                            continue
            except Exception:
                campaign_counts = {}
            # Best-effort Moments share counts per Official (global, all users).
            moments_shares: dict[str, int] = {}
            try:
                acc_ids = [acc.id for acc in accounts]
                if acc_ids:
                    with _moments_session() as ms:
                        mrows = (
                            ms.execute(
                                _sa_select(
                                    MomentPostDB.origin_official_account_id,
                                    _sa_func.count(MomentPostDB.id),
                                )
                                .where(
                                    MomentPostDB.origin_official_account_id.in_(
                                        acc_ids
                                    )
                                )
                                .group_by(MomentPostDB.origin_official_account_id)
                            )
                            .all()
                        )
                        for acc_id, cnt in mrows:
                            try:
                                moments_shares[str(acc_id)] = int(cnt or 0)
                            except Exception:
                                continue
            except Exception:
                moments_shares = {}
            notif_modes: dict[str, str] = {}
            try:
                notif_rows = (
                    s.execute(
                        _sa_select(OfficialNotificationDB).where(
                            OfficialNotificationDB.user_key == ck
                        )
                    )
                    .scalars()
                    .all()
                )
                for row in notif_rows:
                    if row.mode:
                        notif_modes[row.account_id] = row.mode
            except Exception:
                notif_modes = {}
            followed_ids = set(
                s.execute(
                    _sa_select(OfficialFollowDB.account_id).where(OfficialFollowDB.user_key == ck)
                ).scalars().all()
            )
            if not followed_ids and accounts:
                for acc in accounts:
                    s.add(OfficialFollowDB(user_key=ck, account_id=acc.id))
                s.commit()
                followed_ids = {acc.id for acc in accounts}
            items: list[dict[str, Any]] = []
            for acc in accounts:
                is_followed = acc.id in followed_ids
                if followed_only and not is_followed:
                    continue
                last_item_dict: dict[str, Any] | None = None
                try:
                    fi_stmt = (
                        _sa_select(OfficialFeedItemDB)
                        .where(OfficialFeedItemDB.account_id == acc.id)
                        .order_by(OfficialFeedItemDB.ts.desc(), OfficialFeedItemDB.id.desc())
                        .limit(1)
                    )
                    fi = s.execute(fi_stmt).scalars().first()
                except Exception:
                    fi = None
                if fi is not None:
                    try:
                        deeplink = _json.loads(fi.deeplink_json) if fi.deeplink_json else None
                    except Exception:
                        deeplink = None
                    last_item_dict = {
                        "id": fi.slug or str(fi.id),
                        "type": fi.type,
                        "title": fi.title,
                        "snippet": fi.snippet,
                        "thumb_url": fi.thumb_url,
                        "ts": fi.ts.isoformat() if getattr(fi, "ts", None) else None,
                        "deeplink": deeplink,
                    }
                data = {
                    "id": acc.id,
                    "kind": acc.kind,
                    "name": acc.name,
                    "name_ar": acc.name_ar,
                    "avatar_url": acc.avatar_url,
                    "verified": acc.verified,
                    "mini_app_id": acc.mini_app_id,
                    "description": acc.description,
                    "chat_peer_id": getattr(acc, "chat_peer_id", None),
                    "category": getattr(acc, "category", None),
                    "city": getattr(acc, "city", None),
                    "address": getattr(acc, "address", None),
                    "opening_hours": getattr(acc, "opening_hours", None),
                    "website_url": getattr(acc, "website_url", None),
                    "qr_payload": getattr(acc, "qr_payload", None),
                    "featured": getattr(acc, "featured", False),
                    "unread_count": 0,
                    "last_item": last_item_dict,
                    "followed": is_followed,
                }
                # Include global Moments share count for this Official as a
                # lightweight "hotness" indicator (used in Moments filters).
                try:
                    data["moments_total_shares"] = int(
                        moments_shares.get(acc.id, 0)
                    )
                except Exception:
                    data["moments_total_shares"] = 0
                try:
                    data["campaigns_active"] = int(
                        campaign_counts.get(acc.id, 0)
                    )
                except Exception:
                    data["campaigns_active"] = 0
                if acc.id in notif_modes:
                    data["notif_mode"] = notif_modes[acc.id]
                menu_items = _official_menu_items_for(acc)
                if menu_items:
                    data["menu_items"] = menu_items
                items.append(data)
        try:
            emit_event(
                "officials",
                "accounts_listed",
                {
                    "user_key": ck,
                    "kind": kind,
                    "followed_only": followed_only,
                    "count": len(items),
                },
            )
        except Exception:
            pass
        return {"accounts": items}
    except HTTPException:
        raise
    except Exception:
        followed = _OFFICIAL_FOLLOWS.get(ck) or set(_OFFICIAL_ACCOUNTS.keys())
        fallback_items: list[dict[str, Any]] = []
        for acc in _OFFICIAL_ACCOUNTS.values():
            if kind and acc.kind != kind:
                continue
            is_followed = acc.id in followed
            if followed_only and not is_followed:
                continue
            data = acc.dict()
            data["followed"] = is_followed
            fallback_items.append(data)
        try:
            emit_event(
                "officials",
                "accounts_listed",
                {
                    "user_key": ck,
                    "kind": kind,
                    "followed_only": followed_only,
                    "count": len(fallback_items),
                    "mode": "fallback",
                },
            )
        except Exception:
            pass
        return {"accounts": fallback_items}


@app.post("/official_accounts/self_register", response_class=JSONResponse)
def official_account_self_register(
    request: Request, body: OfficialAccountSelfRegisterIn
) -> dict[str, Any]:
    """
    Self‑service registration endpoint for Official accounts.

    A logged‑in merchant can propose a new WeChat‑style Official
    account. The request is stored separately and can later be
    reviewed and approved by ops before an OfficialAccountDB row is
    created.
    """
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="auth required")
    account_id = (body.account_id or "").strip()
    if not account_id:
        raise HTTPException(status_code=400, detail="account_id required")
    # Simple slug validation similar to Mini‑Programs.
    for ch in account_id:
        if not (ch.islower() or ch.isdigit() or ch in {"_", "-"}):
            raise HTTPException(
                status_code=400,
                detail="account_id may only contain lowercase letters, digits, '_' or '-'",
            )
    kind = (body.kind or "service").strip().lower()
    if kind not in {"service", "subscription"}:
        raise HTTPException(status_code=400, detail="kind must be 'service' or 'subscription'")
    name = (body.name or "").strip()
    if not name:
        raise HTTPException(status_code=400, detail="name required")
    owner_name = (body.owner_name or "").strip()
    if not owner_name:
        owner_name = f"Merchant {phone}"
    contact_phone = (body.contact_phone or "").strip()
    if not contact_phone:
        contact_phone = phone
    contact_email = (body.contact_email or "").strip() or None
    try:
        with _officials_session() as s:
            # Prevent registering an ID that already exists as an Official.
            existing_acc = s.get(OfficialAccountDB, account_id)
            if existing_acc:
                raise HTTPException(status_code=409, detail="official account with this id already exists")
            # Allow the same requester to update their latest request; others must use a different id.
            existing_req = (
                s.execute(
                    _sa_select(OfficialAccountRequestDB)
                    .where(
                        OfficialAccountRequestDB.account_id == account_id,
                        OfficialAccountRequestDB.requester_phone == phone,
                    )
                    .order_by(OfficialAccountRequestDB.id.desc())
                )
                .scalars()
                .first()
            )
            if existing_req:
                existing_req.kind = kind
                existing_req.name = name
                if body.name_ar is not None:
                    existing_req.name_ar = body.name_ar
                if body.description is not None:
                    existing_req.description = body.description
                if body.category is not None:
                    existing_req.category = body.category
                if body.city is not None:
                    existing_req.city = body.city
                if body.address is not None:
                    existing_req.address = body.address
                if body.opening_hours is not None:
                    existing_req.opening_hours = body.opening_hours
                if body.website_url is not None:
                    existing_req.website_url = body.website_url
                if body.mini_app_id is not None:
                    existing_req.mini_app_id = body.mini_app_id
                existing_req.owner_name = owner_name
                existing_req.contact_phone = contact_phone
                existing_req.contact_email = contact_email
                row = existing_req
            else:
                row = OfficialAccountRequestDB(
                    account_id=account_id,
                    kind=kind,
                    name=name,
                    name_ar=body.name_ar,
                    description=body.description,
                    category=body.category,
                    city=body.city,
                    address=body.address,
                    opening_hours=body.opening_hours,
                    website_url=body.website_url,
                    mini_app_id=body.mini_app_id,
                    owner_name=owner_name,
                    contact_phone=contact_phone,
                    contact_email=contact_email,
                    requester_phone=phone,
                    status="submitted",
                )
                s.add(row)
            s.commit()
            s.refresh(row)
            try:
                emit_event(
                    "officials",
                    "self_register",
                    {
                        "account_id": row.account_id,
                        "request_id": row.id,
                        "requester_phone": row.requester_phone,
                        "status": row.status,
                    },
                )
            except Exception:
                pass
            out = OfficialAccountRequestOut(
                id=row.id,
                account_id=row.account_id,
                kind=row.kind,
                name=row.name,
                name_ar=row.name_ar,
                description=row.description,
                category=row.category,
                city=row.city,
                address=row.address,
                opening_hours=row.opening_hours,
                website_url=row.website_url,
                mini_app_id=row.mini_app_id,
                owner_name=row.owner_name,
                contact_phone=row.contact_phone,
                contact_email=row.contact_email,
                requester_phone=row.requester_phone,
                status=row.status,
                created_at=row.created_at,
                updated_at=row.updated_at,
            )
            return out.dict()
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/me/official_account_requests", response_class=JSONResponse)
def me_official_account_requests(request: Request) -> dict[str, Any]:
    """
    Lists Official account registration requests for the current user.

    This gives a WeChat‑like overview of pending/approved/rejected
    Official account applications owned by the caller (based on phone).
    """
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="auth required")
    try:
        with _officials_session() as s:
            rows = (
                s.execute(
                    _sa_select(OfficialAccountRequestDB)
                    .where(OfficialAccountRequestDB.requester_phone == phone)
                    .order_by(OfficialAccountRequestDB.created_at.desc())
                )
                .scalars()
                .all()
            )
            items: list[dict[str, Any]] = []
            for row in rows:
                items.append(
                    OfficialAccountRequestOut(
                        id=row.id,
                        account_id=row.account_id,
                        kind=row.kind,
                        name=row.name,
                        name_ar=row.name_ar,
                        description=row.description,
                        category=row.category,
                        city=row.city,
                        address=row.address,
                        opening_hours=row.opening_hours,
                        website_url=row.website_url,
                        mini_app_id=row.mini_app_id,
                        owner_name=row.owner_name,
                        contact_phone=row.contact_phone,
                        contact_email=row.contact_email,
                        requester_phone=row.requester_phone,
                        status=row.status,
                        created_at=row.created_at,
                        updated_at=row.updated_at,
                    ).dict()
                )
        return {"requests": items}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/me/official_template_messages", response_class=JSONResponse)
def me_official_template_messages(
    request: Request, unread_only: bool = False, limit: int = 50
) -> dict[str, Any]:
    """
    Returns Official template messages for the current user (WeChat-like one-time service messages).
    """
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="auth required")
    limit_val = max(1, min(limit, 200))
    try:
        with _officials_session() as s:
            stmt = _sa_select(OfficialTemplateMessageDB).where(
                OfficialTemplateMessageDB.user_phone == phone
            )
            if unread_only:
                stmt = stmt.where(OfficialTemplateMessageDB.read_at.is_(None))
            stmt = stmt.order_by(
                OfficialTemplateMessageDB.created_at.desc()
            ).limit(limit_val)
            rows = s.execute(stmt).scalars().all()
            items: list[dict[str, Any]] = []
            for row in rows:
                try:
                    deeplink = (
                        _json.loads(row.deeplink_json)
                        if row.deeplink_json
                        else None
                    )
                except Exception:
                    deeplink = None
                out = OfficialTemplateMessageOut(
                    id=row.id,
                    account_id=row.account_id,
                    title=row.title,
                    body=row.body,
                    deeplink_json=deeplink,
                    created_at=row.created_at,
                    read_at=row.read_at,
                )
                items.append(out.dict())
        return {"messages": items}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post(
    "/me/official_template_messages/{message_id}/read",
    response_class=JSONResponse,
)
def me_official_template_messages_mark_read(
    message_id: int, request: Request
) -> dict[str, Any]:
    """
    Marks a single Official template message as read for the current user.
    """
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="auth required")
    try:
        with _officials_session() as s:
            row = s.get(OfficialTemplateMessageDB, message_id)
            if not row or row.user_phone != phone:
                raise HTTPException(status_code=404, detail="message not found")
            if row.read_at is None:
                row.read_at = datetime.now(timezone.utc)
                s.add(row)
                s.commit()
                s.refresh(row)
                try:
                    emit_event(
                        "officials",
                        "template_message_read",
                        {
                            "account_id": row.account_id,
                            "user_phone": row.user_phone,
                            "message_id": row.id,
                        },
                    )
                except Exception:
                    pass
            try:
                deeplink = (
                    _json.loads(row.deeplink_json)
                    if row.deeplink_json
                    else None
                )
            except Exception:
                deeplink = None
            out = OfficialTemplateMessageOut(
                id=row.id,
                account_id=row.account_id,
                title=row.title,
                body=row.body,
                deeplink_json=deeplink,
                created_at=row.created_at,
                read_at=row.read_at,
            )
            return out.dict()
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/mini_programs", response_class=JSONResponse)
def mini_program_create(request: Request, body: MiniProgramAdminIn) -> dict[str, Any]:
    """
    Legt einen neuen Mini‑Program‑Eintrag an (admin only).

    Dies bildet die WeChat‑ähnliche Mini‑Program‑Registry ab, getrennt
    von den konkreten App‑Versionen.
    """
    _require_admin_v2(request)
    app_id = (body.app_id or "").strip()
    if not app_id:
        raise HTTPException(status_code=400, detail="app_id required")
    title_en = (body.title_en or "").strip()
    if not title_en:
        raise HTTPException(status_code=400, detail="title_en required")
    try:
        with _officials_session() as s:
            existing = (
                s.execute(
                    _sa_select(MiniProgramDB).where(MiniProgramDB.app_id == app_id)
                )
                .scalars()
                .first()
            )
            if existing:
                raise HTTPException(status_code=409, detail="mini-program already exists")
            actions_json: str | None = None
            if body.actions:
                try:
                    actions_json = _json.dumps([a.dict() for a in body.actions])
                except Exception:
                    actions_json = None
            scopes_json: str | None = None
            if body.scopes:
                try:
                    scopes = [str(s).strip() for s in body.scopes if str(s).strip()]
                    if scopes:
                        scopes_json = _json.dumps(scopes)
                except Exception:
                    scopes_json = None
            row = MiniProgramDB(
                app_id=app_id,
                title_en=title_en,
                title_ar=body.title_ar,
                description_en=body.description_en,
                description_ar=body.description_ar,
                owner_name=body.owner_name,
                owner_contact=body.owner_contact,
                actions_json=actions_json,
                 scopes_json=scopes_json,
                status="draft",
                review_status="draft",
            )
            s.add(row)
            s.commit()
            s.refresh(row)
            actions_out: list[dict[str, Any]] = []
            if body.actions:
                for a in body.actions:
                    actions_out.append(
                        {
                            "id": a.id,
                            "label_en": a.label_en,
                            "label_ar": a.label_ar,
                            "kind": a.kind,
                            "mod_id": a.mod_id,
                            "url": a.url,
                        }
                    )
            scopes_out: list[str] | None = None
            if scopes_json:
                try:
                    val = _json.loads(scopes_json)
                    if isinstance(val, list):
                        scopes_out = [str(s) for s in val if str(s).strip()]
                except Exception:
                    scopes_out = None
            return {
                "app_id": row.app_id,
                "title_en": row.title_en,
                "title_ar": row.title_ar,
                "description_en": row.description_en,
                "description_ar": row.description_ar,
                "owner_name": row.owner_name,
                "owner_contact": row.owner_contact,
                "status": row.status,
                "review_status": getattr(row, "review_status", "draft"),
                "scopes": scopes_out,
                "actions": actions_out,
                "created_at": getattr(row, "created_at", None),
                "updated_at": getattr(row, "updated_at", None),
            }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/mini_programs/self_register", response_class=JSONResponse)
def mini_program_self_register(
    request: Request, body: MiniProgramSelfRegisterIn
) -> dict[str, Any]:
    """
    Self‑service registration endpoint for third‑party Mini‑Programs.

    A logged‑in developer can create or update basic metadata for a
    Mini‑Program. New entries are created with status "draft"; ops can
    later review and activate them via the admin console.
    """
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="auth required")
    app_id = (body.app_id or "").strip()
    if not app_id:
        raise HTTPException(status_code=400, detail="app_id required")
    title_en = (body.title_en or "").strip()
    if not title_en:
        raise HTTPException(status_code=400, detail="title_en required")
    # Very simple app_id sanity-check to avoid surprising IDs.
    for ch in app_id:
        if not (ch.islower() or ch.isdigit() or ch in {"_", "-"}):
            raise HTTPException(
                status_code=400,
                detail="app_id may only contain lowercase letters, digits, '_' or '-'",
            )
    owner_name = (body.owner_name or "").strip()
    if not owner_name:
        owner_name = f"Developer {phone}"
    owner_contact = (body.owner_contact or "").strip()
    if not owner_contact:
        owner_contact = phone
    try:
        with _officials_session() as s:
            existing = (
                s.execute(
                    _sa_select(MiniProgramDB).where(MiniProgramDB.app_id == app_id)
                )
                .scalars()
                .first()
            )
            scopes_json: str | None = None
            if body.scopes:
                try:
                    scopes = [str(s).strip() for s in body.scopes if str(s).strip()]
                    if scopes:
                        scopes_json = _json.dumps(scopes)
                except Exception:
                    scopes_json = None
            if existing:
                # Only allow the original owner (based on owner_contact) to update.
                try:
                    existing_contact = (existing.owner_contact or "").strip()
                except Exception:
                    existing_contact = ""
                if existing_contact and existing_contact != phone:
                    raise HTTPException(
                        status_code=403,
                        detail="mini-program already exists and is owned by a different contact",
                    )
                existing.title_en = title_en
                existing.title_ar = body.title_ar or existing.title_ar
                existing.description_en = (
                    body.description_en or existing.description_en
                )
                existing.description_ar = (
                    body.description_ar or existing.description_ar
                )
                existing.owner_name = owner_name
                existing.owner_contact = owner_contact
                if scopes_json is not None:
                    existing.scopes_json = scopes_json
                s.add(existing)
                row = existing
            else:
                row = MiniProgramDB(
                    app_id=app_id,
                    title_en=title_en,
                    title_ar=body.title_ar,
                    description_en=body.description_en,
                    description_ar=body.description_ar,
                    owner_name=owner_name,
                    owner_contact=owner_contact,
                    scopes_json=scopes_json,
                    status="draft",
                    review_status="draft",
                )
                s.add(row)
            s.commit()
            s.refresh(row)
            try:
                emit_event(
                    "miniprograms",
                    "self_register",
                    {
                        "app_id": row.app_id,
                        "owner_contact": row.owner_contact,
                        "status": row.status,
                    },
                )
            except Exception:
                pass
            return {
                "app_id": row.app_id,
                "title_en": row.title_en,
                "title_ar": row.title_ar,
                "description_en": row.description_en,
                "description_ar": row.description_ar,
                "owner_name": row.owner_name,
                "owner_contact": row.owner_contact,
                "status": row.status,
                "review_status": getattr(row, "review_status", "draft"),
                "scopes": (
                    [
                        str(s)
                        for s in (
                            (_json.loads(row.scopes_json or "[]"))
                            if getattr(row, "scopes_json", None)
                            else []
                        )
                        if str(s).strip()
                    ]
                    if getattr(row, "scopes_json", None)
                    else []
                ),
                "created_at": getattr(row, "created_at", None),
                "updated_at": getattr(row, "updated_at", None),
            }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post(
    "/mini_programs/{app_id}/submit_review",
    response_class=JSONResponse,
)
def mini_program_submit_review(request: Request, app_id: str) -> dict[str, Any]:
    """
    Developer-facing endpoint to submit a Mini‑Program for review.

    Only the original owner (based on owner_contact/phone) may call this.
    Sets review_status="submitted" but does not change the status field;
    ops can then approve the Mini‑Program in the admin Review‑Center.
    """
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="auth required")
    app_id_clean = (app_id or "").strip()
    if not app_id_clean:
        raise HTTPException(status_code=400, detail="app_id required")
    try:
        with _officials_session() as s:
            prog = (
                s.execute(
                    _sa_select(MiniProgramDB).where(
                        MiniProgramDB.app_id == app_id_clean
                    )
                )
                .scalars()
                .first()
            )
            if not prog:
                raise HTTPException(status_code=404, detail="mini-program not found")
            try:
                owner_contact = (prog.owner_contact or "").strip()
            except Exception:
                owner_contact = ""
            if owner_contact and owner_contact != phone:
                raise HTTPException(
                    status_code=403,
                    detail="only the original owner can submit this mini-program for review",
                )
            current_review = (getattr(prog, "review_status", "draft") or "").strip().lower()
            if current_review == "approved":
                # Already approved; nothing to do.
                return {
                    "app_id": prog.app_id,
                    "status": prog.status,
                    "review_status": current_review,
                }
            prog.review_status = "submitted"
            s.add(prog)
            s.commit()
            s.refresh(prog)
            try:
                emit_event(
                    "miniprograms",
                    "submit_review",
                    {
                        "app_id": prog.app_id,
                        "owner_contact": prog.owner_contact,
                        "status": prog.status,
                        "review_status": prog.review_status,
                    },
                )
            except Exception:
                pass
            return {
                "app_id": prog.app_id,
                "status": prog.status,
                "review_status": getattr(prog, "review_status", "submitted"),
            }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/mini_programs", response_class=JSONResponse)
def mini_program_list() -> dict[str, Any]:
    """
    Öffentlicher JSON‑Katalog für registrierte Mini‑Programme.

    Dient als Basis für spätere Developer‑Portale und den
    Mini‑Program‑Runtime, ähnlich zu WeChat.
    """
    try:
        with _officials_session() as s:
            programs = (
                s.execute(
                    _sa_select(MiniProgramDB).order_by(MiniProgramDB.app_id)
                )
                .scalars()
                .all()
            )
            app_ids = [p.app_id for p in programs]
            ratings_map: dict[str, tuple[float, int]] = {}
            if app_ids:
                try:
                    agg_rows = (
                        s.execute(
                            _sa_select(
                                MiniProgramRatingDB.app_id,
                                _sa_func.avg(MiniProgramRatingDB.rating),
                                _sa_func.count(MiniProgramRatingDB.id),
                            ).where(MiniProgramRatingDB.app_id.in_(app_ids))
                            .group_by(MiniProgramRatingDB.app_id)
                        )
                        .all()
                    )
                    for app_id, avg_val, cnt in agg_rows:
                        try:
                            ratings_map[str(app_id)] = (
                                float(avg_val or 0.0),
                                int(cnt or 0),
                            )
                        except Exception:
                            continue
                except Exception:
                    ratings_map = {}
            # Best-effort Moments share counts per Mini-Program based on
            # shamell://mini_program/<id> deep-links in Moments posts.
            # So können Directory & Suche später "hot last 30 days"
            # ähnlich zu WeChat markieren.
            moments_shares: dict[str, int] = {}
            moments_shares_30d: dict[str, int] = {}
            try:
                if app_ids:
                    with _moments_session() as ms:
                        since_30d = datetime.now(timezone.utc) - timedelta(days=30)
                        for app_id in app_ids:
                            try:
                                pattern = f"shamell://mini_program/{app_id}"
                                base_stmt = _sa_select(
                                    _sa_func.count(MomentPostDB.id)
                                ).where(MomentPostDB.text.contains(pattern))
                                cnt_all = ms.execute(base_stmt).scalar() or 0
                                cnt_30 = (
                                    ms.execute(
                                        base_stmt.where(
                                            MomentPostDB.created_at >= since_30d
                                        )
                                    ).scalar()
                                    or 0
                                )
                                moments_shares[str(app_id)] = int(cnt_all or 0)
                                moments_shares_30d[str(app_id)] = int(cnt_30 or 0)
                            except Exception:
                                continue
            except Exception:
                moments_shares = {}
                moments_shares_30d = {}

            items: list[dict[str, Any]] = []
            for prog in programs:
                released_version: str | None = None
                released_channel: str | None = None
                usage_score_val = 0
                try:
                    usage_score_val = int(
                        getattr(prog, "usage_score", 0) or 0
                    )
                except Exception:
                    usage_score_val = 0
                try:
                    avg_rating, rating_count = ratings_map.get(
                        prog.app_id,
                        (
                            float(getattr(prog, "rating", 0.0) or 0.0),
                            0,
                        ),
                    )
                except Exception:
                    avg_rating, rating_count = 0.0, 0
                try:
                    rel = (
                        s.execute(
                            _sa_select(MiniProgramReleaseDB)
                            .where(MiniProgramReleaseDB.program_id == prog.id)
                            .order_by(
                                MiniProgramReleaseDB.created_at.desc(),
                                MiniProgramReleaseDB.id.desc(),
                            )
                            .limit(1)
                        )
                        .scalars()
                        .first()
                    )
                except Exception:
                    rel = None
                if rel is not None:
                    released_channel = rel.channel
                    try:
                        ver = s.get(MiniProgramVersionDB, rel.version_id)
                        if ver is not None:
                            released_version = ver.version
                    except Exception:
                        released_version = None
                scopes_list: list[str] = []
                try:
                    raw_scopes = getattr(prog, "scopes_json", None)
                    if raw_scopes:
                        val = _json.loads(raw_scopes)
                        if isinstance(val, list):
                            scopes_list = [
                                str(s).strip() for s in val if str(s).strip()
                            ]
                except Exception:
                    scopes_list = []
                try:
                    moments_count = int(
                        moments_shares.get(prog.app_id, 0)
                        or getattr(prog, "moments_shares", 0)
                        or 0
                    )
                except Exception:
                    moments_count = 0
                try:
                    moments_30 = int(
                        moments_shares_30d.get(prog.app_id, 0) or 0
                    )
                except Exception:
                    moments_30 = 0
                items.append(
                    {
                        "app_id": prog.app_id,
                        "title_en": prog.title_en,
                        "title_ar": prog.title_ar,
                        "description_en": getattr(prog, "description_en", None),
                        "description_ar": getattr(prog, "description_ar", None),
                        "owner_name": prog.owner_name,
                        "owner_contact": prog.owner_contact,
                        "status": prog.status,
                        "review_status": getattr(prog, "review_status", "draft"),
                        "scopes": scopes_list,
                        "usage_score": usage_score_val,
                        "rating": float(avg_rating),
                        "rating_count": int(rating_count),
                        "released_version": released_version,
                        "released_channel": released_channel,
                        "moments_shares": moments_count,
                        "moments_shares_30d": moments_30,
                    }
                )
        return {"programs": items}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/mini_programs/{app_id}", response_class=JSONResponse)
def mini_program_detail(app_id: str) -> dict[str, Any]:
    """
    Detailansicht eines Mini‑Program‑Eintrags inkl. Versionen.
    """
    app_id_clean = (app_id or "").strip()
    if not app_id_clean:
        raise HTTPException(status_code=400, detail="app_id required")
    try:
        with _officials_session() as s:
            prog = (
                s.execute(
                    _sa_select(MiniProgramDB).where(
                        MiniProgramDB.app_id == app_id_clean
                    )
                )
                .scalars()
                .first()
            )
            if not prog:
                raise HTTPException(status_code=404, detail="mini-program not found")
            versions = (
                s.execute(
                    _sa_select(MiniProgramVersionDB).where(
                        MiniProgramVersionDB.program_id == prog.id
                    )
                    .order_by(
                        MiniProgramVersionDB.created_at.desc(),
                        MiniProgramVersionDB.id.desc(),
                    )
                )
                .scalars()
                .all()
            )
            avg_rating = 0.0
            rating_count = 0
            try:
                row = (
                    s.execute(
                        _sa_select(
                            _sa_func.avg(MiniProgramRatingDB.rating),
                            _sa_func.count(MiniProgramRatingDB.id),
                        ).where(MiniProgramRatingDB.app_id == app_id_clean)
                    )
                    .first()
                )
                if row:
                    avg_rating = float(row[0] or 0.0)
                    rating_count = int(row[1] or 0)
            except Exception:
                avg_rating = 0.0
                rating_count = 0
            vers_items: list[dict[str, Any]] = []
            for v in versions:
                vers_items.append(
                    {
                        "id": v.id,
                        "version": v.version,
                        "bundle_url": v.bundle_url,
                        "changelog_en": v.changelog_en,
                        "changelog_ar": v.changelog_ar,
                        "created_at": getattr(v, "created_at", None),
                    }
                )
            actions: list[dict[str, Any]] = []
            raw_actions = getattr(prog, "actions_json", None)
            if raw_actions:
                try:
                    val = _json.loads(raw_actions)
                    if isinstance(val, list):
                        for item in val:
                            if not isinstance(item, dict):
                                continue
                            try:
                                aid = str(item.get("id") or "").strip()
                                if not aid:
                                    continue
                                actions.append(
                                    {
                                        "id": aid,
                                        "label_en": item.get("label_en") or "",
                                        "label_ar": item.get("label_ar") or "",
                                        "kind": item.get("kind") or "open_mod",
                                        "mod_id": item.get("mod_id"),
                                        "url": item.get("url"),
                                    }
                                )
                            except Exception:
                                continue
                except Exception:
                    actions = []
            scopes_list: list[str] = []
            try:
                raw_scopes = getattr(prog, "scopes_json", None)
                if raw_scopes:
                    val = _json.loads(raw_scopes)
                    if isinstance(val, list):
                        scopes_list = [
                            str(s).strip() for s in val if str(s).strip()
                        ]
            except Exception:
                scopes_list = []
            return {
                "app_id": prog.app_id,
                "title_en": prog.title_en,
                "title_ar": prog.title_ar,
                "description_en": getattr(prog, "description_en", None),
                "description_ar": getattr(prog, "description_ar", None),
                "owner_name": prog.owner_name,
                "owner_contact": prog.owner_contact,
                "status": prog.status,
                "review_status": getattr(prog, "review_status", "draft"),
                "scopes": scopes_list,
                "rating": avg_rating,
                "rating_count": rating_count,
                "versions": vers_items,
                "actions": actions,
            }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/mini_programs/{app_id}/versions", response_class=JSONResponse)
def mini_program_add_version(
    app_id: str, request: Request, body: MiniProgramVersionIn
) -> dict[str, Any]:
    """
    Registriert eine neue Version für ein Mini‑Programm (admin only).
    """
    _require_admin_v2(request)
    app_id_clean = (app_id or "").strip()
    if not app_id_clean:
        raise HTTPException(status_code=400, detail="app_id required")
    version = (body.version or "").strip()
    if not version:
        raise HTTPException(status_code=400, detail="version required")
    try:
        with _officials_session() as s:
            prog = (
                s.execute(
                    _sa_select(MiniProgramDB).where(
                        MiniProgramDB.app_id == app_id_clean
                    )
                )
                .scalars()
                .first()
            )
            if not prog:
                raise HTTPException(status_code=404, detail="mini-program not found")
            existing = (
                s.execute(
                    _sa_select(MiniProgramVersionDB).where(
                        MiniProgramVersionDB.program_id == prog.id,
                        MiniProgramVersionDB.version == version,
                    )
                )
                .scalars()
                .first()
            )
            if existing:
                raise HTTPException(status_code=409, detail="version already exists")
            row = MiniProgramVersionDB(
                program_id=prog.id,
                version=version,
                bundle_url=body.bundle_url,
                changelog_en=body.changelog_en,
                changelog_ar=body.changelog_ar,
            )
            s.add(row)
            s.commit()
            s.refresh(row)
            return {
                "app_id": prog.app_id,
                "version": row.version,
                "bundle_url": row.bundle_url,
                "changelog_en": row.changelog_en,
                "changelog_ar": row.changelog_ar,
                "created_at": getattr(row, "created_at", None),
            }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/mini_programs/{app_id}/versions/self_register", response_class=JSONResponse)
def mini_program_add_version_self(
    app_id: str, request: Request, body: MiniProgramSelfVersionIn
) -> dict[str, Any]:
    """
    Developer self‑service endpoint to propose a new Mini‑Program version.

    The version is recorded but not automatically released; ops can
    later create a Release via the admin API.
    """
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="auth required")
    app_id_clean = (app_id or "").strip()
    if not app_id_clean:
        raise HTTPException(status_code=400, detail="app_id required")
    version = (body.version or "").strip()
    if not version:
        raise HTTPException(status_code=400, detail="version required")
    bundle_url = (body.bundle_url or "").strip()
    if not bundle_url:
        raise HTTPException(status_code=400, detail="bundle_url required")
    try:
        with _officials_session() as s:
            prog = (
                s.execute(
                    _sa_select(MiniProgramDB).where(
                        MiniProgramDB.app_id == app_id_clean
                    )
                )
                .scalars()
                .first()
            )
            if not prog:
                raise HTTPException(status_code=404, detail="mini-program not found")
            # Only allow owner (based on owner_contact) to add versions.
            try:
                existing_contact = (prog.owner_contact or "").strip()
            except Exception:
                existing_contact = ""
            if existing_contact and existing_contact != phone:
                raise HTTPException(
                    status_code=403,
                    detail="mini-program is owned by a different contact",
                )
            existing = (
                s.execute(
                    _sa_select(MiniProgramVersionDB).where(
                        MiniProgramVersionDB.program_id == prog.id,
                        MiniProgramVersionDB.version == version,
                    )
                )
                .scalars()
                .first()
            )
            if existing:
                raise HTTPException(status_code=409, detail="version already exists")
            row = MiniProgramVersionDB(
                program_id=prog.id,
                version=version,
                bundle_url=bundle_url,
                changelog_en=body.changelog_en,
                changelog_ar=body.changelog_ar,
            )
            s.add(row)
            s.commit()
            s.refresh(row)
            try:
                emit_event(
                    "miniprograms",
                    "self_version",
                    {"app_id": prog.app_id, "version": row.version},
                )
            except Exception:
                pass
            return {
                "app_id": prog.app_id,
                "version": row.version,
                "bundle_url": row.bundle_url,
                "changelog_en": row.changelog_en,
                "changelog_ar": row.changelog_ar,
                "created_at": getattr(row, "created_at", None),
            }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/mini_programs/{app_id}/releases", response_class=JSONResponse)
def mini_program_release(
    app_id: str, request: Request, body: MiniProgramReleaseIn
) -> dict[str, Any]:
    """
    Markiert eine Version als freigegeben (admin only).

    Für das MVP hängt der Client nicht direkt an Releases – die Daten
    dienen in erster Linie als WeChat‑ähnliches Backoffice‑Tracking.
    """
    _require_admin_v2(request)
    app_id_clean = (app_id or "").strip()
    if not app_id_clean:
        raise HTTPException(status_code=400, detail="app_id required")
    version_str = (body.version or "").strip()
    if not version_str:
        raise HTTPException(status_code=400, detail="version required")
    channel = (body.channel or "prod").strip() or "prod"
    try:
        with _officials_session() as s:
            prog = (
                s.execute(
                    _sa_select(MiniProgramDB).where(
                        MiniProgramDB.app_id == app_id_clean
                    )
                )
                .scalars()
                .first()
            )
            if not prog:
                raise HTTPException(status_code=404, detail="mini-program not found")
            ver = (
                s.execute(
                    _sa_select(MiniProgramVersionDB).where(
                        MiniProgramVersionDB.program_id == prog.id,
                        MiniProgramVersionDB.version == version_str,
                    )
                )
                .scalars()
                .first()
            )
            if not ver:
                raise HTTPException(status_code=404, detail="version not found")
            rel = MiniProgramReleaseDB(
                program_id=prog.id,
                version_id=ver.id,
                channel=channel,
                status="active",
            )
            s.add(rel)
            try:
                prog.status = "active"
                s.add(prog)
            except Exception:
                pass
            s.commit()
            s.refresh(rel)
            return {
                "app_id": prog.app_id,
                "version": ver.version,
                "channel": rel.channel,
                "status": rel.status,
            }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/mini_programs/{app_id}/track_open", response_class=JSONResponse)
async def mini_program_track_open(app_id: str, request: Request) -> dict[str, Any]:
    """
    Lightweight Tracking-Endpoint für Mini-Program-Opens (WeChat-like analytics).

    Erhöht usage_score für die gegebene app_id – wird vom Client bei
    jedem Öffnen eines Mini-Programms best-effort aufgerufen.
    """
    app_id_clean = (app_id or "").strip()
    if not app_id_clean:
        raise HTTPException(status_code=400, detail="app_id required")
    try:
        with _officials_session() as s:
            row = (
                s.execute(
                    _sa_select(MiniProgramDB).where(
                        MiniProgramDB.app_id == app_id_clean
                    )
                )
                .scalars()
                .first()
            )
            if not row:
                # Unknown app_id – silently ignore so Client-Aufrufe nicht brechen.
                return {"status": "ignored"}
            try:
                current = int(getattr(row, "usage_score", 0) or 0)
            except Exception:
                current = 0
            row.usage_score = current + 1
            s.add(row)
            s.commit()
        try:
            emit_event(
                "miniprograms",
                "open",
                {"app_id": app_id_clean},
            )
        except Exception:
            pass
        return {"status": "ok"}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/mini_programs/{app_id}/moments_stats", response_class=JSONResponse)
def mini_program_moments_stats(app_id: str) -> dict[str, Any]:
    """
    Moments-Analytics für ein einzelnes Mini‑Program auf App‑Ebene.

    Liefert Gesamt‑Shares, 30‑Tage‑Shares, Unique‑Sharers und eine
    einfache Tageskurve für die letzten 30 Tage – WeChat‑ähnlich.
    """
    app_id_clean = (app_id or "").strip()
    if not app_id_clean:
        raise HTTPException(status_code=400, detail="app_id required")
    try:
        # Sicherstellen, dass das Mini‑Program existiert – so können wir
        # 404 für Tippfehler liefern statt leere Stats.
        with _officials_session() as s:
            prog = (
                s.execute(
                    _sa_select(MiniProgramDB).where(
                        MiniProgramDB.app_id == app_id_clean
                    )
                )
                .scalars()
                .first()
            )
            if not prog:
                raise HTTPException(status_code=404, detail="mini-program not found")

        pattern = f"shamell://mini_program/{app_id_clean}"
        total = 0
        total_30d = 0
        uniq_total = 0
        uniq_30d = 0
        series_30d: list[dict[str, Any]] = []
        try:
            since_30d = datetime.now(timezone.utc) - timedelta(days=30)
            with _moments_session() as ms:
                base_filter = MomentPostDB.text.contains(pattern)
                # All-time total shares
                total = (
                    ms.execute(
                        _sa_select(_sa_func.count(MomentPostDB.id)).where(
                            base_filter
                        )
                    )
                    .scalar()
                    or 0
                )
                # 30d shares
                total_30d = (
                    ms.execute(
                        _sa_select(_sa_func.count(MomentPostDB.id)).where(
                            base_filter, MomentPostDB.created_at >= since_30d
                        )
                    )
                    .scalar()
                    or 0
                )
                # Unique sharers all-time
                uniq_total = (
                    ms.execute(
                        _sa_select(
                            _sa_func.count(
                                _sa_func.distinct(MomentPostDB.user_key)
                            )
                        ).where(base_filter)
                    )
                    .scalar()
                    or 0
                )
                # Unique sharers 30d
                uniq_30d = (
                    ms.execute(
                        _sa_select(
                            _sa_func.count(
                                _sa_func.distinct(MomentPostDB.user_key)
                            )
                        ).where(
                            base_filter, MomentPostDB.created_at >= since_30d
                        )
                    )
                    .scalar()
                    or 0
                )
                # Daily curve for last 30 days
                rows = (
                    ms.execute(
                        _sa_select(
                            _sa_func.date(MomentPostDB.created_at),
                            _sa_func.count(MomentPostDB.id),
                        )
                        .where(base_filter, MomentPostDB.created_at >= since_30d)
                        .group_by(_sa_func.date(MomentPostDB.created_at))
                        .order_by(_sa_func.date(MomentPostDB.created_at))
                    )
                    .all()
                )
                for d, cnt in rows:
                    try:
                        if isinstance(d, datetime):
                            date_str = d.date().isoformat()
                        else:
                            date_str = str(d)
                    except Exception:
                        date_str = str(d)
                    series_30d.append(
                        {
                            "date": date_str,
                            "shares": int(cnt or 0),
                        }
                    )
        except Exception:
            total = 0
            total_30d = 0
            uniq_total = 0
            uniq_30d = 0
            series_30d = []

        return {
            "app_id": app_id_clean,
            "shares_total": int(total or 0),
            "shares_30d": int(total_30d or 0),
            "unique_sharers_total": int(uniq_total or 0),
            "unique_sharers_30d": int(uniq_30d or 0),
            "series_30d": series_30d,
        }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/mini_programs/{app_id}/rate", response_class=JSONResponse)
async def mini_program_rate(
    app_id: str, request: Request, body: MiniProgramRatingIn
) -> dict[str, Any]:
    """
    Simple rating endpoint for Mini‑Programs (1–5 stars per user).

    Spiegelbild zu /mini_apps/{id}/rate, nutzt sa_cookie
    als user_key und hält MiniProgramDB.rating synchron.
    """
    app_id_clean = (app_id or "").strip()
    if not app_id_clean:
        raise HTTPException(status_code=400, detail="app_id required")
    user_key = _official_cookie_key(request)
    try:
        val = int(body.rating)
    except Exception:
        val = 0
    if val < 1:
        val = 1
    if val > 5:
        val = 5
    try:
        with _officials_session() as s:
            prog_row = (
                s.execute(
                    _sa_select(MiniProgramDB).where(
                        MiniProgramDB.app_id == app_id_clean
                    )
                )
                .scalars()
                .first()
            )
            if not prog_row:
                raise HTTPException(status_code=404, detail="mini-program not found")
            existing = (
                s.execute(
                    _sa_select(MiniProgramRatingDB).where(
                        MiniProgramRatingDB.app_id == app_id_clean,
                        MiniProgramRatingDB.user_key == user_key,
                    )
                )
                .scalars()
                .first()
            )
            if existing:
                existing.rating = val
                s.add(existing)
            else:
                rec = MiniProgramRatingDB(
                    app_id=app_id_clean, user_key=user_key, rating=val
                )
                s.add(rec)
            s.commit()
            avg_rating = 0.0
            rating_count = 0
            try:
                avg_row = (
                    s.execute(
                        _sa_select(
                            _sa_func.avg(MiniProgramRatingDB.rating),
                            _sa_func.count(MiniProgramRatingDB.id),
                        ).where(MiniProgramRatingDB.app_id == app_id_clean)
                    )
                    .first()
                )
                if avg_row:
                    avg_rating = float(avg_row[0] or 0.0)
                    rating_count = int(avg_row[1] or 0)
            except Exception:
                avg_rating = 0.0
                rating_count = 0
            try:
                prog_row.rating = avg_rating
                s.add(prog_row)
                s.commit()
            except Exception:
                s.rollback()
        try:
            emit_event(
                "miniprograms",
                "rate",
                {"app_id": app_id_clean, "user_key": user_key, "rating": val},
            )
        except Exception:
            pass
        return {"status": "ok", "rating": avg_rating, "count": rating_count}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/mini_apps", response_class=JSONResponse)
async def list_mini_apps() -> dict[str, Any]:
    """
    Öffentlicher JSON-Katalog für Mini-Apps (Mini-Programme).

    Wird vom Flutter-Client genutzt, um dynamische Mini-Apps (inkl. Partner)
    anzuzeigen – analog zum statischen `kMiniApps`-Registry in der App.
    """
    try:
        with _officials_session() as s:
            rows = (
                s.execute(
                    _sa_select(MiniAppDB).where(MiniAppDB.enabled == True)  # type: ignore[comparison-overlap]
                )
                .scalars()
                .all()
            )
            app_ids = [row.app_id for row in rows]
            ratings_map: dict[str, tuple[float, int]] = {}
            if app_ids:
                agg_rows = (
                    s.execute(
                        _sa_select(
                            MiniAppRatingDB.app_id,
                            _sa_func.avg(MiniAppRatingDB.rating),
                            _sa_func.count(MiniAppRatingDB.id),
                        )
                        .where(MiniAppRatingDB.app_id.in_(app_ids))
                        .group_by(MiniAppRatingDB.app_id)
                    )
                    .all()
                )
                for app_id, avg_val, cnt_val in agg_rows:
                    try:
                        ratings_map[str(app_id)] = (
                            float(avg_val or 0.0),
                            int(cnt_val or 0),
                        )
                    except Exception:
                        continue
            # Best-effort Moments share counts per Mini-App based on
            # shamell://miniapp/<id> deep-links in Moments posts.
            moments_shares: dict[str, int] = {}
            try:
                if app_ids:
                    with _moments_session() as ms:
                        for app_id in app_ids:
                            try:
                                pattern = f"shamell://miniapp/{app_id}"
                                cnt = (
                                    ms.execute(
                                        _sa_select(
                                            _sa_func.count(MomentPostDB.id)
                                        ).where(
                                            MomentPostDB.text.contains(
                                                pattern
                                            )
                                        )
                                    )
                                    .scalar()
                                    or 0
                                )
                                moments_shares[str(app_id)] = int(cnt or 0)
                            except Exception:
                                continue
            except Exception:
                moments_shares = {}

            apps: list[dict[str, Any]] = []
            for row in rows:
                avg_rating, rating_count = ratings_map.get(
                    row.app_id, (float(getattr(row, "rating", 0.0) or 0.0), 0)
                )
                try:
                    moments_count = int(
                        moments_shares.get(row.app_id, 0)
                        or getattr(row, "moments_shares", 0)
                        or 0
                    )
                except Exception:
                    moments_count = 0
                apps.append(
                    {
                        "id": row.app_id,
                        "title_en": row.title_en,
                        "title_ar": row.title_ar,
                        "category_en": row.category_en,
                        "category_ar": row.category_ar,
                        "description": row.description,
                        "icon": row.icon,
                        "official": bool(getattr(row, "official", False)),
                        "beta": bool(getattr(row, "beta", False)),
                        "runtime_app_id": getattr(row, "runtime_app_id", None),
                        "rating": float(avg_rating),
                        "rating_count": int(rating_count),
                        "usage_score": int(
                            getattr(row, "usage_score", 0) or 0
                        ),
                        "moments_shares": moments_count,
                    }
                )
        return {"apps": apps}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/mini_apps/developer", response_class=HTMLResponse)
def mini_apps_developer_landing(request: Request) -> HTMLResponse:
    """
    Lightweight Developer-Landing für Mini-Apps (Mini-Programme).

    Beschreibt kurz das Mini-Program-Ökosystem von Shamell und
    verweist auf die Admin-Konsole für Registrierung & Partner-Setup.
    """
    base = request.base_url._url.rstrip("/")  # type: ignore[attr-defined]
    html = f"""
<!doctype html>
<html><head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Shamell · Mini‑Apps developer</title>
  <style>
    body{{font-family:sans-serif;margin:20px;max-width:880px;color:#0f172a;line-height:1.5;}}
    h1{{margin-bottom:4px;}}
    h2{{margin-top:20px;margin-bottom:6px;}}
    p{{margin:4px 0;}}
    code{{background:#f3f4f6;padding:2px 4px;border-radius:3px;font-size:12px;}}
    .muted{{color:#6b7280;font-size:13px;}}
    ul{{padding-left:20px;}}
  </style>
</head><body>
  <h1>Mini‑Apps · Developer overview</h1>
  <p class="muted">
    Shamell Mini‑Apps sind WeChat‑ähnliche Mini‑Programme, die direkt im
    Super‑App‑Shell laufen (Discover‑Strip, Mirsaal, Moments).
  </p>

  <h2>Ökosystem</h2>
  <ul>
    <li><strong>Katalog &amp; Suche:</strong> <code>/mini_apps</code> liefert einen öffentlichen JSON‑Katalog.</li>
    <li><strong>Trending &amp; Analytics:</strong> <code>usage_score</code>, <code>rating</code> und
      <code>moments_shares</code> steuern die Sortierung im Mini‑Apps‑Tab.</li>
    <li><strong>Moments‑Integration:</strong> Mini‑Apps lassen sich direkt in Moments teilen
      (Deep‑Links <code>shamell://miniapp/&lt;id&gt;</code>, Hashtags wie <code>#ShamellMiniApp</code>).</li>
  </ul>

  <h2>Drittanbieter‑Registrierung</h2>
  <p>
    Die eigentliche Anlage und Pflege von Mini‑Apps erfolgt über die
    Admin‑Konsole (nur für Ops/Partner‑Team zugänglich):
  </p>
  <ul>
    <li><code>{base}/admin/miniapps</code> – JSON &amp; HTML Konsole für Anlage/Bearbeitung.</li>
    <li><code>{base}/admin/miniapps/analytics</code> – einfache Analytics‑Übersicht.</li>
  </ul>
  <p class="muted">
    In Produktionsumgebungen sollte die Konsole nur über VPN/Backoffice erreichbar sein.
  </p>

  <h2>Client‑Integration</h2>
  <p>Ein Mini‑App Eintrag besteht typischerweise aus:</p>
  <ul>
    <li><code>app_id</code> (z.B. <code>taxi_rider</code>)</li>
    <li><code>title_en</code>, <code>title_ar</code></li>
    <li><code>category_en</code>, <code>category_ar</code></li>
    <li>optional: <code>icon</code>, <code>official</code>, <code>beta</code></li>
  </ul>
  <p>
    Die Flutter‑Shell mappt <code>app_id</code> auf konkrete Routen (z.B. Taxi, Food,
    Stays, Wallet) und ruft beim Öffnen best‑effort
    <code>POST /mini_apps/&lt;id&gt;/track_open</code> auf.
  </p>

  <p class="muted">
    Hinweis: Diese Seite ist rein informativ. Schreibende Aktionen (Anlage,
    Editieren, Deaktivieren) laufen ausschließlich über die Admin‑Konsole.
  </p>
</body></html>
"""
    return HTMLResponse(content=html)


@app.get("/mini_programs/developer", response_class=HTMLResponse)
def mini_programs_developer_landing(request: Request) -> HTMLResponse:
    """
    Lightweight Developer-Landing für Mini-Programs.

    Spiegelt die Mini-Apps-Developer-Seite, beschreibt aber
    explizit das API-basierte Mini-Program-Ökosystem.
    """
    base = request.base_url._url.rstrip("/")  # type: ignore[attr-defined]
    phone = _auth_phone(request)
    if not phone:
        return RedirectResponse(url="/login", status_code=303)
    html = f"""
<!doctype html>
<html><head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Shamell · Mini‑programs developer</title>
  <style>
    body{{font-family:sans-serif;margin:20px;max-width:880px;color:#0f172a;line-height:1.5;}}
    h1{{margin-bottom:4px;}}
    h2{{margin-top:20px;margin-bottom:6px;}}
    p{{margin:4px 0;}}
    code{{background:#f3f4f6;padding:2px 4px;border-radius:3px;font-size:12px;}}
    .muted{{color:#6b7280;font-size:13px;}}
    ul{{padding-left:20px;}}
    table{{border-collapse:collapse;width:100%;margin-top:8px;font-size:13px;}}
    th,td{{border:1px solid #e5e7eb;padding:4px 6px;text-align:left;vertical-align:top;}}
    th{{background:#f9fafb;font-weight:600;}}
    .pill{{display:inline-block;padding:1px 6px;border-radius:999px;font-size:11px;}}
    .pill-status-active{{background:#dcfce7;color:#166534;}}
    .pill-status-draft{{background:#fef3c7;color:#92400e;}}
    .pill-status-disabled{{background:#fee2e2;color:#991b1b;}}
    .pill-trending{{background:#eff6ff;color:#1d4ed8;margin-left:4px;}}
    .small{{font-size:12px;}}
  </style>
</head><body>
  <h1>Mini‑Programs · Developer overview</h1>
  <p class="muted">
    Shamell Mini‑Programs sind WeChat‑ähnliche Mini‑Apps, die per Manifest
    über <code>/mini_programs/&lt;id&gt;</code> beschrieben werden und im Shamell‑Shell
    laufen (Discover‑Strip, Mini‑Apps‑Kacheln, Deep‑Links).
  </p>

  <h2>Ökosystem</h2>
  <ul>
    <li><strong>Katalog &amp; Suche:</strong> <code>/mini_programs</code> liefert einen öffentlichen JSON‑Katalog mit
      <code>app_id</code>, Titel, Owner, Status, <code>usage_score</code> und Rating.</li>
    <li><strong>Trending &amp; Analytics:</strong> <code>usage_score</code> (Track via
      <code>POST /mini_programs/&lt;id&gt;/track_open</code>) und Rating steuern Sortierung
      in Suche und Directory; HTML‑Analytics: <code>{base}/admin/mini_programs/analytics</code>.</li>
    <li><strong>Runtime‑Manifest:</strong> <code>/mini_programs/&lt;id&gt;</code> liefert Titel,
      Beschreibungen und Actions‑Liste (Buttons) für die Flutter‑Runtime.</li>
  </ul>

  <h2>Drittanbieter‑Registrierung (Self‑Service)</h2>
  <p>
    Als eingeloggter Entwickler (<code>{phone}</code>) kannst du eigene Mini‑Programme
    registrieren. Neue Einträge starten immer im Status <code>draft</code> und
    können später vom Shamell‑Team geprüft und aktiviert werden.
  </p>
  <h3>Eigene Mini‑Programs</h3>
  <p class="muted">
    JSON‑Übersicht deiner Einträge:
    <code>{base}/mini_programs/developer_json</code>
  </p>
  <div id="dev_flash" class="muted"></div>
  <table>
    <thead>
      <tr>
        <th>App‑ID</th>
        <th>Title</th>
        <th>Status</th>
        <th>Review</th>
        <th>Scopes</th>
        <th>Rating</th>
        <th>Usage</th>
        <th>Last version</th>
        <th>Links</th>
      </tr>
    </thead>
    <tbody id="dev_programs_body">
      <tr><td colspan="9" class="small">Lade deine Mini‑Programs…</td></tr>
    </tbody>
  </table>

  <h3>Neues Mini‑Program registrieren</h3>
  <p>Minimaler JSON‑Call (z.B. via <code>curl</code>):</p>
  <pre><code>POST {base}/mini_programs/self_register
Content-Type: application/json
sa_cookie: &lt;your_sa_session&gt;

{{
  "app_id": "my_cool_app",
  "title_en": "My cool Mini‑Program",
  "title_ar": "تطبيقي المصغر الرائع",
  "description_en": "Short description of my service",
  "owner_name": "Your company",
  "owner_contact": "{phone}"
}}</code></pre>
  <p class="muted">
    Hinweis: <code>owner_contact</code> wird automatisch mit deiner Telefonnummer
    vorbelegt, wenn du keinen Wert angibst. Nur dieser Kontakt darf das
    Mini‑Program später per Self‑Service aktualisieren.
  </p>

  <h3>Versionen vorschlagen</h3>
  <p>
    Optional kannst du eine oder mehrere Versionen mit Bundles registrieren.
    Die Veröffentlichung (Release) erfolgt weiterhin über das Ops‑Team.
  </p>
  <pre><code>POST {base}/mini_programs/my_cool_app/versions/self_register
Content-Type: application/json
sa_cookie: &lt;your_sa_session&gt;

{{
  "version": "1.0.0",
  "bundle_url": "https://example.com/bundles/my_cool_app-1.0.0.zip",
  "changelog_en": "Initial public version"
}}</code></pre>

  <p class="muted">
    Für produktive Freischaltung kann das Ops‑Team später einen Release
    über <code>/mini_programs/&lt;id&gt;/releases</code> anlegen (Admin‑Konsole /
    Backoffice‑APIs).
  </p>

  <h2>Client‑Integration</h2>
  <p>Ein Mini‑Program‑Eintrag besteht typischerweise aus:</p>
  <ul>
    <li><code>app_id</code> (z.B. <code>taxi_demo</code>)</li>
    <li><code>title_en</code>, <code>title_ar</code></li>
    <li>optional: <code>description_en</code>, <code>description_ar</code></li>
    <li>Owner‑Metadaten: <code>owner_name</code>, <code>owner_contact</code></li>
    <li>optionale <code>actions</code> (Buttons) mit <code>kind=open_mod|open_url|close</code>.</li>
  </ul>
  <p>
    Die Flutter‑Shell lädt das Manifest aus <code>/mini_programs/&lt;id&gt;</code> und rendert
    Buttons, die entweder interne Module (<code>open_mod</code>) oder externe URLs
    (<code>open_url</code>) öffnen – ähnlich zu WeChat Mini‑Programs.
  </p>

  <p class="muted">
    Hinweis: Diese Seite kombiniert Self‑Service‑Calls für Entwickler mit
    klassischen Admin‑Konsole‑Flows. In Produktionsumgebungen sollte die
    Admin‑Konsole weiterhin nur über VPN/Backoffice erreichbar sein.
  </p>
  <script>
    async function loadDeveloperPrograms() {{
      const tbody = document.getElementById('dev_programs_body');
      const flash = document.getElementById('dev_flash');
      if (!tbody) return;
      tbody.innerHTML = '<tr><td colspan="7" class="small">Lade deine Mini‑Programs…</td></tr>';
      flash.textContent = '';
      try {{
        const r = await fetch('/mini_programs/developer_json');
        if (!r.ok) {{
          tbody.innerHTML = '<tr><td colspan="7" class="small">Konnte Mini‑Programs nicht laden (HTTP ' + r.status + ').</td></tr>';
          return;
        }}
        const data = await r.json();
        const items = Array.isArray(data.programs) ? data.programs : [];
        if (!items.length) {{
          tbody.innerHTML = '<tr><td colspan="7" class="small">Noch keine eigenen Mini‑Programs registriert.</td></tr>';
          return;
        }}
        tbody.innerHTML = '';
        for (const p of items) {{
          const tr = document.createElement('tr');
          const appId = (p.app_id || '').toString();
          const titleEn = (p.title_en || '').toString();
          const titleAr = (p.title_ar || '').toString();
          const status = (p.status || '').toString();
          const reviewStatus = (p.review_status || 'draft').toString();
          const scopes = Array.isArray(p.scopes) ? p.scopes : [];
          const rating = typeof p.rating === 'number' ? p.rating : 0;
          const usage = typeof p.usage_score === 'number' ? p.usage_score : 0;
          const lastVersion = (p.last_version || '').toString();
          const lastBundle = (p.last_bundle_url || '').toString();
          let statusClass = '';
          if (status === 'active') {{
            statusClass = 'pill-status-active';
          }} else if (status === 'draft') {{
            statusClass = 'pill-status-draft';
          }} else if (status === 'disabled') {{
            statusClass = 'pill-status-disabled';
          }}
          let trending = false;
          if (status === 'active') {{
            if (usage >= 50 || rating >= 4.5) {{
              trending = true;
            }}
          }}
          // App‑ID
          const tdId = document.createElement('td');
          tdId.textContent = appId || '–';
          tr.appendChild(tdId);
          // Title
          const tdTitle = document.createElement('td');
          tdTitle.textContent = titleEn || titleAr || '–';
          tr.appendChild(tdTitle);
          let reviewClass = 'pill-status-draft';
          const rs = reviewStatus.toLowerCase();
          if (rs === 'approved') reviewClass = 'pill-status-active';
          else if (rs === 'rejected' || rs === 'suspended') reviewClass = 'pill-status-disabled';
          // Status + trending
          const tdStatus = document.createElement('td');
          if (status) {{
            const span = document.createElement('span');
            span.className = 'pill ' + statusClass;
            span.textContent = status;
            tdStatus.appendChild(span);
          }} else {{
            tdStatus.textContent = '–';
          }}
          if (trending) {{
            const spanTr = document.createElement('span');
            spanTr.className = 'pill pill-trending';
            spanTr.textContent = 'Trending';
            tdStatus.appendChild(spanTr);
          }}
          tr.appendChild(tdStatus);
          const tdReview = document.createElement('td');
          const spanRv = document.createElement('span');
          spanRv.className = 'pill ' + reviewClass;
          spanRv.textContent = reviewStatus;
          tdReview.appendChild(spanRv);
          tr.appendChild(tdReview);
          // Rating
          const tdRating = document.createElement('td');
          if (rating > 0) {{
            tdRating.textContent = rating.toFixed(1) + ' ★';
          }} else {{
            tdRating.textContent = '–';
          }}
          tr.appendChild(tdRating);
          // Usage
          const tdUsage = document.createElement('td');
          tdUsage.textContent = usage > 0 ? String(usage) : '–';
          tr.appendChild(tdUsage);
          // Scopes
          const tdScopes = document.createElement('td');
          if (scopes.length) {{
            tdScopes.className = 'small';
            tdScopes.innerHTML = scopes.map(s => '<code>' + String(s) + '</code>').join(' ');
          }} else {{
            tdScopes.innerHTML = '<span class="small muted">–</span>';
          }}
          tr.appendChild(tdScopes);
          // Last version
          const tdVer = document.createElement('td');
          if (lastVersion) {{
            tdVer.textContent = lastVersion;
          }} else {{
            tdVer.textContent = '–';
          }}
          tr.appendChild(tdVer);
          // Links
          const tdLinks = document.createElement('td');
          tdLinks.className = 'small';
          if (appId) {{
            const aManifest = document.createElement('a');
            aManifest.href = '{base}/mini_programs/' + encodeURIComponent(appId);
            aManifest.textContent = 'Manifest';
            aManifest.target = '_blank';
            tdLinks.appendChild(aManifest);
          }}
          if (lastBundle) {{
            const spanSep = document.createTextNode(' · ');
            tdLinks.appendChild(spanSep);
            const aBundle = document.createElement('a');
            aBundle.href = lastBundle;
            aBundle.textContent = 'Bundle';
            aBundle.target = '_blank';
            tdLinks.appendChild(aBundle);
          }}
          tr.appendChild(tdLinks);
          tbody.appendChild(tr);
        }}
      }} catch (e) {{
        tbody.innerHTML = '<tr><td colspan=\"7\" class=\"small\">Fehler beim Laden deiner Mini‑Programs.</td></tr>';
        flash.textContent = String(e);
      }}
    }}
    document.addEventListener('DOMContentLoaded', loadDeveloperPrograms);
  </script>
</body></html>
"""
    return HTMLResponse(content=html)


@app.get("/mini_programs/developer_json", response_class=JSONResponse)
def mini_programs_developer_json(request: Request) -> dict[str, Any]:
    """
    JSON‑Übersicht aller Mini‑Programs, die dem eingeloggten Entwickler gehören.

    Ownership wird über MiniProgramDB.owner_contact (Telefonnummer) abgebildet.
    """
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="auth required")
    contact = phone.strip()
    try:
        with _officials_session() as s:
            stmt = _sa_select(MiniProgramDB).order_by(MiniProgramDB.app_id)
            if contact:
                stmt = stmt.where(MiniProgramDB.owner_contact == contact)
            rows = s.execute(stmt).scalars().all()
            if not rows:
                return {"programs": []}
            prog_ids = [r.id for r in rows if getattr(r, "id", None) is not None]
            versions_map: dict[int, list[MiniProgramVersionDB]] = {}
            if prog_ids:
                try:
                    v_rows = (
                        s.execute(
                            _sa_select(MiniProgramVersionDB)
                            .where(MiniProgramVersionDB.program_id.in_(prog_ids))
                            .order_by(
                                MiniProgramVersionDB.program_id.asc(),
                                MiniProgramVersionDB.created_at.desc(),
                                MiniProgramVersionDB.id.desc(),
                            )
                        )
                        .scalars()
                        .all()
                    )
                    for v in v_rows:
                        pid = getattr(v, "program_id", None)
                        if pid is None:
                            continue
                        versions_map.setdefault(int(pid), []).append(v)
                except Exception:
                    versions_map = {}
            # Best-effort Moments share counts per Mini-Program based on
            # shamell://mini_program/<id> deep-links in Moments posts.
            moments_shares: dict[str, int] = {}
            moments_shares_30d: dict[str, int] = {}
            try:
                app_ids = [r.app_id for r in rows]
                if app_ids:
                    with _moments_session() as ms:
                        since_30d = datetime.now(timezone.utc) - timedelta(days=30)
                        for app_id in app_ids:
                            try:
                                pattern = f"shamell://mini_program/{app_id}"
                                base_stmt = _sa_select(
                                    _sa_func.count(MomentPostDB.id)
                                ).where(MomentPostDB.text.contains(pattern))
                                cnt_all = ms.execute(base_stmt).scalar() or 0
                                cnt_30 = (
                                    ms.execute(
                                        base_stmt.where(
                                            MomentPostDB.created_at >= since_30d
                                        )
                                    ).scalar()
                                    or 0
                                )
                                moments_shares[str(app_id)] = int(cnt_all or 0)
                                moments_shares_30d[str(app_id)] = int(cnt_30 or 0)
                            except Exception:
                                continue
            except Exception:
                moments_shares = {}
                moments_shares_30d = {}

            items: list[dict[str, Any]] = []
            for prog in rows:
                scopes_list: list[str] = []
                try:
                    raw_scopes = getattr(prog, "scopes_json", None)
                    if raw_scopes:
                        val = _json.loads(raw_scopes)
                        if isinstance(val, list):
                            scopes_list = [
                                str(s).strip() for s in val if str(s).strip()
                            ]
                except Exception:
                    scopes_list = []
                pid = getattr(prog, "id", None)
                vers = versions_map.get(int(pid)) if pid is not None else None
                last_ver: MiniProgramVersionDB | None = vers[0] if vers else None
                last_version = getattr(last_ver, "version", None) if last_ver else None
                last_bundle_url = getattr(last_ver, "bundle_url", None) if last_ver else None
                try:
                    moments_count = int(
                        moments_shares.get(prog.app_id, 0)
                        or getattr(prog, "moments_shares", 0)
                        or 0
                    )
                except Exception:
                    moments_count = 0
                try:
                    moments_30 = int(
                        moments_shares_30d.get(prog.app_id, 0) or 0
                    )
                except Exception:
                    moments_30 = 0
                items.append(
                    {
                        "app_id": prog.app_id,
                        "title_en": prog.title_en,
                        "title_ar": prog.title_ar,
                        "description_en": getattr(prog, "description_en", None),
                        "description_ar": getattr(prog, "description_ar", None),
                        "owner_name": prog.owner_name,
                        "owner_contact": prog.owner_contact,
                        "status": prog.status,
                        "usage_score": int(getattr(prog, "usage_score", 0) or 0),
                        "rating": float(getattr(prog, "rating", 0.0) or 0.0),
                        "moments_shares": moments_count,
                        "moments_shares_30d": moments_30,
                        "review_status": getattr(prog, "review_status", "draft"),
                        "scopes": scopes_list,
                        "last_version": last_version,
                        "last_bundle_url": last_bundle_url,
                        "created_at": getattr(prog, "created_at", None),
                        "updated_at": getattr(prog, "updated_at", None),
                    }
                )
        return {"programs": items}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/mini_apps/{app_id}/track_open", response_class=JSONResponse)
async def mini_app_track_open(app_id: str, request: Request) -> dict[str, Any]:
    """
    Lightweight Tracking-Endpoint für Mini-App-Opens (WeChat-like analytics).

    Erhöht usage_score für die gegebene app_id – wird vom Client bei
    jedem Öffnen einer Mini-App (Mini-Program) best-effort aufgerufen.
    """
    app_id_clean = (app_id or "").strip()
    if not app_id_clean:
        raise HTTPException(status_code=400, detail="app_id required")
    try:
        with _officials_session() as s:
            row = (
                s.execute(
                    _sa_select(MiniAppDB).where(MiniAppDB.app_id == app_id_clean)
                )
                .scalars()
                .first()
            )
            if not row:
                # Unknown app_id – silently ignore so Client-Aufrufe nicht brechen.
                return {"status": "ignored"}
            try:
                current = int(getattr(row, "usage_score", 0) or 0)
            except Exception:
                current = 0
            row.usage_score = current + 1
            s.add(row)
            s.commit()
        try:
            emit_event(
                "miniapps",
                "open",
                {"app_id": app_id_clean},
            )
        except Exception:
            pass
        return {"status": "ok"}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/mini_apps/{app_id}/rate", response_class=JSONResponse)
async def mini_app_rate(app_id: str, request: Request, body: MiniAppRatingIn) -> dict[str, Any]:
    """
    Simple rating endpoint for Mini-Apps (1–5 stars per user).

    Persists a per-user rating (sa_cookie-based) and updates the
    aggregated rating on the MiniAppDB row, similar to WeChat
    Mini-Program ratings.
    """
    app_id_clean = (app_id or "").strip()
    if not app_id_clean:
        raise HTTPException(status_code=400, detail="app_id required")
    user_key = _official_cookie_key(request)
    try:
        val = int(body.rating)
    except Exception:
        val = 0
    if val < 1:
        val = 1
    if val > 5:
        val = 5
    try:
        with _officials_session() as s:
            app_row = (
                s.execute(
                    _sa_select(MiniAppDB).where(MiniAppDB.app_id == app_id_clean)
                )
                .scalars()
                .first()
            )
            if not app_row or not bool(getattr(app_row, "enabled", True)):
                raise HTTPException(status_code=404, detail="mini-app not found")
            existing = (
                s.execute(
                    _sa_select(MiniAppRatingDB).where(
                        MiniAppRatingDB.app_id == app_id_clean,
                        MiniAppRatingDB.user_key == user_key,
                    )
                )
                .scalars()
                .first()
            )
            if existing:
                existing.rating = val
                s.add(existing)
            else:
                rec = MiniAppRatingDB(app_id=app_id_clean, user_key=user_key, rating=val)
                s.add(rec)
            s.commit()
            avg_rating = 0.0
            rating_count = 0
            try:
                avg_row = (
                    s.execute(
                        _sa_select(
                            _sa_func.avg(MiniAppRatingDB.rating),
                            _sa_func.count(MiniAppRatingDB.id),
                        ).where(MiniAppRatingDB.app_id == app_id_clean)
                    )
                    .first()
                )
                if avg_row:
                    avg_rating = float(avg_row[0] or 0.0)
                    rating_count = int(avg_row[1] or 0)
            except Exception:
                avg_rating = 0.0
                rating_count = 0
            try:
                app_row.rating = avg_rating
                s.add(app_row)
                s.commit()
            except Exception:
                s.rollback()
        try:
            emit_event(
                "miniapps",
                "rate",
                {"app_id": app_id_clean, "user_key": user_key, "rating": val},
            )
        except Exception:
            pass
        return {"status": "ok", "rating": avg_rating, "count": rating_count}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/admin/miniapps/analytics", response_class=HTMLResponse)
def admin_miniapps_analytics(request: Request) -> HTMLResponse:
    """
    Lightweight HTML analytics für Mini-Apps (Mini-Programme).

    Nutzt usage_score und rating als einfache KPIs – ähnlich zu WeChat
    Mini-Program "popular" / "top" Rankings.
    """
    _require_admin_v2(request)
    try:
      with _officials_session() as s:
          rows = (
              s.execute(
                  _sa_select(MiniAppDB).order_by(
                      MiniAppDB.usage_score.desc(), MiniAppDB.rating.desc()
                  )
              )
              .scalars()
              .all()
          )
      total_usage = 0
      for row in rows:
          try:
              total_usage += int(getattr(row, "usage_score", 0) or 0)
          except Exception:
              continue

      def esc(s: str) -> str:
          return (
              s.replace("&", "&amp;")
              .replace("<", "&lt;")
              .replace(">", "&gt;")
          )

      rows_html: list[str] = []
      for row in rows:
          app_id = row.app_id
          title_en = row.title_en or ""
          title_ar = row.title_ar or ""
          cat = " / ".join(
              [
                  c
                  for c in [
                      getattr(row, "category_en", None) or "",
                      getattr(row, "category_ar", None) or "",
                  ]
                  if c
              ]
          )
          official = bool(getattr(row, "official", False))
          enabled = bool(getattr(row, "enabled", True))
          beta = bool(getattr(row, "beta", False))
          try:
              rating = float(getattr(row, "rating", 0.0) or 0.0)
          except Exception:
              rating = 0.0
          try:
              usage = int(getattr(row, "usage_score", 0) or 0)
          except Exception:
              usage = 0
          share = 0.0
          if total_usage > 0 and usage > 0:
              try:
                  share = (usage / float(total_usage)) * 100.0
              except Exception:
                  share = 0.0
          status_bits: list[str] = []
          if official:
              status_bits.append("official")
          if beta:
              status_bits.append("beta")
          if not enabled:
              status_bits.append("disabled")
          status = ", ".join(status_bits) if status_bits else ""
          rows_html.append(
              "<tr>"
              f"<td><code>{esc(app_id)}</code></td>"
              f"<td>{esc(title_en)}<br/><span class=\"meta\">{esc(title_ar)}</span></td>"
              f"<td>{esc(cat)}</td>"
              f"<td>{esc(status)}</td>"
              f"<td>{rating:.1f}</td>"
              f"<td>{usage}</td>"
              f"<td>{share:.1f}%</td>"
              "</tr>"
          )

      html = f"""
<!doctype html>
<html><head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mini-Apps · Analytics</title>
  <style>
    body{{font-family:sans-serif;margin:20px;max-width:960px;color:#0f172a;}}
    h1{{margin-bottom:4px;}}
    table{{border-collapse:collapse;width:100%;margin-top:12px;}}
    th,td{{padding:6px 8px;border-bottom:1px solid #e5e7eb;font-size:13px;text-align:left;vertical-align:top;}}
    th{{background:#f9fafb;font-weight:600;}}
    .meta{{color:#6b7280;font-size:12px;margin-top:2px;}}
    code{{background:#f3f4f6;padding:2px 4px;border-radius:3px;font-size:12px;}}
  </style>
</head><body>
  <h1>Mini-Apps · Analytics</h1>
  <div class="meta">
    Basierend auf usage_score (Open-Events via /mini_apps/&lt;id&gt;/track_open) und Rating.<br/>
    Dient als einfache WeChat‑ähnliche Übersicht der beliebtesten Mini-Programme.
  </div>
  <p class="meta">
    <a href="/admin/miniapps">Zurück zur Mini-Apps-Konsole</a>
  </p>
  <table>
    <thead>
      <tr>
        <th>App ID</th>
        <th>Title</th>
        <th>Category</th>
        <th>Status</th>
        <th>Rating</th>
        <th>Usage score</th>
        <th>Share of usage</th>
      </tr>
    </thead>
    <tbody>
      {''.join(rows_html) if rows_html else '<tr><td colspan="7">No Mini-Apps registered yet.</td></tr>'}
    </tbody>
  </table>
</body></html>
"""
      return HTMLResponse(content=html)
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/admin/mini_apps", response_class=JSONResponse)
def admin_mini_apps_list(request: Request) -> dict[str, Any]:
    """
    JSON-Admin-Listing für registrierte Mini-Apps (Mini-Programme).

    Dient als Basis für ein Developer-Portal oder einfache Ops-Verwaltung.
    """
    _require_admin_v2(request)
    with _officials_session() as s:
        rows = (
            s.execute(
                _sa_select(MiniAppDB).order_by(MiniAppDB.app_id)
            )
            .scalars()
            .all()
        )
        apps: list[dict[str, Any]] = []
        for row in rows:
            apps.append(
                {
                    "app_id": row.app_id,
                    "title_en": row.title_en,
                    "title_ar": row.title_ar,
                    "category_en": row.category_en,
                    "category_ar": row.category_ar,
                    "description": row.description,
                    "icon": row.icon,
                    "official": bool(getattr(row, "official", False)),
                    "enabled": bool(getattr(row, "enabled", True)),
                    "beta": bool(getattr(row, "beta", False)),
                    "runtime_app_id": getattr(row, "runtime_app_id", None),
                    "rating": float(getattr(row, "rating", 0.0) or 0.0),
                    "usage_score": int(getattr(row, "usage_score", 0) or 0),
                    "created_at": getattr(row, "created_at", None),
                    "updated_at": getattr(row, "updated_at", None),
                }
            )
    return {"apps": apps}


@app.post("/admin/mini_apps", response_class=JSONResponse)
def admin_mini_apps_create(request: Request, body: MiniAppAdminIn) -> dict[str, Any]:
    """
    Legt eine neue Mini-App an (admin only).
    """
    _require_admin_v2(request)
    data = body
    app_id = (data.app_id or "").strip()
    if not app_id:
        raise HTTPException(status_code=400, detail="app_id required")
    with _officials_session() as s:
        existing = (
            s.execute(
                _sa_select(MiniAppDB).where(MiniAppDB.app_id == app_id)
            )
            .scalars()
            .first()
        )
        if existing:
            raise HTTPException(status_code=409, detail="mini-app already exists")
        row = MiniAppDB(
            app_id=app_id,
            title_en=data.title_en,
            title_ar=data.title_ar,
            category_en=data.category_en,
            category_ar=data.category_ar,
            description=data.description,
            icon=data.icon,
            official=data.official,
            enabled=data.enabled,
            beta=data.beta,
            runtime_app_id=data.runtime_app_id,
            rating=data.rating,
            usage_score=data.usage_score or 0,
        )
        s.add(row)
        s.commit()
        s.refresh(row)
        return {
            "app_id": row.app_id,
            "title_en": row.title_en,
            "title_ar": row.title_ar,
            "category_en": row.category_en,
            "category_ar": row.category_ar,
            "description": row.description,
            "icon": row.icon,
            "official": bool(row.official),
            "enabled": bool(row.enabled),
            "beta": bool(row.beta),
            "rating": float(row.rating or 0.0),
            "usage_score": int(row.usage_score or 0),
        }


@app.patch("/admin/mini_apps/{app_id}", response_class=JSONResponse)
def admin_mini_apps_update(
    app_id: str, request: Request, body: dict[str, Any]
) -> dict[str, Any]:
    """
    Aktualisiert Felder einer Mini-App (admin only).
    """
    _require_admin_v2(request)
    if not isinstance(body, dict):
        body = {}
    allowed_fields = {
        "title_en",
        "title_ar",
        "category_en",
        "category_ar",
        "description",
        "icon",
        "official",
        "enabled",
        "beta",
        "runtime_app_id",
        "rating",
        "usage_score",
    }
    app_id_clean = (app_id or "").strip()
    if not app_id_clean:
        raise HTTPException(status_code=400, detail="app_id required")
    with _officials_session() as s:
        row = (
            s.execute(
                _sa_select(MiniAppDB).where(MiniAppDB.app_id == app_id_clean)
            )
            .scalars()
            .first()
        )
        if not row:
            raise HTTPException(status_code=404, detail="mini-app not found")
        for k, v in body.items():
            if k in allowed_fields:
                setattr(row, k, v)
        s.add(row)
        s.commit()
        s.refresh(row)
        return {
            "app_id": row.app_id,
            "title_en": row.title_en,
            "title_ar": row.title_ar,
            "category_en": row.category_en,
            "category_ar": row.category_ar,
            "description": row.description,
            "icon": row.icon,
            "official": bool(row.official),
            "enabled": bool(row.enabled),
            "beta": bool(row.beta),
            "rating": float(row.rating or 0.0),
            "usage_score": int(row.usage_score or 0),
        }


@app.delete("/admin/mini_apps/{app_id}", response_class=JSONResponse)
def admin_mini_apps_delete(app_id: str, request: Request) -> dict[str, Any]:
    """
    Deaktiviert eine Mini-App (soft delete via enabled=False).
    """
    _require_admin_v2(request)
    app_id_clean = (app_id or "").strip()
    if not app_id_clean:
        raise HTTPException(status_code=400, detail="app_id required")
    with _officials_session() as s:
        row = (
            s.execute(
                _sa_select(MiniAppDB).where(MiniAppDB.app_id == app_id_clean)
            )
            .scalars()
            .first()
        )
        if not row:
            raise HTTPException(status_code=404, detail="mini-app not found")
        row.enabled = False
        s.add(row)
        s.commit()
    return {"status": "ok"}


@app.get("/official_accounts/{account_id}/feed", response_class=JSONResponse)
async def official_account_feed(request: Request, account_id: str, limit: int = 20):
    try:
        limit_val = max(1, min(limit, 200))
        user_key = _official_cookie_key(request)
        with _officials_session() as s:
            acc = s.get(OfficialAccountDB, account_id)
            if not acc or not acc.enabled:
                raise HTTPException(status_code=404, detail="unknown official account")
            stmt = (
                _sa_select(OfficialFeedItemDB)
                .where(OfficialFeedItemDB.account_id == account_id)
                .order_by(OfficialFeedItemDB.ts.desc(), OfficialFeedItemDB.id.desc())
                .limit(limit_val)
            )
            rows = s.execute(stmt).scalars().all()
            items: list[dict[str, Any]] = []
            for row in rows:
                try:
                    deeplink = _json.loads(row.deeplink_json) if row.deeplink_json else None
                except Exception:
                    deeplink = None
                items.append(
                    OfficialFeedItemOut(
                        id=row.slug or str(row.id),
                        type=row.type,
                        title=row.title,
                        snippet=row.snippet,
                        thumb_url=row.thumb_url,
                        ts=row.ts.isoformat() if getattr(row, "ts", None) else None,
                        deeplink=deeplink,
                    ).dict()
                )
        try:
            emit_event(
                "officials",
                "feed_view",
                {"user_key": user_key, "account_id": account_id, "limit": limit_val, "returned": len(items)},
            )
        except Exception:
            pass
        return {"items": items}
    except HTTPException:
        raise
    except Exception:
        if account_id not in _OFFICIAL_ACCOUNTS:
            raise HTTPException(status_code=404, detail="unknown official account")
        acc = _OFFICIAL_ACCOUNTS[account_id]
        seed = _OFFICIAL_FEED_SEED.get(acc.id, [])
        base_items: list[OfficialFeedItemOut] = []
        for item in seed[: max(0, min(limit, len(seed)))]:
            base_items.append(
                OfficialFeedItemOut(
                    id=item.get("id", ""),
                    type=item.get("type", "promo"),
                    title=item.get("title"),
                    snippet=item.get("snippet"),
                    thumb_url=item.get("thumb_url"),
                    ts=item.get("ts"),
                    deeplink=item.get("deeplink"),
                )
            )
        items_out = [i.dict() for i in base_items]
        try:
            emit_event(
                "officials",
                "feed_view",
                {"user_key": user_key, "account_id": account_id, "limit": limit, "returned": len(items_out), "mode": "fallback"},
            )
        except Exception:
            pass
        return {"items": items_out}


@app.get("/official_accounts/{account_id}/moments_stats", response_class=JSONResponse)
def official_account_moments_stats(account_id: str) -> dict[str, Any]:
    """
    Aggregate Moments "social impact" stats for a single Official account.

    Returns total Moments shares with origin_official_account_id = account_id,
    how many of those mention red packets in the last 30 days, plus basic
    "social impact" KPIs used in merchant UIs.
    """
    try:
        total = 0
        shares_30 = 0
        uniq_total = 0
        uniq_30 = 0
        rp_30 = 0
        comments_total = 0
        comments_30 = 0
        followers = 0
        with _moments_session() as s:
            total = (
                s.execute(
                    _sa_select(_sa_func.count(MomentPostDB.id)).where(
                        MomentPostDB.origin_official_account_id == account_id
                    )
                )
                .scalar()
                or 0
            )
            since = datetime.now(timezone.utc) - timedelta(days=30)

            try:
                shares_30 = (
                    s.execute(
                        _sa_select(_sa_func.count(MomentPostDB.id)).where(
                            MomentPostDB.origin_official_account_id
                            == account_id,
                            MomentPostDB.created_at >= since,
                        )
                    )
                    .scalar()
                    or 0
                )
            except Exception:
                shares_30 = 0

            # Unique sharers (all time)
            try:
                uniq_total = (
                    s.execute(
                        _sa_select(
                            _sa_func.count(
                                _sa_func.distinct(MomentPostDB.user_key)
                            )
                        ).where(
                            MomentPostDB.origin_official_account_id
                            == account_id
                        )
                    )
                    .scalar()
                    or 0
                )
                uniq_30 = (
                    s.execute(
                        _sa_select(
                            _sa_func.count(
                                _sa_func.distinct(MomentPostDB.user_key)
                            )
                        ).where(
                            MomentPostDB.origin_official_account_id
                            == account_id,
                            MomentPostDB.created_at >= since,
                        )
                    )
                    .scalar()
                    or 0
                )
            except Exception:
                uniq_total = 0
                uniq_30 = 0

            # Red-packet related shares in the last 30 days
            try:
                rp1 = (
                    s.execute(
                        _sa_select(_sa_func.count(MomentPostDB.id)).where(
                            MomentPostDB.origin_official_account_id
                            == account_id,
                            MomentPostDB.created_at >= since,
                            MomentPostDB.text.contains("Red packet"),
                        )
                    )
                    .scalar()
                    or 0
                )
                rp2 = (
                    s.execute(
                        _sa_select(_sa_func.count(MomentPostDB.id)).where(
                            MomentPostDB.origin_official_account_id
                            == account_id,
                            MomentPostDB.created_at >= since,
                            MomentPostDB.text.contains(
                                "I am sending red packets via Shamell Pay"
                            ),
                        )
                    )
                    .scalar()
                    or 0
                )
                rp3 = (
                    s.execute(
                        _sa_select(_sa_func.count(MomentPostDB.id)).where(
                            MomentPostDB.origin_official_account_id
                            == account_id,
                            MomentPostDB.created_at >= since,
                            MomentPostDB.text.contains("حزمة حمراء"),
                        )
                    )
                    .scalar()
                    or 0
                )
                rp_30 = int((rp1 or 0) + (rp2 or 0) + (rp3 or 0))
            except Exception:
                rp_30 = 0

            # Comment volume (all time / last 30 days) for posts of this Official
            try:
                comments_total = (
                    s.execute(
                        _sa_select(_sa_func.count(MomentCommentDB.id))
                        .select_from(MomentCommentDB)
                        .join(
                            MomentPostDB,
                            MomentCommentDB.post_id == MomentPostDB.id,
                        )
                        .where(
                            MomentPostDB.origin_official_account_id
                            == account_id
                        )
                    )
                    .scalar()
                    or 0
                )
                comments_30 = (
                    s.execute(
                        _sa_select(_sa_func.count(MomentCommentDB.id))
                        .select_from(MomentCommentDB)
                        .join(
                            MomentPostDB,
                            MomentCommentDB.post_id == MomentPostDB.id,
                        )
                        .where(
                            MomentPostDB.origin_official_account_id
                            == account_id,
                            MomentCommentDB.created_at >= since,
                        )
                    )
                    .scalar()
                    or 0
                )
            except Exception:
                comments_total = 0
                comments_30 = 0

        # Follower count for this Official (for per-1k metric)
        try:
            with _officials_session() as osess:
                followers = (
                    osess.execute(
                        _sa_select(_sa_func.count(OfficialFollowDB.id)).where(
                            OfficialFollowDB.account_id == account_id
                        )
                    )
                    .scalar()
                    or 0
                )
        except Exception:
            followers = 0

        shares_per_1k = 0.0
        try:
            if followers and total:
                shares_per_1k = (float(total) / float(followers)) * 1000.0
        except Exception:
            shares_per_1k = 0.0

        return {
            "total_shares": int(total or 0),
            "shares_30d": int(shares_30 or 0),
            "redpacket_shares_30d": int(rp_30 or 0),
            "unique_sharers_total": int(uniq_total or 0),
            "unique_sharers_30d": int(uniq_30 or 0),
            "followers": int(followers or 0),
            "shares_per_1k_followers": shares_per_1k,
            "comments_total": int(comments_total or 0),
            "comments_30d": int(comments_30 or 0),
        }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/channels/feed", response_class=JSONResponse)
def channels_feed(
    request: Request,
    limit: int = 50,
    official_account_id: str | None = None,
) -> dict[str, Any]:
    """
    Lightweight "Channels" feed built from Official feed items.

    This is a WeChat‑like short feed that surfaces recent
    Official promotions and content in a unified view, with
    simple likes and view counters.
    """
    user_key = _official_cookie_key(request)
    try:
        limit_val = max(1, min(limit, 100))
        with _officials_session() as s:
            stmt = _sa_select(
                OfficialFeedItemDB,
                OfficialAccountDB.name,
                OfficialAccountDB.avatar_url,
                OfficialAccountDB.city,
                OfficialAccountDB.category,
            ).join(
                OfficialAccountDB,
                OfficialFeedItemDB.account_id == OfficialAccountDB.id,
            ).where(
                OfficialAccountDB.enabled == True  # type: ignore[comparison-overlap]
            )
            if official_account_id:
                stmt = stmt.where(
                    OfficialFeedItemDB.account_id == official_account_id
                )
            stmt = stmt.order_by(
                OfficialFeedItemDB.ts.desc(), OfficialFeedItemDB.id.desc()
            ).limit(limit_val)
            rows = s.execute(stmt).all()
            item_ids = [str(feed_row.id) for feed_row, _, _, _, _ in rows]
            likes_map: dict[str, int] = {}
            liked_by_me: set[str] = set()
            views_map: dict[str, int] = {}
            comments_map: dict[str, int] = {}
            if item_ids:
                like_rows = (
                    s.execute(
                        _sa_select(
                            ChannelLikeDB.item_id,
                            _sa_func.count(ChannelLikeDB.id),
                        )
                        .where(ChannelLikeDB.item_id.in_(item_ids))
                        .group_by(ChannelLikeDB.item_id)
                    )
                    .all()
                )
                for iid, cnt in like_rows:
                    likes_map[str(iid)] = int(cnt or 0)
                my_like_rows = (
                    s.execute(
                        _sa_select(ChannelLikeDB.item_id).where(
                            ChannelLikeDB.item_id.in_(item_ids),
                            ChannelLikeDB.user_key == user_key,
                        )
                    )
                    .scalars()
                    .all()
                )
                liked_by_me.update(str(iid) for iid in my_like_rows)
                view_rows = (
                    s.execute(
                        _sa_select(
                            ChannelViewDB.item_id,
                            ChannelViewDB.views,
                        ).where(ChannelViewDB.item_id.in_(item_ids))
                    )
                    .all()
                )
                for iid, views in view_rows:
                    try:
                        views_map[str(iid)] = int(views or 0)
                    except Exception:
                        continue
                comment_rows = (
                    s.execute(
                        _sa_select(
                            ChannelCommentDB.item_id,
                            _sa_func.count(ChannelCommentDB.id),
                        )
                        .where(ChannelCommentDB.item_id.in_(item_ids))
                        .group_by(ChannelCommentDB.item_id)
                    )
                    .all()
                )
                for iid, cnt in comment_rows:
                    try:
                        comments_map[str(iid)] = int(cnt or 0)
                    except Exception:
                        continue
        # Compute "hot in Moments" per Official based on total Moments shares,
        # a dedicated follower graph for Channels based on ChannelFollowDB,
        # and simple gift/coin stats per clip from ChannelGiftDB.
        hot_accounts: set[str] = set()
        channel_followers: dict[str, int] = {}
        channel_followed_by_me: set[str] = set()
        gift_totals: dict[str, int] = {}
        gift_by_me: dict[str, int] = {}
        try:
            acc_ids: set[str] = set()
            for feed_row, _, _, _, _ in rows:
                acc_id_val = getattr(feed_row, "account_id", None)
                if acc_id_val:
                    acc_ids.add(str(acc_id_val))
            if acc_ids:
                # Moments-derived "hot" flag.
                with _moments_session() as ms:
                    agg_rows = (
                        ms.execute(
                            _sa_select(
                                MomentPostDB.origin_official_account_id,
                                _sa_func.count(MomentPostDB.id),
                            )
                            .where(
                                MomentPostDB.origin_official_account_id.in_(
                                    list(acc_ids)
                                )
                            )
                            .group_by(MomentPostDB.origin_official_account_id)
                        )
                        .all()
                    )
                    for acc_id, cnt in agg_rows:
                        try:
                            if int(cnt or 0) >= 10:
                                hot_accounts.add(str(acc_id))
                        except Exception:
                            continue
                # Follower counts and "followed by me" for these channels.
                try:
                    with _officials_session() as osess:
                        f_rows = (
                            osess.execute(
                                _sa_select(
                                    ChannelFollowDB.account_id,
                                    _sa_func.count(ChannelFollowDB.id),
                                )
                                .where(ChannelFollowDB.account_id.in_(list(acc_ids)))
                                .group_by(ChannelFollowDB.account_id)
                            )
                            .all()
                        )
                        for acc_id, cnt in f_rows:
                            try:
                                channel_followers[str(acc_id)] = int(cnt or 0)
                            except Exception:
                                continue
                        my_rows = osess.execute(
                            _sa_select(ChannelFollowDB.account_id).where(
                                ChannelFollowDB.account_id.in_(list(acc_ids)),
                                ChannelFollowDB.user_key == user_key,
                            )
                        ).scalars().all()
                        channel_followed_by_me.update(str(aid) for aid in my_rows)
                    # Gift/coin stats per clip.
                    try:
                        g_rows = (
                            osess.execute(
                                _sa_select(
                                    ChannelGiftDB.item_id,
                                    _sa_func.sum(ChannelGiftDB.coins),
                                ).group_by(ChannelGiftDB.item_id)
                            )
                            .all()
                        )
                        for iid, total in g_rows:
                            try:
                                gift_totals[str(iid)] = int(total or 0)
                            except Exception:
                                continue
                        my_gift_rows = (
                            osess.execute(
                                _sa_select(
                                    ChannelGiftDB.item_id,
                                    _sa_func.sum(ChannelGiftDB.coins),
                                )
                                .where(ChannelGiftDB.user_key == user_key)
                                .group_by(ChannelGiftDB.item_id)
                            )
                            .all()
                        )
                        for iid, total in my_gift_rows:
                            try:
                                gift_by_me[str(iid)] = int(total or 0)
                            except Exception:
                                continue
                    except Exception:
                        gift_totals = {}
                        gift_by_me = {}
                except Exception:
                    channel_followers = {}
                    channel_followed_by_me = set()
                    gift_totals = {}
                    gift_by_me = {}
        except Exception:
            hot_accounts = set()
            channel_followers = {}
            channel_followed_by_me = set()
            gift_totals = {}
            gift_by_me = {}

        # Compute a simple WeChat-like ranking score per clip
        # based on engagement and how "hot" the originating
        # Official account is in Moments – similar to the
        # /search heuristics for Channels.
        scored_rows: list[
            tuple[
                float,
                Any,
                Any,
                Any,
                Any,
                Any,
            ]
        ] = []
        for feed_row, acc_name, acc_avatar, acc_city, acc_category in rows:
            item_id = str(getattr(feed_row, "id", ""))
            likes = likes_map.get(item_id, 0)
            views = views_map.get(item_id, 0)
            comments = comments_map.get(item_id, 0)
            f_type = (getattr(feed_row, "type", "") or "").strip().lower()
            acc_id_val = getattr(feed_row, "account_id", None)
            acc_id_str = str(acc_id_val) if acc_id_val is not None else ""
            score = 20.0
            # WeChat-like boost for special content types – live items
            # should surface very prominently, followed by campaigns.
            if f_type == "live":
                score += 15.0
            elif f_type in {"campaign", "promo"}:
                score += 10.0
            if acc_id_str in hot_accounts:
                score += 5.0
            try:
                if views > 0:
                    score += min(views, 5000) / 200.0
            except Exception:
                pass
            try:
                if likes > 0:
                    score += min(likes, 500) * 0.5
            except Exception:
                pass
            try:
                if comments > 0:
                    score += min(comments, 100) * 1.0
            except Exception:
                pass
            scored_rows.append(
                (score, feed_row, acc_name, acc_avatar, acc_city, acc_category)
            )
        scored_rows.sort(key=lambda t: t[0], reverse=True)

        items: list[dict[str, Any]] = []
        for score, feed_row, acc_name, acc_avatar, acc_city, acc_category in scored_rows:
            ts_val = getattr(feed_row, "ts", None)
            if isinstance(ts_val, datetime):
                ts_str = ts_val.isoformat().replace("+00:00", "Z")
            else:
                ts_str = None
            item_id = str(getattr(feed_row, "id", ""))
            acc_id_val = getattr(feed_row, "account_id", None)
            acc_id_str = str(acc_id_val) if acc_id_val is not None else ""
            items.append(
                ChannelItemOut(
                    id=item_id,
                    title=getattr(feed_row, "title", None),
                    snippet=getattr(feed_row, "snippet", None),
                    thumb_url=getattr(feed_row, "thumb_url", None),
                    ts=ts_str,
                    item_type=getattr(feed_row, "type", None),
                    official_account_id=acc_id_val,
                    official_name=str(acc_name or "")
                    if acc_name is not None
                    else None,
                    official_avatar_url=str(acc_avatar or "")
                    if acc_avatar is not None
                    else None,
                    official_city=str(acc_city or "") if acc_city is not None else None,
                    official_category=str(acc_category or "")
                    if acc_category is not None
                    else None,
                    likes=likes_map.get(item_id, 0),
                    liked_by_me=item_id in liked_by_me,
                    views=views_map.get(item_id, 0),
                    comments=comments_map.get(item_id, 0),
                    official_is_hot=acc_id_str in hot_accounts,
                    channel_followers=channel_followers.get(acc_id_str, 0),
                    channel_followed_by_me=acc_id_str in channel_followed_by_me,
                    gifts=gift_totals.get(item_id, 0),
                    gifts_by_me=gift_by_me.get(item_id, 0),
                    score=score,
                ).dict()
            )
        return {"items": items}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/channels/{item_id}/moments_stats", response_class=JSONResponse)
def channels_item_moments_stats(item_id: str) -> dict[str, Any]:
    """
    Moments-Analytics für einen einzelnen Channels-Clip.

    Nutzt shamell://official/<account>/<item_id>-Deeplinks in
    Moments-Posts, um WeChat-ähnliche Kennzahlen zu liefern:
    Gesamt-Shares, 30d-Shares, Unique-Sharer und einfache 30d-Kurve.
    """
    clean_id = (item_id or "").strip()
    if not clean_id:
        raise HTTPException(status_code=400, detail="item_id required")
    try:
        # Resolve owning Official account and optional slug for this feed item.
        acc_id: str | None = None
        slug: str | None = None
        with _officials_session() as s:
            row = s.get(OfficialFeedItemDB, clean_id)
            if row is None:
                # Some deployments may use slug-based IDs – try slug lookup.
                feed_row = (
                    s.execute(
                        _sa_select(OfficialFeedItemDB).where(
                            OfficialFeedItemDB.slug == clean_id
                        )
                    )
                    .scalars()
                    .first()
                )
                row = feed_row
            if row is None:
                raise HTTPException(status_code=404, detail="channels item not found")
            try:
                acc_val = getattr(row, "account_id", None)
                if acc_val is not None:
                    acc_id = str(acc_val)
            except Exception:
                acc_id = None
            try:
                slug_val = getattr(row, "slug", None)
                if slug_val:
                    slug = str(slug_val)
            except Exception:
                slug = None

        if not acc_id:
            raise HTTPException(status_code=404, detail="channels item not linked to account")

        # Build possible deeplink patterns as seen in Moments posts.
        patterns: list[str] = []
        # Primary pattern used by client when sharing Channels to Moments.
        patterns.append(f"shamell://official/{acc_id}/{clean_id}")
        if slug and slug != clean_id:
            patterns.append(f"shamell://official/{acc_id}/{slug}")

        def _base_filter() -> Any:
            cond = None
            for p in patterns:
                if not p:
                    continue
                expr = MomentPostDB.text.contains(p)
                cond = expr if cond is None else (cond | expr)
            return cond

        total = 0
        total_30d = 0
        uniq_total = 0
        uniq_30d = 0
        series_30d: list[dict[str, Any]] = []
        try:
            with _moments_session() as ms:
                since_30d = datetime.now(timezone.utc) - timedelta(days=30)
                cond = _base_filter()
                if cond is None:
                    return {
                        "item_id": clean_id,
                        "official_account_id": acc_id,
                        "shares_total": 0,
                        "shares_30d": 0,
                        "unique_sharers_total": 0,
                        "unique_sharers_30d": 0,
                        "series_30d": [],
                    }
                # All-time total shares.
                total = (
                    ms.execute(
                        _sa_select(_sa_func.count(MomentPostDB.id)).where(cond)
                    )
                    .scalar()
                    or 0
                )
                # 30d shares.
                total_30d = (
                    ms.execute(
                        _sa_select(_sa_func.count(MomentPostDB.id)).where(
                            cond, MomentPostDB.created_at >= since_30d
                        )
                    )
                    .scalar()
                    or 0
                )
                # Unique sharers all-time.
                uniq_total = (
                    ms.execute(
                        _sa_select(
                            _sa_func.count(
                                _sa_func.distinct(MomentPostDB.user_key)
                            )
                        ).where(cond)
                    )
                    .scalar()
                    or 0
                )
                # Unique sharers 30d.
                uniq_30d = (
                    ms.execute(
                        _sa_select(
                            _sa_func.count(
                                _sa_func.distinct(MomentPostDB.user_key)
                            )
                        ).where(
                            cond, MomentPostDB.created_at >= since_30d
                        )
                    )
                    .scalar()
                    or 0
                )
                # Daily curve for last 30 days.
                rows = (
                    ms.execute(
                        _sa_select(
                            _sa_func.date(MomentPostDB.created_at),
                            _sa_func.count(MomentPostDB.id),
                        )
                        .where(cond, MomentPostDB.created_at >= since_30d)
                        .group_by(_sa_func.date(MomentPostDB.created_at))
                        .order_by(_sa_func.date(MomentPostDB.created_at))
                    )
                    .all()
                )
                for d, cnt in rows:
                    try:
                        if isinstance(d, datetime):
                            date_str = d.date().isoformat()
                        else:
                            date_str = str(d)
                    except Exception:
                        date_str = str(d)
                    series_30d.append(
                        {"date": date_str, "shares": int(cnt or 0)}
                    )
        except Exception:
            total = 0
            total_30d = 0
            uniq_total = 0
            uniq_30d = 0
            series_30d = []

        return {
            "item_id": clean_id,
            "official_account_id": acc_id,
            "shares_total": int(total or 0),
            "shares_30d": int(total_30d or 0),
            "unique_sharers_total": int(uniq_total or 0),
            "unique_sharers_30d": int(uniq_30d or 0),
            "series_30d": series_30d,
        }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/stickers/my", response_class=JSONResponse)
def stickers_my(request: Request) -> dict[str, Any]:
    """
    Returns the IDs of sticker packs purchased by the current user.

    This is used by the Sticker‑Store to show which paid packs
    are already owned (WeChat‑like \"Owned\" state).
    """
    phone = _auth_phone(request)
    if not phone:
        # Anonymous users simply have no server‑side purchases.
        return {"packs": []}
    try:
        with _stickers_session() as s:
            rows = (
                s.execute(
                    _sa_select(StickerPurchaseDB.pack_id).where(
                        StickerPurchaseDB.user_phone == phone
                    )
                )
                .scalars()
                .all()
            )
        return {"packs": [str(pid) for pid in rows]}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/stickers/purchase", response_class=JSONResponse)
async def stickers_purchase(request: Request) -> dict[str, Any]:
    """
    Purchase a sticker pack using the user's wallet.

    For paid packs the server charges from_wallet_id -> STICKERS_MERCHANT_WALLET_ID
    via the Payments service (reusing the guarded transfer helper) and records
    the purchase idempotently per user + pack.
    """
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="unauthorized")
    try:
        body = await request.json()
    except Exception:
        body = {}
    if not isinstance(body, dict):
        body = {}
    pack_id = (body.get("pack_id") or "").strip()
    from_wallet_id = (body.get("from_wallet_id") or "").strip()
    if not pack_id:
        raise HTTPException(status_code=400, detail="pack_id required")

    # Resolve pack metadata from catalog.
    packs = _sticker_packs_config()
    pack_meta: dict[str, Any] | None = None
    for p in packs:
        try:
            if (p.get("id") or "").strip() == pack_id:
                pack_meta = p
                break
        except Exception:
            continue
    if not pack_meta:
        raise HTTPException(status_code=404, detail="unknown sticker pack")

    price_raw = pack_meta.get("price_cents") or 0
    try:
        price_cents = int(price_raw)
    except Exception:
        price_cents = 0
    currency = (pack_meta.get("currency") or DEFAULT_CURRENCY).strip() or DEFAULT_CURRENCY

    try:
        with _stickers_session() as s:
            # Idempotent per user/pack: if we already have a record, do not charge again.
            existing = (
                s.execute(
                    _sa_select(StickerPurchaseDB).where(
                        StickerPurchaseDB.user_phone == phone,
                        StickerPurchaseDB.pack_id == pack_id,
                    )
                )
                .scalars()
                .first()
            )
            if existing:
                return {
                    "status": "ok",
                    "pack_id": pack_id,
                    "owned": True,
                    "price_cents": existing.amount_cents,
                    "currency": existing.currency,
                }

            if price_cents > 0:
                if not STICKERS_MERCHANT_WALLET_ID:
                    raise HTTPException(
                        status_code=500,
                        detail="STICKERS_MERCHANT_WALLET_ID not configured",
                    )
                if not from_wallet_id:
                    raise HTTPException(
                        status_code=400,
                        detail="from_wallet_id required for paid packs",
                    )
                ref = f"stickers pack {pack_id}"
                _building_transfer(
                    request=request,
                    from_wallet_id=from_wallet_id,
                    to_wallet_id=STICKERS_MERCHANT_WALLET_ID,
                    amount_cents=price_cents,
                    reference=ref,
                )

            rec = StickerPurchaseDB(
                user_phone=phone,
                pack_id=pack_id,
                amount_cents=price_cents,
                currency=currency,
            )
            s.add(rec)
            s.commit()
            return {
                "status": "ok",
                "pack_id": pack_id,
                "owned": True,
                "price_cents": price_cents,
                "currency": currency,
            }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/stickers/packs", response_class=JSONResponse)
def stickers_packs(request: Request) -> dict[str, Any]:
    """
    Server‑side sticker pack catalog for the Sticker‑Store.

    Returns a small list of packs with IDs that mirror the
    built‑in Flutter packs so that the client can render a
    WeChat‑like online sticker marketplace.

    When the user is authenticated, each pack includes an
    \"owned\" flag based on StickerPurchaseDB so the client
    can show a WeChat‑like \"Owned\" state for paid packs.
    """
    try:
        packs = _sticker_packs_config()
        phone = _auth_phone(request)
        owned_ids: set[str] = set()
        if phone:
            try:
                with _stickers_session() as s:
                    rows = (
                        s.execute(
                            _sa_select(StickerPurchaseDB.pack_id).where(
                                StickerPurchaseDB.user_phone == phone
                            )
                        )
                        .scalars()
                        .all()
                    )
                    owned_ids = {str(pid) for pid in rows}
            except Exception:
                owned_ids = set()
        out_packs: list[dict[str, Any]] = []
        for p in packs:
            try:
                m = dict(p)
            except Exception:
                continue
            pid = (m.get("id") or "").strip()
            m["owned"] = bool(pid and pid in owned_ids)
            out_packs.append(m)
        return {"packs": out_packs}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/channels/{item_id}/like", response_class=JSONResponse)
def channels_like(item_id: str, request: Request) -> dict[str, Any]:
    """
    Toggle like for a Channels item (idempotent per user).
    """
    user_key = _official_cookie_key(request)
    clean_id = (item_id or "").strip()
    if not clean_id:
        raise HTTPException(status_code=400, detail="item_id required")
    try:
        with _officials_session() as s:
            existing = (
                s.execute(
                    _sa_select(ChannelLikeDB).where(
                        ChannelLikeDB.item_id == clean_id,
                        ChannelLikeDB.user_key == user_key,
                    )
                )
                .scalars()
                .first()
            )
            liked = False
            if existing:
                s.delete(existing)
                liked = False
            else:
                s.add(
                    ChannelLikeDB(
                        item_id=clean_id,
                        user_key=user_key,
                    )
                )
                liked = True
            s.commit()
            likes = (
                s.execute(
                    _sa_select(_sa_func.count(ChannelLikeDB.id)).where(
                        ChannelLikeDB.item_id == clean_id
                    )
                )
                .scalar()
                or 0
            )
        try:
            emit_event(
                "channels",
                "like",
                {"user_key": user_key, "item_id": clean_id, "liked": liked},
            )
        except Exception:
            pass
        return {"likes": int(likes or 0), "liked": liked}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/channels/{item_id}/comments", response_class=JSONResponse)
def channels_comments(item_id: str, request: Request, limit: int = 50) -> dict[str, Any]:
    """
    Returns latest comments for a Channels item.

    Lightweight, per-item thread similar to WeChat Channels comments.
    """
    _ = _official_cookie_key(request)
    clean_id = (item_id or "").strip()
    if not clean_id:
        raise HTTPException(status_code=400, detail="item_id required")
    try:
        limit_val = max(1, min(limit, 200))
        with _officials_session() as s:
            rows = (
                s.execute(
                    _sa_select(ChannelCommentDB)
                    .where(ChannelCommentDB.item_id == clean_id)
                    .order_by(
                        ChannelCommentDB.created_at.asc(),
                        ChannelCommentDB.id.asc(),
                    )
                    .limit(limit_val)
                )
                .scalars()
                .all()
            )
            items: list[dict[str, Any]] = []
            for row in rows:
                created = getattr(row, "created_at", None)
                try:
                    created_str = (
                        created.isoformat().replace("+00:00", "Z")
                        if isinstance(created, datetime)
                        else None
                    )
                except Exception:
                    created_str = str(created) if created is not None else None
                user_key = getattr(row, "user_key", "") or ""
                author_kind = "official" if user_key.startswith("official:") else "user"
                items.append(
                    {
                        "id": row.id,
                        "item_id": row.item_id,
                        "text": row.text,
                        "created_at": created_str,
                        "author_kind": author_kind,
                    }
                )
        return {"items": items}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


class ChannelGiftIn(BaseModel):
    account_id: str
    coins: int = 1
    gift_kind: str | None = None


@app.post("/channels/{item_id}/gift", response_class=JSONResponse)
def channels_item_gift(item_id: str, request: Request, body: ChannelGiftIn) -> dict[str, Any]:
    """
    Send a lightweight gift / coin to a Channels clip.

    This records engagement in ChannelGiftDB without moving real
    funds; coin-based payouts can be implemented separately via
    the payments layer.
    """
    clean_id = (item_id or "").strip()
    if not clean_id:
        raise HTTPException(status_code=400, detail="item_id required")
    account_id = (body.account_id or "").strip()
    if not account_id:
        raise HTTPException(status_code=400, detail="account_id required")
    coins = int(body.coins or 0)
    if coins <= 0:
        raise HTTPException(status_code=400, detail="coins must be > 0")
    # Soft cap per request to avoid accidental huge numbers.
    if coins > 1000:
        coins = 1000
    user_key = _channels_user_key(request)
    gift_kind = (body.gift_kind or "coin").strip().lower() or "coin"
    try:
        with _officials_session() as s:
            # Ensure the Channels item exists and belongs to the given account.
            feed_row = s.get(OfficialFeedItemDB, clean_id)
            if feed_row is None:
                # Some deployments may expose slug-based IDs.
                feed_row = (
                    s.execute(
                        _sa_select(OfficialFeedItemDB).where(
                            OfficialFeedItemDB.slug == clean_id
                        )
                    )
                    .scalars()
                    .first()
                )
            if feed_row is None:
                raise HTTPException(
                    status_code=404, detail="channels item not found"
                )
            acc_val = getattr(feed_row, "account_id", None)
            if not acc_val or str(acc_val) != account_id:
                raise HTTPException(
                    status_code=400, detail="account_id does not match clip"
                )
            s.add(
                ChannelGiftDB(
                    user_key=user_key,
                    account_id=account_id,
                    item_id=str(getattr(feed_row, "id", clean_id)),
                    gift_kind=gift_kind,
                    coins=coins,
                )
            )
            s.commit()
        try:
            emit_event(
                "channels",
                "gift",
                {
                    "user_key": user_key,
                    "account_id": account_id,
                    "item_id": clean_id,
                    "coins": coins,
                    "gift_kind": gift_kind,
                },
            )
        except Exception:
            pass
        return {"status": "ok"}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/channels/{item_id}/comments", response_class=JSONResponse)
def channels_add_comment(
    item_id: str, request: Request, body: ChannelCommentIn
) -> dict[str, Any]:
    """
    Adds a new comment to a Channels item for the current user.
    """
    user_key = _official_cookie_key(request)
    clean_id = (item_id or "").strip()
    if not clean_id:
        raise HTTPException(status_code=400, detail="item_id required")
    text = (body.text or "").strip()
    if not text:
        raise HTTPException(status_code=400, detail="text required")
    try:
        with _officials_session() as s:
            # Best-effort validation that the target feed item exists.
            try:
                fid = int(clean_id)
            except Exception:
                raise HTTPException(status_code=404, detail="unknown channel item")
            feed = s.get(OfficialFeedItemDB, fid)
            if not feed:
                raise HTTPException(status_code=404, detail="unknown channel item")
            row = ChannelCommentDB(item_id=clean_id, user_key=user_key, text=text)
            s.add(row)
            s.commit()
            s.refresh(row)
            created = getattr(row, "created_at", None)
            try:
                created_str = (
                    created.isoformat().replace("+00:00", "Z")
                    if isinstance(created, datetime)
                    else None
                )
            except Exception:
                created_str = str(created) if created is not None else None
        try:
            emit_event(
                "channels",
                "comment",
                {"user_key": user_key, "item_id": clean_id, "comment_id": row.id},
            )
        except Exception:
            pass
        return {
            "id": row.id,
            "item_id": row.item_id,
            "text": row.text,
            "created_at": created_str,
        }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/channels/{item_id}/view", response_class=JSONResponse)
def channels_view(item_id: str, request: Request) -> dict[str, Any]:
    """
    Increment view counter for a Channels item.
    """
    _ = _official_cookie_key(request)
    clean_id = (item_id or "").strip()
    if not clean_id:
        raise HTTPException(status_code=400, detail="item_id required")
    try:
        with _officials_session() as s:
            row = (
                s.execute(
                    _sa_select(ChannelViewDB).where(
                        ChannelViewDB.item_id == clean_id
                    )
                )
                .scalars()
                .first()
            )
            if row is None:
                row = ChannelViewDB(item_id=clean_id, views=1)
                s.add(row)
            else:
                try:
                    current = int(getattr(row, "views", 0) or 0)
                except Exception:
                    current = 0
                row.views = current + 1
                s.add(row)
            s.commit()
            views = int(getattr(row, "views", 0) or 0)
        try:
            emit_event(
                "channels",
                "view",
                {"item_id": clean_id, "views": views},
            )
        except Exception:
            pass
        return {"views": views}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/channels/upload", response_class=JSONResponse)
def channels_upload(request: Request, body: ChannelUploadIn) -> dict[str, Any]:
    """
    Creator-style upload endpoint for Channels clips.

    Authenticated users can attach a short clip to a specific Official
    account. The item is stored as OfficialFeedItemDB with type "clip"
    so it appears in Channels feed and the Official's feed.
    """
    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="auth required")
    acc_id = (body.official_account_id or "").strip()
    if not acc_id:
        raise HTTPException(status_code=400, detail="official_account_id required")
    title = (body.title or "").strip() or None
    snippet = (body.snippet or "").strip() or None
    thumb_url = (body.thumb_url or "").strip() or None
    # Basic live/clip switch – when is_live is true we store the
    # item as type "live", otherwise as a normal "clip". This keeps
    # existing clients compatible while enabling WeChat-style live
    # entries in Channels.
    row_type = "live" if bool(body.is_live) else "clip"
    try:
        with _officials_session() as s:
            acc = s.get(OfficialAccountDB, acc_id)
            if not acc or not acc.enabled:
                raise HTTPException(status_code=404, detail="unknown official account")
            slug = _uuid.uuid4().hex
            now = datetime.now(timezone.utc)
            deeplink_json = (
                _json.dumps(body.deeplink) if body.deeplink is not None else None
            )
            row = OfficialFeedItemDB(
                account_id=acc_id,
                slug=slug,
                type=row_type,
                title=title,
                snippet=snippet,
                thumb_url=thumb_url,
                ts=now,
                deeplink_json=deeplink_json,
            )
            s.add(row)
            s.commit()
            s.refresh(row)
            ts_str = (
                row.ts.isoformat().replace("+00:00", "Z")
                if isinstance(row.ts, datetime)
                else None
            )
        try:
            emit_event(
                "channels",
                "upload",
                {
                    "user_phone": phone,
                    "account_id": acc_id,
                    "slug": slug,
                    "has_thumb": bool(thumb_url),
                },
            )
        except Exception:
            pass
        return {
            "id": row.id,
            "slug": row.slug,
            "official_account_id": row.account_id,
            "type": row.type,
            "title": row.title,
            "snippet": row.snippet,
            "thumb_url": row.thumb_url,
            "ts": ts_str,
            "is_live": row.type == "live",
        }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/channels/live/{item_id}/stop", response_class=JSONResponse)
def channels_live_stop(request: Request, item_id: str) -> dict[str, Any]:
    """
    Lightweight "stop live" endpoint for Channels.

    For now this simply flips the underlying OfficialFeedItemDB.type
    from "live" back to "clip" so that the feed no longer highlights
    it as a live session, roughly matching WeChat Channels behaviour
    where ended streams turn into normal VOD entries.
    """

    phone = _auth_phone(request)
    if not phone:
        raise HTTPException(status_code=401, detail="auth required")
    clean_id = (item_id or "").strip()
    if not clean_id:
        raise HTTPException(status_code=400, detail="item_id required")
    try:
        with _officials_session() as s:
            row = s.get(OfficialFeedItemDB, clean_id)
            if row is None:
                raise HTTPException(status_code=404, detail="unknown feed item")
            try:
                current_type = (row.type or "").strip().lower()
            except Exception:
                current_type = ""
            # If it's not live anymore, we simply return the current state.
            if current_type != "live":
                ts_str: str | None
                ts_val = getattr(row, "ts", None)
                if isinstance(ts_val, datetime):
                    ts_str = ts_val.isoformat().replace("+00:00", "Z")
                else:
                    ts_str = None
                return {
                    "id": row.id,
                    "slug": row.slug,
                    "official_account_id": row.account_id,
                    "type": row.type,
                    "title": row.title,
                    "snippet": row.snippet,
                    "thumb_url": row.thumb_url,
                    "ts": ts_str,
                    "is_live": False,
                    "changed": False,
                }
            row.type = "clip"
            s.add(row)
            s.commit()
            s.refresh(row)
            ts_val = getattr(row, "ts", None)
            if isinstance(ts_val, datetime):
                ts_str = ts_val.isoformat().replace("+00:00", "Z")
            else:
                ts_str = None
        try:
            emit_event(
                "channels",
                "live_stop",
                {
                    "user_phone": phone,
                    "item_id": clean_id,
                    "account_id": row.account_id,
                },
            )
        except Exception:
            pass
        return {
            "id": row.id,
            "slug": row.slug,
            "official_account_id": row.account_id,
            "type": row.type,
            "title": row.title,
            "snippet": row.snippet,
            "thumb_url": row.thumb_url,
            "ts": ts_str,
            "is_live": False,
            "changed": True,
        }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/search", response_class=JSONResponse)
async def global_search(
    request: Request,
    q: str,
    kind: str | None = None,
    limit: int = 20,
) -> dict[str, Any]:
    """
    Einfache globale Suche über Mini-Apps, Mini-Programs, Official-Accounts,
    Moments und Channels – WeChat-ähnlicher Discover-Einstieg.
    """
    term = (q or "").strip()
    if not term:
        raise HTTPException(status_code=400, detail="q required")
    kind_clean = (kind or "").strip().lower()
    limit_val = max(1, min(limit, 50))
    needle = term.lower()
    phone = _auth_phone(request)
    contact = (phone or "").strip()

    results: list[dict[str, Any]] = []

    def _score_from_extra(extra: dict[str, Any] | None) -> float:
        if not extra:
            return 0.0
        val = extra.get("score")
        if isinstance(val, (int, float)):
            try:
                return float(val)
            except Exception:
                return 0.0
        return 0.0

    def _want(target: str) -> bool:
        if not kind_clean or kind_clean == "all":
            return True
        return kind_clean == target

    # Mini-Apps & Mini-Programs & Official / Channels all aus Official-DB.
    try:
        with _officials_session() as s:
            if _want("mini_app"):
                try:
                    stmt = (
                        _sa_select(MiniAppDB)
                        .where(MiniAppDB.enabled == True)  # type: ignore[comparison-overlap]
                        .limit(limit_val)
                    )
                    if needle:
                        stmt = stmt.where(
                            _sa_func.lower(MiniAppDB.title_en).contains(needle)
                            | _sa_func.lower(MiniAppDB.title_ar).contains(needle)
                            | _sa_func.lower(MiniAppDB.category_en).contains(needle)
                            | _sa_func.lower(MiniAppDB.category_ar).contains(needle)
                            | _sa_func.lower(MiniAppDB.description).contains(needle)
                        )
                    for row in s.execute(stmt).scalars().all():
                        try:
                            rating_val = float(
                                getattr(row, "rating", 0.0) or 0.0
                            )
                        except Exception:
                            rating_val = 0.0
                        try:
                            usage_val = int(
                                getattr(row, "usage_score", 0) or 0
                            )
                        except Exception:
                            usage_val = 0
                        try:
                            moments_val = int(
                                getattr(row, "moments_shares", 0) or 0
                            )
                        except Exception:
                            moments_val = 0
                        badges: list[str] = []
                        if bool(getattr(row, "official", False)):
                            badges.append("official")
                        if bool(getattr(row, "beta", False)):
                            badges.append("beta")
                        # Very simple "trending" heuristic – usage + social signal.
                        if usage_val >= 50 or moments_val >= 5:
                            badges.append("trending")
                        if moments_val >= 10:
                            badges.append("hot_in_moments")
                        # WeChat-like: usage + social + rating as core score,
                        # plus a modest type boost so Mini-Apps surface
                        # vor Moments/Channels in der "All"-Suche.
                        score = (
                            float(usage_val)
                            + float(moments_val * 5)
                            + (rating_val * 10.0)
                            + 40.0
                        )
                        results.append(
                            {
                                "kind": "mini_app",
                                "id": row.app_id,
                                "title": row.title_en,
                                "title_ar": row.title_ar,
                                "snippet": row.description,
                                "extra": {
                                    "category_en": row.category_en,
                                    "category_ar": row.category_ar,
                                    "runtime_app_id": getattr(row, "runtime_app_id", None),
                                    "rating": rating_val,
                                    "usage_score": usage_val,
                                    "moments_shares": moments_val,
                                    "official": bool(
                                        getattr(row, "official", False)
                                    ),
                                    "beta": bool(getattr(row, "beta", False)),
                                    "score": score,
                                    "badges": badges,
                                },
                            }
                        )
                except Exception:
                    pass

            if _want("mini_program"):
                try:
                    stmt = _sa_select(MiniProgramDB).limit(limit_val)
                    if needle:
                        stmt = stmt.where(
                            _sa_func.lower(MiniProgramDB.title_en).contains(needle)
                            | _sa_func.lower(MiniProgramDB.title_ar).contains(needle)
                            | _sa_func.lower(MiniProgramDB.description_en).contains(
                                needle
                            )
                            | _sa_func.lower(MiniProgramDB.description_ar).contains(
                                needle
                            )
                        )
                    rows = s.execute(stmt).scalars().all()
                    # Best-effort Moments shares pro Mini-Program für die Suche,
                    # damit "Hot in Moments" / 30‑Tage‑Aktivität WeChat‑ähnlich
                    # berücksichtigt werden kann.
                    mp_moments_30d: dict[str, int] = {}
                    try:
                        app_ids = [
                            (getattr(r, "app_id", "") or "").strip()
                            for r in rows
                        ]
                        app_ids = [a for a in app_ids if a]
                        if app_ids:
                            with _moments_session() as ms:
                                since_30d = datetime.now(timezone.utc) - timedelta(
                                    days=30
                                )
                                for app_id in app_ids:
                                    try:
                                        pattern = f"shamell://mini_program/{app_id}"
                                        stmt_m = _sa_select(
                                            _sa_func.count(MomentPostDB.id)
                                        ).where(
                                            MomentPostDB.text.contains(pattern),
                                            MomentPostDB.created_at >= since_30d,
                                        )
                                        cnt = ms.execute(stmt_m).scalar() or 0
                                        mp_moments_30d[app_id] = int(cnt or 0)
                                    except Exception:
                                        continue
                    except Exception:
                        mp_moments_30d = {}
                    for row in rows:
                        status = (row.status or "draft").strip().lower()
                        owner_name = (row.owner_name or "").strip()
                        owner_contact = (
                            getattr(row, "owner_contact", "") or ""
                        ).strip()
                        try:
                            usage_val = int(
                                getattr(row, "usage_score", 0) or 0
                            )
                        except Exception:
                            usage_val = 0
                        try:
                            rating_val = float(
                                getattr(row, "rating", 0.0) or 0.0
                            )
                        except Exception:
                            rating_val = 0.0
                        try:
                            moments_30 = int(
                                mp_moments_30d.get(row.app_id or "", 0) or 0
                            )
                        except Exception:
                            moments_30 = 0
                        # Lightweight category heuristic, ähnlich zu
                        # MiniProgramsDirectoryPage im Flutter-Client.
                        category_key: str | None = None
                        try:
                            hay = " ".join(
                                [
                                    (row.title_en or ""),
                                    (row.title_ar or ""),
                                    getattr(row, "description_en", "") or "",
                                    getattr(row, "description_ar", "") or "",
                                    row.app_id or "",
                                ]
                            ).lower()
                            if any(k in hay for k in ["taxi", "ride", "transport"]):
                                category_key = "transport"
                            elif any(
                                k in hay for k in ["food", "restaurant", "delivery"]
                            ):
                                category_key = "food"
                            elif any(
                                k in hay for k in ["stay", "hotel", "travel"]
                            ):
                                category_key = "stays"
                            elif any(
                                k in hay
                                for k in ["wallet", "pay ", "payment", "payments"]
                            ):
                                category_key = "wallet"
                        except Exception:
                            category_key = None
                        badges: list[str] = []
                        if status == "active":
                            badges.append("active")
                        elif status:
                            badges.append(status)
                        if owner_name:
                            badges.append("owner")
                        if contact and owner_contact and contact == owner_contact:
                            badges.append("mine")
                        if moments_30 >= 5:
                            badges.append("hot_in_moments")
                        # WeChat-like: aktive und häufig genutzte Mini-Programme
                        # werden deutlich vor anderen Content-Arten priorisiert.
                        # Zusätzlich einfaches "Trending"-Signal und Rating-
                        # Einbindung für die Suche – analog zur Mini-Apps-
                        # Heuristik und dem Mini-Programs-Katalog.
                        if (
                            usage_val >= 50
                            or rating_val >= 4.5
                            or moments_30 >= 5
                        ):
                            badges.append("trending")
                        if status == "active":
                            score = (
                                60.0
                                + float(usage_val)
                                + (rating_val * 5.0)
                                + (float(moments_30) * 3.0)
                            )
                        else:
                            score = (
                                30.0
                                + float(usage_val * 0.5)
                                + (rating_val * 2.5)
                                + (float(moments_30) * 1.5)
                            )
                        results.append(
                            {
                                "kind": "mini_program",
                                "id": row.app_id,
                                "title": row.title_en,
                                "title_ar": row.title_ar,
                                "snippet": getattr(row, "description_en", None),
                                "extra": {
                                    "status": row.status,
                                    "owner_name": row.owner_name,
                                    "usage_score": usage_val,
                                    "rating": rating_val,
                                    "moments_shares_30d": moments_30,
                                    "category": category_key,
                                    "score": score,
                                    "badges": badges,
                                },
                            }
                        )
                except Exception:
                    pass

            if _want("official"):
                try:
                    stmt = (
                        _sa_select(OfficialAccountDB)
                        .where(OfficialAccountDB.enabled == True)  # type: ignore[comparison-overlap]
                    )
                    if needle:
                        stmt = stmt.where(
                            _sa_func.lower(OfficialAccountDB.name).contains(needle)
                            | _sa_func.lower(OfficialAccountDB.name_ar).contains(
                                needle
                            )
                            | _sa_func.lower(OfficialAccountDB.city).contains(needle)
                            | _sa_func.lower(OfficialAccountDB.category).contains(
                                needle
                            )
                            | _sa_func.lower(OfficialAccountDB.description).contains(
                                needle
                            )
                        )
                    rows = s.execute(stmt.limit(limit_val)).scalars().all()
                    if rows:
                        acc_ids = [str(getattr(r, "id", "")) for r in rows if getattr(r, "id", None)]
                        followers: dict[str, int] = {}
                        campaign_counts: dict[str, int] = {}
                        if acc_ids:
                            try:
                                f_rows = (
                                    s.execute(
                                        _sa_select(
                                            OfficialFollowDB.account_id,
                                            _sa_func.count(OfficialFollowDB.id),
                                        ).where(OfficialFollowDB.account_id.in_(acc_ids))
                                        .group_by(OfficialFollowDB.account_id)
                                    )
                                    .all()
                                )
                                for acc_id, cnt in f_rows:
                                    try:
                                        followers[str(acc_id)] = int(cnt or 0)
                                    except Exception:
                                        continue
                            except Exception:
                                followers = {}
                            # Active Red‑Packet campaigns per Official for badges in search.
                            try:
                                camp_rows = (
                                    s.execute(
                                        _sa_select(
                                            RedPacketCampaignDB.account_id,
                                            _sa_func.count(RedPacketCampaignDB.id),
                                        )
                                        .where(
                                            RedPacketCampaignDB.account_id.in_(acc_ids),
                                            RedPacketCampaignDB.active.is_(True),
                                        )
                                        .group_by(RedPacketCampaignDB.account_id)
                                    )
                                    .all()
                                )
                                for acc_id, cnt in camp_rows:
                                    try:
                                        campaign_counts[str(acc_id)] = int(cnt or 0)
                                    except Exception:
                                        continue
                            except Exception:
                                campaign_counts = {}
                        # Moments shares in the last 30 days for these officials.
                        shares_30d: dict[str, int] = {}
                        if acc_ids:
                            try:
                                since_30 = datetime.now(timezone.utc) - timedelta(days=30)
                            except Exception:
                                since_30 = None  # type: ignore[assignment]
                            if since_30 is not None:
                                try:
                                    with _moments_session() as ms:
                                        m_rows = (
                                            ms.execute(
                                                _sa_select(
                                                    MomentPostDB.origin_official_account_id,
                                                    _sa_func.count(MomentPostDB.id),
                                                )
                                                .where(
                                                    MomentPostDB.origin_official_account_id.in_(acc_ids),
                                                    MomentPostDB.created_at >= since_30,
                                                )
                                                .group_by(MomentPostDB.origin_official_account_id)
                                            )
                                            .all()
                                        )
                                        for acc_id, cnt in m_rows:
                                            if not acc_id:
                                                continue
                                            try:
                                                shares_30d[str(acc_id)] = int(cnt or 0)
                                            except Exception:
                                                continue
                                except Exception:
                                    shares_30d = {}
                        for row in rows:
                            acc_id = str(getattr(row, "id", ""))
                            kind_val = (getattr(row, "kind", "") or "").strip().lower()
                            badges: list[str] = []
                            if kind_val == "service":
                                badges.append("service")
                            elif kind_val == "subscription":
                                badges.append("subscription")
                            featured = bool(getattr(row, "featured", False))
                            verified = bool(getattr(row, "verified", False))
                            if featured:
                                badges.append("featured")
                            if verified:
                                badges.append("verified")
                            followers_cnt = followers.get(acc_id, 0)
                            campaigns_active = campaign_counts.get(acc_id, 0)
                            if campaigns_active > 0:
                                badges.append("campaign")
                            shares_cnt = shares_30d.get(acc_id, 0)
                            if shares_cnt >= 3:
                                badges.append("hot_in_moments")
                            # Simple WeChat-like prominence: featured/verified,
                            # follower size (log-ish) and recent Moments shares,
                            # plus ein klarer Typ-Boost gegenüber Moments/Channels.
                            score = 80.0
                            if featured:
                                score += 20.0
                            if verified:
                                score += 5.0
                            if followers_cnt > 0:
                                try:
                                    score += min(followers_cnt, 50000) / 1000.0
                                except Exception:
                                    pass
                            if shares_cnt > 0:
                                score += shares_cnt * 2.0
                            results.append(
                                {
                                    "kind": "official",
                                    "id": row.id,
                                    "title": row.name,
                                    "title_ar": row.name_ar,
                                    "snippet": row.description,
                                    "extra": {
                                        "city": getattr(row, "city", None),
                                        "category": getattr(row, "category", None),
                                        "kind": kind_val or None,
                                        "followers": followers_cnt,
                                        "shares_30d": shares_cnt,
                                        "campaigns_active": campaigns_active,
                                        "score": score,
                                        "badges": badges,
                                    },
                                }
                            )
                except Exception:
                    pass

            if _want("channel"):
                try:
                    c_stmt = (
                        _sa_select(
                            OfficialFeedItemDB,
                            OfficialAccountDB.name,
                        )
                        .join(
                            OfficialAccountDB,
                            OfficialFeedItemDB.account_id == OfficialAccountDB.id,
                        )
                        .order_by(
                            OfficialFeedItemDB.ts.desc(),
                            OfficialFeedItemDB.id.desc(),
                        )
                        .limit(limit_val)
                    )
                    if needle:
                        c_stmt = c_stmt.where(
                            _sa_func.lower(OfficialFeedItemDB.title).contains(needle)
                            | _sa_func.lower(OfficialFeedItemDB.snippet).contains(
                                needle
                            )
                        )
                    rows = s.execute(c_stmt).all()
                    # Preload simple engagement metrics for these items to strengthen
                    # ranking heuristics (likes, views, comments).
                    item_ids: list[str] = []
                    for feed_row, _ in rows:
                        try:
                            item_ids.append(str(getattr(feed_row, "id", "")))
                        except Exception:
                            continue
                    likes_map: dict[str, int] = {}
                    views_map: dict[str, int] = {}
                    comments_map: dict[str, int] = {}
                    if item_ids:
                        try:
                            like_rows = (
                                s.execute(
                                    _sa_select(
                                        ChannelLikeDB.item_id,
                                        _sa_func.count(ChannelLikeDB.id),
                                    )
                                    .where(ChannelLikeDB.item_id.in_(item_ids))
                                    .group_by(ChannelLikeDB.item_id)
                                )
                                .all()
                            )
                            for iid, cnt in like_rows:
                                try:
                                    likes_map[str(iid)] = int(cnt or 0)
                                except Exception:
                                    continue
                        except Exception:
                            likes_map = {}
                        try:
                            view_rows = (
                                s.execute(
                                    _sa_select(
                                        ChannelViewDB.item_id,
                                        ChannelViewDB.views,
                                    ).where(ChannelViewDB.item_id.in_(item_ids))
                                )
                                .all()
                            )
                            for iid, views in view_rows:
                                try:
                                    views_map[str(iid)] = int(views or 0)
                                except Exception:
                                    continue
                        except Exception:
                            views_map = {}
                        try:
                            comment_rows = (
                                s.execute(
                                    _sa_select(
                                        ChannelCommentDB.item_id,
                                        _sa_func.count(ChannelCommentDB.id),
                                    )
                                    .where(ChannelCommentDB.item_id.in_(item_ids))
                                    .group_by(ChannelCommentDB.item_id)
                                )
                                .all()
                            )
                            for iid, cnt in comment_rows:
                                try:
                                    comments_map[str(iid)] = int(cnt or 0)
                                except Exception:
                                    continue
                        except Exception:
                            comments_map = {}
                    hot_accounts: set[str] = set()
                    try:
                        acc_ids: set[str] = set()
                        for feed_row, _ in rows:
                            acc_id_val = getattr(feed_row, "account_id", None)
                            if acc_id_val:
                                acc_ids.add(str(acc_id_val))
                        if acc_ids:
                            with _moments_session() as ms:
                                agg_rows = (
                                    ms.execute(
                                        _sa_select(
                                            MomentPostDB.origin_official_account_id,
                                            _sa_func.count(MomentPostDB.id),
                                        )
                                        .where(
                                            MomentPostDB.origin_official_account_id.in_(
                                                list(acc_ids)
                                            )
                                        )
                                        .group_by(
                                            MomentPostDB.origin_official_account_id
                                        )
                                    )
                                    .all()
                                )
                                for acc_id, cnt in agg_rows:
                                    try:
                                        if int(cnt or 0) >= 10:
                                            hot_accounts.add(str(acc_id))
                                    except Exception:
                                        continue
                    except Exception:
                        hot_accounts = set()
                    for feed_row, acc_name in rows:
                        f_type = (getattr(feed_row, "type", "") or "").strip().lower()
                        badges: list[str] = []
                        if f_type:
                            badges.append(f_type)
                        item_id_str = str(getattr(feed_row, "id", ""))
                        likes = likes_map.get(item_id_str, 0)
                        views = views_map.get(item_id_str, 0)
                        comments = comments_map.get(item_id_str, 0)
                        if likes >= 10 or views >= 100:
                            badges.append("popular_clip")
                        if comments >= 3:
                            badges.append("discussed")
                        acc_id_val = getattr(feed_row, "account_id", None)
                        acc_id_str = str(acc_id_val) if acc_id_val is not None else ""
                        if acc_id_str in hot_accounts:
                            badges.append("hot_in_moments")
                        # WeChat-like: Campaign/Promo-Clips und Clips von
                        # besonders aktiven Official-Accounts leicht bevorzugen.
                        # Zusätzlich werden Clips mit hoher Interaktion (Likes/Views/
                        # Comments) stärker gewichtet, bleiben aber unter
                        # Official/Mini-Program-Ergebnissen. Live-Items werden
                        # zusätzlich hervorgehoben.
                        score = 20.0
                        if f_type == "live":
                            score += 15.0
                            if "live" not in badges:
                                badges.append("live")
                        elif f_type in {"campaign", "promo"}:
                            score += 10.0
                        if acc_id_str in hot_accounts:
                            score += 5.0
                        try:
                            if views > 0:
                                score += min(views, 5000) / 200.0
                        except Exception:
                            pass
                        try:
                            if likes > 0:
                                score += min(likes, 500) * 0.5
                        except Exception:
                            pass
                        try:
                            if comments > 0:
                                score += min(comments, 100) * 1.0
                        except Exception:
                            pass
                        results.append(
                            {
                                "kind": "channel",
                                "id": getattr(feed_row, "slug", None)
                                or str(getattr(feed_row, "id", "")),
                                "title": getattr(feed_row, "title", None),
                                "title_ar": None,
                                "snippet": getattr(feed_row, "snippet", None),
                                "extra": {
                                    "official_account_id": acc_id_val,
                                    "official_name": acc_name,
                                    "likes": likes,
                                    "views": views,
                                    "comments": comments,
                                    "score": score,
                                    "badges": badges,
                                    "type": f_type or None,
                                },
                            }
                        )
                except Exception:
                    pass
    except HTTPException:
        raise
    except Exception:
        # ignore and fall back to other sources
        pass

    # Moments search via Moments DB.
    if _want("moment"):
        try:
            with _moments_session() as ms:
                m_stmt = (
                    _sa_select(MomentPostDB)
                    .where(_sa_func.lower(MomentPostDB.text).contains(needle))
                    .order_by(
                        MomentPostDB.created_at.desc(),
                        MomentPostDB.id.desc(),
                    )
                    .limit(limit_val)
                )
                for row in ms.execute(m_stmt).scalars().all():
                    text = getattr(row, "text", "") or ""
                    is_redpacket = False
                    try:
                        t_low = text.lower()
                        if "red packet" in t_low or "red packets" in t_low:
                            is_redpacket = True
                        if "i am sending red packets via shamell pay" in t_low:
                            is_redpacket = True
                        if "حزمة حمراء" in text or "حزمًا حمراء" in text:
                            is_redpacket = True
                    except Exception:
                        is_redpacket = False
                    badges: list[str] = []
                    if is_redpacket:
                        badges.append("redpacket")
                    results.append(
                        {
                            "kind": "moment",
                            "id": getattr(row, "id", None),
                            "title": None,
                            "title_ar": None,
                            "snippet": text,
                            "extra": {
                                "created_at": getattr(row, "created_at", None),
                                "author_id": getattr(row, "user_id", None),
                                "score": 0.0,
                                "badges": badges,
                            },
                        }
                    )
        except Exception:
            pass

    # Sort by score for WeChat-like "trending" behaviour where available.
    if not kind_clean or kind_clean == "all":
        results.sort(
            key=lambda r: _score_from_extra(
                r.get("extra") if isinstance(r.get("extra"), dict) else None
            ),
            reverse=True,
        )
    elif kind_clean in {"mini_app", "mini_program", "official"}:
        results.sort(
            key=lambda r: _score_from_extra(
                r.get("extra") if isinstance(r.get("extra"), dict) else None
            ),
            reverse=True,
        )

    if len(results) > limit_val:
        results = results[:limit_val]
    return {"results": results}


@app.get("/official_accounts/{account_id}/campaigns", response_class=JSONResponse)
def official_account_campaigns(account_id: str) -> dict[str, Any]:
    """
    Public, read-only list of active red-packet campaigns for a single Official.

    Used by the client to prefill campaign-specific red-packet issuing UIs.
    """
    try:
        with _officials_session() as s:
            rows = (
                s.execute(
                    _sa_select(RedPacketCampaignDB).where(
                        RedPacketCampaignDB.account_id == account_id,
                        RedPacketCampaignDB.active.is_(True),
                    )
                )
                .scalars()
                .all()
            )
            items: list[dict[str, Any]] = []
            for row in rows:
                created = getattr(row, "created_at", None)
                created_str = None
                try:
                    created_str = (
                        created.isoformat().replace("+00:00", "Z")
                        if created
                        else None
                    )
                except Exception:
                    created_str = str(created) if created is not None else None
                items.append(
                    {
                        "id": row.id,
                        "account_id": row.account_id,
                        "title": row.title,
                        "default_amount_cents": getattr(
                            row, "default_amount_cents", None
                        ),
                        "default_count": getattr(row, "default_count", None),
                        "active": bool(getattr(row, "active", True)),
                        "created_at": created_str,
                        "note": getattr(row, "note", None),
                    }
                )
        return {"campaigns": items}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get(
    "/official_accounts/{account_id}/campaigns/{campaign_id}/stats",
    response_class=JSONResponse,
)
def official_account_campaign_stats(
    account_id: str,
    campaign_id: str,
) -> dict[str, Any]:
    """
    Lightweight JSON KPIs for a single Red‑Packet campaign – WeChat‑style.

    Exposes aggregated Moments shares (all time / 30d, unique sharers) and
    Red‑Packet payments KPIs (issued/claimed packets and amounts) so that
    merchant UIs can render a compact in‑app dashboard.
    """
    cid = (campaign_id or "").strip()
    if not cid:
        raise HTTPException(status_code=400, detail="campaign_id required")
    try:
        # Resolve campaign and ensure it belongs to the given Official.
        with _officials_session() as s:
            camp = s.get(RedPacketCampaignDB, cid)
            if not camp or camp.account_id != account_id:
                raise HTTPException(status_code=404, detail="campaign not found")

        # Moments metrics for this campaign (origin_official_item_id == campaign_id)
        moments_total = 0
        moments_30d = 0
        uniq_total = 0
        uniq_30d = 0
        last_share_ts: str | None = None
        try:
            since_30d = datetime.now(timezone.utc) - timedelta(days=30)
            with _moments_session() as ms:
                moments_total = int(
                    (
                        ms.execute(
                            _sa_select(_sa_func.count(MomentPostDB.id)).where(
                                MomentPostDB.origin_official_item_id == cid
                            )
                        ).scalar()
                        or 0
                    )
                )
                moments_30d = int(
                    (
                        ms.execute(
                            _sa_select(_sa_func.count(MomentPostDB.id)).where(
                                MomentPostDB.origin_official_item_id == cid,
                                MomentPostDB.created_at >= since_30d,
                            )
                        ).scalar()
                        or 0
                    )
                )
                uniq_total = int(
                    (
                        ms.execute(
                            _sa_select(
                                _sa_func.count(
                                    _sa_func.distinct(MomentPostDB.user_key)
                                )
                            ).where(MomentPostDB.origin_official_item_id == cid)
                        ).scalar()
                        or 0
                    )
                )
                uniq_30d = int(
                    (
                        ms.execute(
                            _sa_select(
                                _sa_func.count(
                                    _sa_func.distinct(MomentPostDB.user_key)
                                )
                            ).where(
                                MomentPostDB.origin_official_item_id == cid,
                                MomentPostDB.created_at >= since_30d,
                            )
                        ).scalar()
                        or 0
                    )
                )
                last_row = (
                    ms.execute(
                        _sa_select(_sa_func.max(MomentPostDB.created_at)).where(
                            MomentPostDB.origin_official_item_id == cid
                        )
                    ).scalar()
                    or None
                )
                if last_row is not None:
                    try:
                        last_share_ts = (
                            last_row.isoformat().replace("+00:00", "Z")
                            if isinstance(last_row, datetime)
                            else str(last_row)
                        )
                    except Exception:
                        last_share_ts = str(last_row)
        except Exception:
            moments_total = 0
            moments_30d = 0
            uniq_total = 0
            uniq_30d = 0
            last_share_ts = None

        # Optional Payments KPIs via internal Payments service or PAYMENTS_BASE.
        payments_total_packets_issued = 0
        payments_total_packets_claimed = 0
        payments_total_amount_cents = 0
        payments_claimed_amount_cents = 0
        payments_unique_creators = 0
        payments_unique_claimants = 0
        try:
            data: dict[str, Any] | None = None
            data_30d: dict[str, Any] | None = None
            since_30d_pay = datetime.now(timezone.utc) - timedelta(days=30)
            # Prefer internal Payments integration when available; fall back to HTTP.
            if _use_pay_internal() and _pay_main is not None:
                from apps.payments.app.main import (  # type: ignore[import]
                    redpacket_campaign_payments_analytics,
                )

                with _pay_internal_session() as ps:  # type: ignore[name-defined]
                    stats = redpacket_campaign_payments_analytics(
                        campaign_id=cid,
                        from_iso=None,
                        to_iso=None,
                        s=ps,
                        admin_ok=True,  # bypass external admin checks for internal call
                    )
                    data = stats.dict() if hasattr(stats, "dict") else stats  # type: ignore[assignment]
                    stats_30 = redpacket_campaign_payments_analytics(
                        campaign_id=cid,
                        from_iso=since_30d_pay.isoformat(),
                        to_iso=None,
                        s=ps,
                        admin_ok=True,
                    )
                    data_30d = stats_30.dict() if hasattr(stats_30, "dict") else stats_30  # type: ignore[assignment]
            elif PAYMENTS_BASE:
                base = PAYMENTS_BASE.rstrip("/")
                url = f"{base}/admin/redpacket_campaigns/payments_analytics"
                r = httpx.get(
                    url,
                    headers=_payments_headers(),
                    params={"campaign_id": cid},
                    timeout=5.0,
                )
                if (
                    r.status_code == 200
                    and r.headers.get("content-type", "").startswith(
                        "application/json"
                    )
                ):
                    body = r.json()
                    if isinstance(body, dict):
                        data = body
                try:
                    r30 = httpx.get(
                        url,
                        headers=_payments_headers(),
                        params={"campaign_id": cid, "from_iso": since_30d_pay.isoformat()},
                        timeout=5.0,
                    )
                    if (
                        r30.status_code == 200
                        and r30.headers.get("content-type", "").startswith(
                            "application/json"
                        )
                    ):
                        body_30 = r30.json()
                        if isinstance(body_30, dict):
                            data_30d = body_30
                except Exception:
                    data_30d = data_30d
            if isinstance(data, dict):
                try:
                    payments_total_packets_issued = int(
                        data.get("total_packets_issued", 0) or 0
                    )
                except Exception:
                    payments_total_packets_issued = 0
                try:
                    payments_total_packets_claimed = int(
                        data.get("total_packets_claimed", 0) or 0
                    )
                except Exception:
                    payments_total_packets_claimed = 0
                try:
                    payments_total_amount_cents = int(
                        data.get("total_amount_cents", 0) or 0
                    )
                except Exception:
                    payments_total_amount_cents = 0
                try:
                    payments_claimed_amount_cents = int(
                        data.get("claimed_amount_cents", 0) or 0
                    )
                except Exception:
                    payments_claimed_amount_cents = 0
                try:
                    payments_unique_creators = int(
                        data.get("unique_creators", 0) or 0
                    )
                except Exception:
                    payments_unique_creators = 0
                try:
                    payments_unique_claimants = int(
                        data.get("unique_claimants", 0) or 0
                    )
                except Exception:
                    payments_unique_claimants = 0

            payments_total_packets_issued_30d = 0
            payments_total_packets_claimed_30d = 0
            payments_total_amount_cents_30d = 0
            payments_claimed_amount_cents_30d = 0
            payments_unique_creators_30d = 0
            payments_unique_claimants_30d = 0
            if isinstance(data_30d, dict):
                try:
                    payments_total_packets_issued_30d = int(
                        data_30d.get("total_packets_issued", 0) or 0
                    )
                except Exception:
                    payments_total_packets_issued_30d = 0
                try:
                    payments_total_packets_claimed_30d = int(
                        data_30d.get("total_packets_claimed", 0) or 0
                    )
                except Exception:
                    payments_total_packets_claimed_30d = 0
                try:
                    payments_total_amount_cents_30d = int(
                        data_30d.get("total_amount_cents", 0) or 0
                    )
                except Exception:
                    payments_total_amount_cents_30d = 0
                try:
                    payments_claimed_amount_cents_30d = int(
                        data_30d.get("claimed_amount_cents", 0) or 0
                    )
                except Exception:
                    payments_claimed_amount_cents_30d = 0
                try:
                    payments_unique_creators_30d = int(
                        data_30d.get("unique_creators", 0) or 0
                    )
                except Exception:
                    payments_unique_creators_30d = 0
                try:
                    payments_unique_claimants_30d = int(
                        data_30d.get("unique_claimants", 0) or 0
                    )
                except Exception:
                    payments_unique_claimants_30d = 0
        except Exception:
            payments_total_packets_issued = 0
            payments_total_packets_claimed = 0
            payments_total_amount_cents = 0
            payments_claimed_amount_cents = 0
            payments_unique_creators = 0
            payments_unique_claimants = 0
            payments_total_packets_issued_30d = 0
            payments_total_packets_claimed_30d = 0
            payments_total_amount_cents_30d = 0
            payments_claimed_amount_cents_30d = 0
            payments_unique_creators_30d = 0
            payments_unique_claimants_30d = 0

        return {
            "campaign_id": cid,
            "account_id": account_id,
            "moments_shares_total": moments_total,
            "moments_shares_30d": moments_30d,
            "moments_unique_sharers_total": uniq_total,
            "moments_unique_sharers_30d": uniq_30d,
            "moments_last_share_ts": last_share_ts,
            "payments_total_packets_issued": payments_total_packets_issued,
            "payments_total_packets_claimed": payments_total_packets_claimed,
            "payments_total_amount_cents": payments_total_amount_cents,
            "payments_claimed_amount_cents": payments_claimed_amount_cents,
            "payments_unique_creators": payments_unique_creators,
            "payments_unique_claimants": payments_unique_claimants,
            "payments_total_packets_issued_30d": payments_total_packets_issued_30d,
            "payments_total_packets_claimed_30d": payments_total_packets_claimed_30d,
            "payments_total_amount_cents_30d": payments_total_amount_cents_30d,
            "payments_claimed_amount_cents_30d": payments_claimed_amount_cents_30d,
            "payments_unique_creators_30d": payments_unique_creators_30d,
            "payments_unique_claimants_30d": payments_unique_claimants_30d,
        }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/official_accounts/notifications", response_class=JSONResponse)
def official_notifications(request: Request):
    """
    Returns per-account notification modes for the current user.
    """
    user_key = _official_cookie_key(request)
    try:
        with _officials_session() as s:
            rows = (
                s.execute(
                    _sa_select(OfficialNotificationDB).where(
                        OfficialNotificationDB.user_key == user_key
                    )
                )
                .scalars()
                .all()
            )
            modes = {row.account_id: row.mode for row in rows if row.mode}
        return {"modes": modes}
    except HTTPException:
        raise
    except Exception:
        # Soft-fail: empty map if notifications table is unavailable.
        return {"modes": {}}


@app.post(
    "/official_accounts/{account_id}/notification_mode",
    response_class=JSONResponse,
)
def official_set_notification_mode(
    account_id: str,
    request: Request,
    body: OfficialNotificationIn,
):
    """
    Sets or clears per-user notification mode for a single official account.
    Modes: full, summary, muted. Omitting or "full" clears the override.
    """
    user_key = _official_cookie_key(request)
    raw_mode = body.mode
    if raw_mode is None:
        norm_mode: str | None = None
    else:
        m = raw_mode.strip().lower()
        if m not in {"full", "summary", "muted"}:
            raise HTTPException(status_code=400, detail="invalid mode")
        norm_mode = m
    try:
        with _officials_session() as s:
            acc = s.get(OfficialAccountDB, account_id)
            if not acc or not acc.enabled:
                raise HTTPException(status_code=404, detail="unknown official account")
            stmt = _sa_select(OfficialNotificationDB).where(
                OfficialNotificationDB.user_key == user_key,
                OfficialNotificationDB.account_id == account_id,
            )
            existing = s.execute(stmt).scalars().first()
            if norm_mode is None or norm_mode == "full":
                if existing is not None:
                    s.delete(existing)
                    s.commit()
                result_mode = "full"
            else:
                if existing is None:
                    existing = OfficialNotificationDB(
                        user_key=user_key,
                        account_id=account_id,
                        mode=norm_mode,
                    )
                    s.add(existing)
                else:
                    existing.mode = norm_mode
                s.commit()
                result_mode = norm_mode
        try:
            emit_event(
                "officials",
                "notif_mode_set",
                {
                    "user_key": user_key,
                    "account_id": account_id,
                    "mode": result_mode,
                },
            )
        except Exception:
            pass
        return {"account_id": account_id, "mode": result_mode}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get(
    "/official_accounts/{account_id}/auto_replies",
    response_class=JSONResponse,
)
def official_auto_replies(account_id: str, request: Request) -> dict[str, Any]:
    """
    Returns enabled auto‑reply rules for a single Official account.

    The main consumer is the Mirsaal chat client, which can use the
    first "welcome" rule to display a WeChat‑style greeting bubble
    when a user first opens a conversation with an Official account.
    """

    try:
        _ = _official_cookie_key(request)
    except Exception:
        # Treat missing cookie the same as anonymous; auto‑replies are
        # public metadata and do not leak sensitive state.
        pass
    try:
        with _officials_session() as s:
            acc = s.get(OfficialAccountDB, account_id)
            if not acc or not acc.enabled:
                raise HTTPException(status_code=404, detail="unknown official account")
            stmt = _sa_select(OfficialAutoReplyDB).where(
                OfficialAutoReplyDB.account_id == account_id,
                OfficialAutoReplyDB.enabled.is_(True),
            ).order_by(OfficialAutoReplyDB.id.asc())
            rows = s.execute(stmt).scalars().all()
            rules: list[dict[str, Any]] = []
            for row in rows:
                rules.append(
                    {
                        "id": row.id,
                        "account_id": row.account_id,
                        "kind": row.kind,
                        "keyword": row.keyword,
                        "text": row.text,
                        "enabled": bool(row.enabled),
                    }
                )
        return {"rules": rules}
    except HTTPException:
        raise
    except Exception:
        # Soft‑fail for deployments that have not yet migrated the
        # auto‑replies table.
        return {"rules": []}


@app.get("/official_accounts/{account_id}/locations", response_class=JSONResponse)
async def official_account_locations(request: Request, account_id: str, limit: int = 50):
    try:
        limit_val = max(1, min(limit, 200))
        _ = _official_cookie_key(request)
        with _officials_session() as s:
            acc = s.get(OfficialAccountDB, account_id)
            if not acc or not acc.enabled:
                raise HTTPException(status_code=404, detail="unknown official account")
            stmt = (
                _sa_select(OfficialLocationDB)
                .where(OfficialLocationDB.account_id == account_id)
                .order_by(OfficialLocationDB.id.asc())
                .limit(limit_val)
            )
            rows = s.execute(stmt).scalars().all()
            items: list[dict[str, Any]] = []
            for row in rows:
                items.append(
                    OfficialLocationOut(
                        id=row.id,
                        name=row.name,
                        city=row.city,
                        address=row.address,
                        lat=row.lat,
                        lon=row.lon,
                        phone=row.phone,
                        opening_hours=row.opening_hours,
                    ).dict()
                )
        return {"locations": items}
    except HTTPException:
        raise
    except Exception:
        # No fallback locations configured; behave like empty list or 404.
        raise HTTPException(status_code=404, detail="locations not available")


@app.post("/official_accounts/{account_id}/follow", response_class=JSONResponse)
async def follow_official_account(account_id: str, request: Request):
    ck = _official_cookie_key(request)
    try:
        with _officials_session() as s:
            acc = s.get(OfficialAccountDB, account_id)
            if not acc or not acc.enabled:
                raise HTTPException(status_code=404, detail="unknown official account")
            existing = s.execute(
                _sa_select(OfficialFollowDB).where(
                    OfficialFollowDB.user_key == ck,
                    OfficialFollowDB.account_id == account_id,
                )
            ).scalars().first()
            if not existing:
                s.add(OfficialFollowDB(user_key=ck, account_id=account_id))
                s.commit()
        try:
            emit_event(
                "officials",
                f"follow_{account_id}",
                {"user_key": ck},
            )
        except Exception:
            pass
        return {"status": "ok", "followed": True}
    except HTTPException:
        raise
    except Exception:
        if account_id not in _OFFICIAL_ACCOUNTS:
            raise HTTPException(status_code=404, detail="unknown official account")
        s = _OFFICIAL_FOLLOWS.setdefault(ck, set(_OFFICIAL_ACCOUNTS.keys()))
        s.add(account_id)
        return {"status": "ok", "followed": True}


@app.post("/official_accounts/{account_id}/unfollow", response_class=JSONResponse)
async def unfollow_official_account(account_id: str, request: Request):
    ck = _official_cookie_key(request)
    try:
        with _officials_session() as s:
            acc = s.get(OfficialAccountDB, account_id)
            if not acc or not acc.enabled:
                raise HTTPException(status_code=404, detail="unknown official account")
            row = s.execute(
                _sa_select(OfficialFollowDB).where(
                    OfficialFollowDB.user_key == ck,
                    OfficialFollowDB.account_id == account_id,
                )
            ).scalars().first()
            if row:
                s.delete(row)
                s.commit()
        try:
            emit_event(
                "officials",
                f"unfollow_{account_id}",
                {"user_key": ck},
            )
        except Exception:
            pass
        return {"status": "ok", "followed": False}
    except HTTPException:
        raise
    except Exception:
        if account_id not in _OFFICIAL_ACCOUNTS:
            raise HTTPException(status_code=404, detail="unknown official account")
        s = _OFFICIAL_FOLLOWS.setdefault(ck, set(_OFFICIAL_ACCOUNTS.keys()))
        if account_id in s:
            s.remove(account_id)
        return {"status": "ok", "followed": False}


@app.post("/channels/accounts/{account_id}/follow", response_class=JSONResponse)
async def channels_follow_account(account_id: str, request: Request):
    """
    Follow a Channel for the given Official account.

    This is intentionally separate from OfficialFollowDB so users can
    follow a service as a channel without affecting their Official
    subscriptions, similar to WeChat's Channels follower graph.
    """
    user_key = _channels_user_key(request)
    try:
      with _officials_session() as s:
          acc = s.get(OfficialAccountDB, account_id)
          if not acc or not acc.enabled:
              raise HTTPException(
                  status_code=404, detail="unknown official account"
              )
          existing = s.execute(
              _sa_select(ChannelFollowDB).where(
                  ChannelFollowDB.user_key == user_key,
                  ChannelFollowDB.account_id == account_id,
              )
          ).scalars().first()
          if not existing:
              s.add(
                  ChannelFollowDB(
                      user_key=user_key,
                      account_id=account_id,
                  )
              )
              s.commit()
      try:
          emit_event(
              "channels",
              "follow",
              {"user_key": user_key, "account_id": account_id},
          )
      except Exception:
          pass
      return {"status": "ok", "followed": True}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/channels/accounts/{account_id}/unfollow", response_class=JSONResponse)
async def channels_unfollow_account(account_id: str, request: Request):
    """
    Unfollow a Channel for the given Official account.
    """
    user_key = _channels_user_key(request)
    try:
      with _officials_session() as s:
          acc = s.get(OfficialAccountDB, account_id)
          if not acc or not acc.enabled:
              raise HTTPException(
                  status_code=404, detail="unknown official account"
              )
          row = s.execute(
              _sa_select(ChannelFollowDB).where(
                  ChannelFollowDB.user_key == user_key,
                  ChannelFollowDB.account_id == account_id,
              )
          ).scalars().first()
          if row:
              s.delete(row)
              s.commit()
      try:
          emit_event(
              "channels",
              "unfollow",
              {"user_key": user_key, "account_id": account_id},
          )
      except Exception:
          pass
      return {"status": "ok", "followed": False}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
